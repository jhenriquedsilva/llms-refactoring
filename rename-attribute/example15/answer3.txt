02-05-2025, 10:53

### Review of Rename Attribute Refactoring Opportunities

Upon reviewing the code, the **main variable/attribute names** are:

- `runner` (InternalRunner)
- `testClass` (Class<?>)
- `filterRequested` (boolean)
- `delegate` (Filter, in the inner class)

Let's check if any identifier does **not clearly express its intent** or conflicts with established naming conventions.

#### Potential Targets:
- `runner`: A bit generic, but since the class is called `StrictRunner`, this `runner` is the underlying runner being wrapped. For clarity, renaming to something like `underlyingRunner` would improve readability and intent.
- `testClass`: Clear usage — refers to the class being tested.
- `filterRequested`: Its purpose is to track if a filter was requested. The name is acceptable, but could be more explicitly named as `isFilterRequested` (following boolean naming conventions) for clarity.
- `delegate` (RecordingFilter): This is a common pattern for wrapped or proxied objects. However, `delegate` could be more specifically named `wrappedFilter`.

#### Suggestion

- **Rename** `runner` → `underlyingRunner`
- **Rename** `filterRequested` → `isFilterRequested`
- **Rename** `delegate` → `wrappedFilter`

---

## Refactored Code

```java
package org.mockito.internal.runners;

import org.junit.runner.Description;
import org.junit.runner.manipulation.Filter;
import org.junit.runner.manipulation.NoTestsRemainException;
import org.junit.runner.notification.RunNotifier;
import org.mockito.Mockito;
import org.mockito.internal.junit.UnnecessaryStubbingsReporter;
import org.mockito.internal.runners.util.FailureDetector;

public class StrictRunner implements InternalRunner {

    private final Class<?> testClass;
    private final InternalRunner underlyingRunner;
    private boolean isFilterRequested;

    /**
     * @param underlyingRunner - the runner to wrap around
     * @param testClass - for reporting purposes
     */
    public StrictRunner(InternalRunner underlyingRunner, Class<?> testClass) {
        this.underlyingRunner = underlyingRunner;
        this.testClass = testClass;
        this.isFilterRequested = false;
    }

    @Override
    public void run(RunNotifier notifier) {
        // TODO need to be able to opt in for full stack trace instead of just relying on the stack
        // trace filter
        UnnecessaryStubbingsReporter reporter = new UnnecessaryStubbingsReporter();
        FailureDetector listener = new FailureDetector();

        Mockito.framework().addListener(reporter);
        try {
            // add listener that detects test failures
            notifier.addListener(listener);
            underlyingRunner.run(notifier);
        } finally {
            Mockito.framework().removeListener(reporter);
        }

        if (!isFilterRequested && listener.isSuccessful()) {
            // only report when:
            // 1. if all tests from given test have ran (tests skipped is false)
            //   Otherwise we would report unnecessary stubs even if the user runs just single test
            // from the class
            // 2. tests are successful (we don't want to add an extra failure on top of any existing
            // failure, to avoid confusion)
            reporter.validateUnusedStubs(testClass, notifier);
        }
    }

    @Override
    public Description getDescription() {
        return underlyingRunner.getDescription();
    }

    @Override
    public void filter(Filter filter) throws NoTestsRemainException {
        Filter recordingFilter = new RecordingFilter(filter);
        underlyingRunner.filter(recordingFilter);
    }

    private class RecordingFilter extends Filter {

        private final Filter wrappedFilter;

        public RecordingFilter(Filter wrappedFilter) {
            this.wrappedFilter = wrappedFilter;
        }

        @Override
        public void apply(Object child) throws NoTestsRemainException {
            wrappedFilter.apply(child);
        }

        @Override
        public Filter intersect(Filter second) {
            return wrappedFilter.intersect(second);
        }

        @Override
        public boolean shouldRun(Description description) {
            boolean result = wrappedFilter.shouldRun(description);
            if (!result) {
                isFilterRequested = true;
            }
            return result;
        }

        @Override
        public String describe() {
            return wrappedFilter.describe();
        }
    }
}
```

---

**Summary**:
The refactoring improves identifier clarity to better communicate the intent of each attribute, adhering to common Java conventions and enhancing overall code readability.

Compiles
Tests pass