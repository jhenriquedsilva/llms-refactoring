02-05-2025, 08:54

Below are detailed observations and recommended rename-attribute (rename-field) refactorings for improving identifier readability in the provided class. The focus is on fields and variables whose names are unnecessarily abbreviated or inconsistent.

---

### Observations and Candidate Refactorings

#### 1. SDiff class fields:
- `leftS` and `rightS` are non-descriptive abbreviations. "S" appears to stand for "Supplier".
- **Proposed new names:**
  - `leftSupplier` instead of `leftS`
  - `rightSupplier` instead of `rightS`

#### 2. SDiff constructor:
- Update parameter names to be consistent.

#### 3. DiffBuilder class fields:
- `diffs` is clear.
- `objectsEquals` could be improved to `objectsAreEqual` for better readability.
- `left`, `right`, `style`, and `toStringFormat` are fine.

#### 4. General consistency:
- `lhs` and `rhs` for 'left hand side' and 'right hand side' are common and acceptable as parameter names.

---

## Refactored Code

```java
package org.apache.commons.lang3.builder;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.function.Supplier;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.ObjectUtils;

public class DiffBuilder<T> implements Builder<DiffResult<T>> {

    private static final class SDiff<T> extends Diff<T> {

        private static final long serialVersionUID = 1L;
        private final transient Supplier<T> leftSupplier;
        private final transient Supplier<T> rightSupplier;

        private SDiff(final String fieldName, final Supplier<T> leftSupplier, final Supplier<T> rightSupplier, final Class<T> type) {
            super(fieldName, type);
            this.leftSupplier = leftSupplier;
            this.rightSupplier = rightSupplier;
        }

        @Override
        public T getLeft() {
            return leftSupplier.get();
        }

        @Override
        public T getRight() {
            return rightSupplier.get();
        }
    }
    static final String TO_STRING_FORMAT = "%s differs from %s";

    private final List<Diff<?>> diffs;
    private final boolean objectsAreEqual;
    private final T left;
    private final T right;
    private final ToStringStyle style;
    private final String toStringFormat;

    /**
     * Constructs a builder for the specified objects with the specified style.
     *
     * <p>
     * If {@code lhs == rhs} or {@code lhs.equals(rhs)} then the builder will
     * not evaluate any calls to {@code append(...)} and will return an empty
     * {@link DiffResult} when {@link #build()} is executed.
     * </p>
     *
     * <p>
     * This delegates to {@link #DiffBuilder(Object, Object, ToStringStyle, boolean)}
     * with the testTriviallyEqual flag enabled.
     * </p>
     *
     * @param lhs
     *            {@code this} object
     * @param rhs
     *            the object to diff against
     * @param style
     *            the style will use when outputting the objects, {@code null}
     *            uses the default
     * @throws NullPointerException
     *             if {@code lhs} or {@code rhs} is {@code null}
     */
    public DiffBuilder(final T lhs, final T rhs, final ToStringStyle style) {
        this(lhs, rhs, style, true);
    }

    /**
     * Constructs a builder for the specified objects with the specified style.
     *
     * <p>
     * If {@code lhs == rhs} or {@code lhs.equals(rhs)} then the builder will
     * not evaluate any calls to {@code append(...)} and will return an empty
     * {@link DiffResult} when {@link #build()} is executed.
     * </p>
     *
     * @param lhs
     *            {@code this} object
     * @param rhs
     *            the object to diff against
     * @param style
     *            the style will use when outputting the objects, {@code null}
     *            uses the default
     * @param testObjectsEquals
     *            If true, this will test if lhs and rhs are the same or equal.
     *            All of the append(fieldName, lhs, rhs) methods will abort
     *            without creating a field {@link Diff} if the trivially equal
     *            test is enabled and returns true.  The result of this test
     *            is never changed throughout the life of this {@link DiffBuilder}.
     * @throws NullPointerException
     *             if {@code lhs} or {@code rhs} is {@code null}
     * @since 3.4
     */
    public DiffBuilder(final T lhs, final T rhs, final ToStringStyle style, final boolean testObjectsEquals) {
        this.left = Objects.requireNonNull(lhs, "lhs");
        this.right = Objects.requireNonNull(rhs, "rhs");
        this.diffs = new ArrayList<>();
        this.toStringFormat = DiffBuilder.TO_STRING_FORMAT;
        this.style = style != null ? style : ToStringStyle.DEFAULT_STYLE;
        // Don't compare any fields if objects are equal
        this.objectsAreEqual = testObjectsEquals && Objects.equals(lhs, rhs);
    }

    private <F> DiffBuilder<T> add(final String fieldName, final Supplier<F> leftSupplier, final Supplier<F> rightSupplier, final Class<F> type) {
        diffs.add(new SDiff<>(Objects.requireNonNull(fieldName, "fieldName"), leftSupplier, rightSupplier, type));
        return this;
    }

    // ... rest of the class remains unchanged except "objectsEquals" -> "objectsAreEqual" ...

    public DiffBuilder<T> append(final String fieldName, final boolean lhs, final boolean rhs) {
        return objectsAreEqual || lhs == rhs ? this : add(fieldName, () -> Boolean.valueOf(lhs), () -> Boolean.valueOf(rhs), Boolean.class);
    }

    public DiffBuilder<T> append(final String fieldName, final boolean[] lhs, final boolean[] rhs) {
        return objectsAreEqual || Arrays.equals(lhs, rhs) ? this : add(fieldName, () -> ArrayUtils.toObject(lhs), () -> ArrayUtils.toObject(rhs), Boolean[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final byte lhs, final byte rhs) {
        return objectsAreEqual || lhs == rhs ? this : add(fieldName, () -> Byte.valueOf(lhs), () -> Byte.valueOf(rhs), Byte.class);
    }

    public DiffBuilder<T> append(final String fieldName, final byte[] lhs, final byte[] rhs) {
        return objectsAreEqual || Arrays.equals(lhs, rhs) ? this : add(fieldName, () -> ArrayUtils.toObject(lhs), () -> ArrayUtils.toObject(rhs), Byte[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final char lhs, final char rhs) {
        return objectsAreEqual || lhs == rhs ? this : add(fieldName, () -> Character.valueOf(lhs), () -> Character.valueOf(rhs), Character.class);
    }

    public DiffBuilder<T> append(final String fieldName, final char[] lhs, final char[] rhs) {
        return objectsAreEqual || Arrays.equals(lhs, rhs) ? this : add(fieldName, () -> ArrayUtils.toObject(lhs), () -> ArrayUtils.toObject(rhs), Character[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final DiffResult<T> diffResult) {
        Objects.requireNonNull(diffResult, "diffResult");
        if (objectsAreEqual) {
            return this;
        }
        diffResult.getDiffs().forEach(diff -> append(fieldName + "." + diff.getFieldName(), diff.getLeft(), diff.getRight()));
        return this;
    }

    public DiffBuilder<T> append(final String fieldName, final double lhs, final double rhs) {
        return objectsAreEqual || Double.doubleToLongBits(lhs) == Double.doubleToLongBits(rhs) ? this
                : add(fieldName, () -> Double.valueOf(lhs), () -> Double.valueOf(rhs), Double.class);
    }

    public DiffBuilder<T> append(final String fieldName, final double[] lhs, final double[] rhs) {
        return objectsAreEqual || Arrays.equals(lhs, rhs) ? this : add(fieldName, () -> ArrayUtils.toObject(lhs), () -> ArrayUtils.toObject(rhs), Double[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final float lhs, final float rhs) {
        return objectsAreEqual || Float.floatToIntBits(lhs) == Float.floatToIntBits(rhs) ? this
                : add(fieldName, () -> Float.valueOf(lhs), () -> Float.valueOf(rhs), Float.class);
    }

    public DiffBuilder<T> append(final String fieldName, final float[] lhs, final float[] rhs) {
        return objectsAreEqual || Arrays.equals(lhs, rhs) ? this : add(fieldName, () -> ArrayUtils.toObject(lhs), () -> ArrayUtils.toObject(rhs), Float[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final int lhs, final int rhs) {
        return objectsAreEqual || lhs == rhs ? this : add(fieldName, () -> Integer.valueOf(lhs), () -> Integer.valueOf(rhs), Integer.class);
    }

    public DiffBuilder<T> append(final String fieldName, final int[] lhs, final int[] rhs) {
        return objectsAreEqual || Arrays.equals(lhs, rhs) ? this : add(fieldName, () -> ArrayUtils.toObject(lhs), () -> ArrayUtils.toObject(rhs), Integer[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final long lhs, final long rhs) {
        return objectsAreEqual || lhs == rhs ? this : add(fieldName, () -> Long.valueOf(lhs), () -> Long.valueOf(rhs), Long.class);
    }

    public DiffBuilder<T> append(final String fieldName, final long[] lhs, final long[] rhs) {
        return objectsAreEqual || Arrays.equals(lhs, rhs) ? this : add(fieldName, () -> ArrayUtils.toObject(lhs), () -> ArrayUtils.toObject(rhs), Long[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final Object lhs, final Object rhs) {
        if (objectsAreEqual || lhs == rhs) {
            return this;
        }
        final Object objectToTest = lhs != null ? lhs : rhs;
        if (ObjectUtils.isArray(objectToTest)) {
            if (objectToTest instanceof boolean[]) {
                return append(fieldName, (boolean[]) lhs, (boolean[]) rhs);
            }
            if (objectToTest instanceof byte[]) {
                return append(fieldName, (byte[]) lhs, (byte[]) rhs);
            }
            if (objectToTest instanceof char[]) {
                return append(fieldName, (char[]) lhs, (char[]) rhs);
            }
            if (objectToTest instanceof double[]) {
                return append(fieldName, (double[]) lhs, (double[]) rhs);
            }
            if (objectToTest instanceof float[]) {
                return append(fieldName, (float[]) lhs, (float[]) rhs);
            }
            if (objectToTest instanceof int[]) {
                return append(fieldName, (int[]) lhs, (int[]) rhs);
            }
            if (objectToTest instanceof long[]) {
                return append(fieldName, (long[]) lhs, (long[]) rhs);
            }
            if (objectToTest instanceof short[]) {
                return append(fieldName, (short[]) lhs, (short[]) rhs);
            }
            return append(fieldName, (Object[]) lhs, (Object[]) rhs);
        }
        if (Objects.equals(lhs, rhs)) {
            return this;
        }
        add(fieldName, () -> lhs, () -> rhs, Object.class);
        return this;
    }

    public DiffBuilder<T> append(final String fieldName, final Object[] lhs, final Object[] rhs) {
        return objectsAreEqual || Arrays.equals(lhs, rhs) ? this : add(fieldName, () -> lhs, () -> rhs, Object[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final short lhs, final short rhs) {
        return objectsAreEqual || lhs == rhs ? this : add(fieldName, () -> Short.valueOf(lhs), () -> Short.valueOf(rhs), Short.class);
    }

    public DiffBuilder<T> append(final String fieldName, final short[] lhs, final short[] rhs) {
        return objectsAreEqual || Arrays.equals(lhs, rhs) ? this : add(fieldName, () -> ArrayUtils.toObject(lhs), () -> ArrayUtils.toObject(rhs), Short[].class);
    }

    @Override
    public DiffResult<T> build() {
        return new DiffResult<>(left, right, diffs, style, toStringFormat);
    }
}
```

---

**Summary of changes:**
- Renamed `leftS` → `leftSupplier`, `rightS` → `rightSupplier` in `SDiff`.
- Renamed `objectsEquals` → `objectsAreEqual` throughout `DiffBuilder`.
- Adjusted constructor and methods for new field names.

**These renames make the code's intent clearer and improve maintainability.**



FINISHED REFACTORING 0



**Refactoring Opportunities**

Yes, there are clear rename attribute refactoring opportunities in the class, most notably:

- The names `lhs` and `rhs` (left hand side, right hand side) for object/class fields and method parameters are not as expressive as they could be. Renaming these to `left` and `right` would improve clarity/readability.
- Similarly, in the inner class `SDiff`, the attribute names `leftS` and `rightS` are not very clear. They can be clearly renamed to `leftSupplier` and `rightSupplier`.
- The field `objectsEquals` could be more clearly named as `objectsAreEqual` to make it more representative of a boolean predicate.

**Applying these changes throughout the codebase gives:**

---

```java
package org.apache.commons.lang3.builder;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.function.Supplier;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.ObjectUtils;

public class DiffBuilder<T> implements Builder<DiffResult<T>> {

    private static final class SDiff<T> extends Diff<T> {

        private static final long serialVersionUID = 1L;
        private final transient Supplier<T> leftSupplier;
        private final transient Supplier<T> rightSupplier;

        private SDiff(final String fieldName, final Supplier<T> leftSupplier, final Supplier<T> rightSupplier, final Class<T> type) {
            super(fieldName, type);
            this.leftSupplier = leftSupplier;
            this.rightSupplier = rightSupplier;
        }

        @Override
        public T getLeft() {
            return leftSupplier.get();
        }

        @Override
        public T getRight() {
            return rightSupplier.get();
        }

    }

    static final String TO_STRING_FORMAT = "%s differs from %s";

    private final List<Diff<?>> diffs;
    private final boolean objectsAreEqual;
    private final T left;
    private final T right;
    private final ToStringStyle style;
    private final String toStringFormat;

    /**
     * Constructs a builder for the specified objects with the specified style.
     *
     * <p>
     * If {@code left == right} or {@code left.equals(right)} then the builder will
     * not evaluate any calls to {@code append(...)} and will return an empty
     * {@link DiffResult} when {@link #build()} is executed.
     * </p>
     *
     * <p>
     * This delegates to {@link #DiffBuilder(Object, Object, ToStringStyle, boolean)}
     * with the testTriviallyEqual flag enabled.
     * </p>
     *
     * @param left
     *            {@code this} object
     * @param right
     *            the object to diff against
     * @param style
     *            the style will use when outputting the objects, {@code null}
     *            uses the default
     * @throws NullPointerException
     *             if {@code left} or {@code right} is {@code null}
     */
    public DiffBuilder(final T left, final T right, final ToStringStyle style) {
        this(left, right, style, true);
    }

    /**
     * Constructs a builder for the specified objects with the specified style.
     *
     * <p>
     * If {@code left == right} or {@code left.equals(right)} then the builder will
     * not evaluate any calls to {@code append(...)} and will return an empty
     * {@link DiffResult} when {@link #build()} is executed.
     * </p>
     *
     * @param left
     *            {@code this} object
     * @param right
     *            the object to diff against
     * @param style
     *            the style will use when outputting the objects, {@code null}
     *            uses the default
     * @param testObjectsAreEqual
     *            If true, this will test if left and right are the same or equal.
     *            All of the append(fieldName, left, right) methods will abort
     *            without creating a field {@link Diff} if the trivially equal
     *            test is enabled and returns true.  The result of this test
     *            is never changed throughout the life of this {@link DiffBuilder}.
     * @throws NullPointerException
     *             if {@code left} or {@code right} is {@code null}
     * @since 3.4
     */
    public DiffBuilder(final T left, final T right, final ToStringStyle style, final boolean testObjectsAreEqual) {
        this.left = Objects.requireNonNull(left, "left");
        this.right = Objects.requireNonNull(right, "right");
        this.diffs = new ArrayList<>();
        this.toStringFormat = DiffBuilder.TO_STRING_FORMAT;
        this.style = style != null ? style : ToStringStyle.DEFAULT_STYLE;
        // Don't compare any fields if objects are equal
        this.objectsAreEqual = testObjectsAreEqual && Objects.equals(left, right);
    }

    private <F> DiffBuilder<T> add(final String fieldName, final Supplier<F> left, final Supplier<F> right, final Class<F> type) {
        diffs.add(new SDiff<>(Objects.requireNonNull(fieldName, "fieldName"), left, right, type));
        return this;
    }

    // All append methods:
    public DiffBuilder<T> append(final String fieldName, final boolean left, final boolean right) {
        return objectsAreEqual || left == right ? this : add(fieldName, () -> Boolean.valueOf(left), () -> Boolean.valueOf(right), Boolean.class);
    }

    public DiffBuilder<T> append(final String fieldName, final boolean[] left, final boolean[] right) {
        return objectsAreEqual || Arrays.equals(left, right) ? this : add(fieldName, () -> ArrayUtils.toObject(left), () -> ArrayUtils.toObject(right), Boolean[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final byte left, final byte right) {
        return objectsAreEqual || left == right ? this : add(fieldName, () -> Byte.valueOf(left), () -> Byte.valueOf(right), Byte.class);
    }

    public DiffBuilder<T> append(final String fieldName, final byte[] left, final byte[] right) {
        return objectsAreEqual || Arrays.equals(left, right) ? this : add(fieldName, () -> ArrayUtils.toObject(left), () -> ArrayUtils.toObject(right), Byte[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final char left, final char right) {
        return objectsAreEqual || left == right ? this : add(fieldName, () -> Character.valueOf(left), () -> Character.valueOf(right), Character.class);
    }

    public DiffBuilder<T> append(final String fieldName, final char[] left, final char[] right) {
        return objectsAreEqual || Arrays.equals(left, right) ? this : add(fieldName, () -> ArrayUtils.toObject(left), () -> ArrayUtils.toObject(right), Character[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final DiffResult<T> diffResult) {
        Objects.requireNonNull(diffResult, "diffResult");
        if (objectsAreEqual) {
            return this;
        }
        diffResult.getDiffs().forEach(diff -> append(fieldName + "." + diff.getFieldName(), diff.getLeft(), diff.getRight()));
        return this;
    }

    public DiffBuilder<T> append(final String fieldName, final double left, final double right) {
        return objectsAreEqual || Double.doubleToLongBits(left) == Double.doubleToLongBits(right) ? this
                : add(fieldName, () -> Double.valueOf(left), () -> Double.valueOf(right), Double.class);
    }

    public DiffBuilder<T> append(final String fieldName, final double[] left, final double[] right) {
        return objectsAreEqual || Arrays.equals(left, right) ? this : add(fieldName, () -> ArrayUtils.toObject(left), () -> ArrayUtils.toObject(right), Double[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final float left, final float right) {
        return objectsAreEqual || Float.floatToIntBits(left) == Float.floatToIntBits(right) ? this
                : add(fieldName, () -> Float.valueOf(left), () -> Float.valueOf(right), Float.class);
    }

    public DiffBuilder<T> append(final String fieldName, final float[] left, final float[] right) {
        return objectsAreEqual || Arrays.equals(left, right) ? this : add(fieldName, () -> ArrayUtils.toObject(left), () -> ArrayUtils.toObject(right), Float[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final int left, final int right) {
        return objectsAreEqual || left == right ? this : add(fieldName, () -> Integer.valueOf(left), () -> Integer.valueOf(right), Integer.class);
    }

    public DiffBuilder<T> append(final String fieldName, final int[] left, final int[] right) {
        return objectsAreEqual || Arrays.equals(left, right) ? this : add(fieldName, () -> ArrayUtils.toObject(left), () -> ArrayUtils.toObject(right), Integer[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final long left, final long right) {
        return objectsAreEqual || left == right ? this : add(fieldName, () -> Long.valueOf(left), () -> Long.valueOf(right), Long.class);
    }

    public DiffBuilder<T> append(final String fieldName, final long[] left, final long[] right) {
        return objectsAreEqual || Arrays.equals(left, right) ? this : add(fieldName, () -> ArrayUtils.toObject(left), () -> ArrayUtils.toObject(right), Long[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final Object left, final Object right) {
        if (objectsAreEqual || left == right) {
            return this;
        }
        // right cannot be null, as left != right
        final Object objectToTest = left != null ? left : right;
        if (ObjectUtils.isArray(objectToTest)) {
            if (objectToTest instanceof boolean[]) {
                return append(fieldName, (boolean[]) left, (boolean[]) right);
            }
            if (objectToTest instanceof byte[]) {
                return append(fieldName, (byte[]) left, (byte[]) right);
            }
            if (objectToTest instanceof char[]) {
                return append(fieldName, (char[]) left, (char[]) right);
            }
            if (objectToTest instanceof double[]) {
                return append(fieldName, (double[]) left, (double[]) right);
            }
            if (objectToTest instanceof float[]) {
                return append(fieldName, (float[]) left, (float[]) right);
            }
            if (objectToTest instanceof int[]) {
                return append(fieldName, (int[]) left, (int[]) right);
            }
            if (objectToTest instanceof long[]) {
                return append(fieldName, (long[]) left, (long[]) right);
            }
            if (objectToTest instanceof short[]) {
                return append(fieldName, (short[]) left, (short[]) right);
            }
            return append(fieldName, (Object[]) left, (Object[]) right);
        }
        // Not array type
        if (Objects.equals(left, right)) {
            return this;
        }
        add(fieldName, () -> left, () -> right, Object.class);
        return this;
    }

    public DiffBuilder<T> append(final String fieldName, final Object[] left, final Object[] right) {
        return objectsAreEqual || Arrays.equals(left, right) ? this : add(fieldName, () -> left, () -> right, Object[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final short left, final short right) {
        return objectsAreEqual || left == right ? this : add(fieldName, () -> Short.valueOf(left), () -> Short.valueOf(right), Short.class);
    }

    public DiffBuilder<T> append(final String fieldName, final short[] left, final short[] right) {
        return objectsAreEqual || Arrays.equals(left, right) ? this : add(fieldName, () -> ArrayUtils.toObject(left), () -> ArrayUtils.toObject(right), Short[].class);
    }

    @Override
    public DiffResult<T> build() {
        return new DiffResult<>(left, right, diffs, style, toStringFormat);
    }
}
```

---

**Main refactoring points:**

- All *field* and *parameter* usages of `lhs`/`rhs` are changed to `left`/`right`.
- Parameter documentation (`@param`) is updated accordingly.
- `leftS`/`rightS` → `leftSupplier`/`rightSupplier`.
- `objectsEquals` → `objectsAreEqual`.

This makes the code more readable and idiomatic, especially for teams and new maintainers.

---

**If you need more aggressive refactoring (such as for method names or logic), let me know!**



FINISHED REFACTORING 1



## Review & Possible Refactoring

The prompt specifically asks to identify attribute (field) names with low readability/quality and rename them to improve readability. Let’s do a quick review and identify candidates for rename attribute refactoring:

### Class: `DiffBuilder<T>`

#### Attributes:
- **diffs** – List of Diff<?>
- **objectsEquals** – boolean
- **left** – T
- **right** – T
- **style** – ToStringStyle
- **toStringFormat** – String

#### Inner class: `SDiff<T>`
- **leftS** – Supplier<T>
- **rightS** – Supplier<T>

#### Static constant:
- **TO_STRING_FORMAT**

#### Most problematic field names:
- **leftS / rightS** (inner class, cryptic)
- **objectsEquals** (slightly unclear; could be `objectsAreEqual`)
- **diffs** (could be `differences`, but `diffs` is ok since its class is `DiffBuilder`)
- For main class’s `left` and `right`, these match the “lhs/rhs” in params, are clear for “left-hand side” and “right-hand side”; okay.
- **style** and **toStringFormat** are clear.

#### Conclusion:
The fields **leftS** and **rightS** in `SDiff<T>` are not very descriptive (`S` likely for "Supplier"), possibly confusing.
`objectsEquals` is only slightly off—could be improved to `objectsAreEqual`.

Let’s apply these changes:

1. Rename **leftS** to **leftSupplier**, **rightS** to **rightSupplier** in `SDiff`.
2. Rename **objectsEquals** to **objectsAreEqual** throughout the code (constructor, usage, etc).

Here is the refactored code:

---

```java
package org.apache.commons.lang3.builder;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.function.Supplier;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.ObjectUtils;

public class DiffBuilder<T> implements Builder<DiffResult<T>> {

    private static final class SDiff<T> extends Diff<T> {

        private static final long serialVersionUID = 1L;
        private final transient Supplier<T> leftSupplier;
        private final transient Supplier<T> rightSupplier;

        private SDiff(final String fieldName, final Supplier<T> leftSupplier, final Supplier<T> rightSupplier, final Class<T> type) {
            super(fieldName, type);
            this.leftSupplier = leftSupplier;
            this.rightSupplier = rightSupplier;
        }

        @Override
        public T getLeft() {
            return leftSupplier.get();
        }

        @Override
        public T getRight() {
            return rightSupplier.get();
        }

    }
    static final String TO_STRING_FORMAT = "%s differs from %s";

    private final List<Diff<?>> diffs;
    private final boolean objectsAreEqual;
    private final T left;
    private final T right;
    private final ToStringStyle style;
    private final String toStringFormat;

    public DiffBuilder(final T lhs, final T rhs, final ToStringStyle style) {
        this(lhs, rhs, style, true);
    }

    public DiffBuilder(final T lhs, final T rhs, final ToStringStyle style, final boolean testObjectsEquals) {
        this.left = Objects.requireNonNull(lhs, "lhs");
        this.right = Objects.requireNonNull(rhs, "rhs");
        this.diffs = new ArrayList<>();
        this.toStringFormat = DiffBuilder.TO_STRING_FORMAT;
        this.style = style != null ? style : ToStringStyle.DEFAULT_STYLE;
        // Don't compare any fields if objects are equal
        this.objectsAreEqual = testObjectsEquals && Objects.equals(lhs, rhs);
    }

    private <F> DiffBuilder<T> add(final String fieldName, final Supplier<F> left, final Supplier<F> right, final Class<F> type) {
        diffs.add(new SDiff<>(Objects.requireNonNull(fieldName, "fieldName"), left, right, type));
        return this;
    }

    public DiffBuilder<T> append(final String fieldName, final boolean lhs, final boolean rhs) {
        return objectsAreEqual || lhs == rhs ? this : add(fieldName, () -> Boolean.valueOf(lhs), () -> Boolean.valueOf(rhs), Boolean.class);
    }

    public DiffBuilder<T> append(final String fieldName, final boolean[] lhs, final boolean[] rhs) {
        return objectsAreEqual || Arrays.equals(lhs, rhs) ? this : add(fieldName, () -> ArrayUtils.toObject(lhs), () -> ArrayUtils.toObject(rhs), Boolean[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final byte lhs, final byte rhs) {
        return objectsAreEqual || lhs == rhs ? this : add(fieldName, () -> Byte.valueOf(lhs), () -> Byte.valueOf(rhs), Byte.class);
    }

    public DiffBuilder<T> append(final String fieldName, final byte[] lhs, final byte[] rhs) {
        return objectsAreEqual || Arrays.equals(lhs, rhs) ? this : add(fieldName, () -> ArrayUtils.toObject(lhs), () -> ArrayUtils.toObject(rhs), Byte[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final char lhs, final char rhs) {
        return objectsAreEqual || lhs == rhs ? this : add(fieldName, () -> Character.valueOf(lhs), () -> Character.valueOf(rhs), Character.class);
    }

    public DiffBuilder<T> append(final String fieldName, final char[] lhs, final char[] rhs) {
        return objectsAreEqual || Arrays.equals(lhs, rhs) ? this : add(fieldName, () -> ArrayUtils.toObject(lhs), () -> ArrayUtils.toObject(rhs), Character[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final DiffResult<T> diffResult) {
        Objects.requireNonNull(diffResult, "diffResult");
        if (objectsAreEqual) {
            return this;
        }
        diffResult.getDiffs().forEach(diff -> append(fieldName + "." + diff.getFieldName(), diff.getLeft(), diff.getRight()));
        return this;
    }

    public DiffBuilder<T> append(final String fieldName, final double lhs, final double rhs) {
        return objectsAreEqual || Double.doubleToLongBits(lhs) == Double.doubleToLongBits(rhs) ? this
                : add(fieldName, () -> Double.valueOf(lhs), () -> Double.valueOf(rhs), Double.class);
    }

    public DiffBuilder<T> append(final String fieldName, final double[] lhs, final double[] rhs) {
        return objectsAreEqual || Arrays.equals(lhs, rhs) ? this : add(fieldName, () -> ArrayUtils.toObject(lhs), () -> ArrayUtils.toObject(rhs), Double[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final float lhs, final float rhs) {
        return objectsAreEqual || Float.floatToIntBits(lhs) == Float.floatToIntBits(rhs) ? this
                : add(fieldName, () -> Float.valueOf(lhs), () -> Float.valueOf(rhs), Float.class);
    }

    public DiffBuilder<T> append(final String fieldName, final float[] lhs, final float[] rhs) {
        return objectsAreEqual || Arrays.equals(lhs, rhs) ? this : add(fieldName, () -> ArrayUtils.toObject(lhs), () -> ArrayUtils.toObject(rhs), Float[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final int lhs, final int rhs) {
        return objectsAreEqual || lhs == rhs ? this : add(fieldName, () -> Integer.valueOf(lhs), () -> Integer.valueOf(rhs), Integer.class);
    }

    public DiffBuilder<T> append(final String fieldName, final int[] lhs, final int[] rhs) {
        return objectsAreEqual || Arrays.equals(lhs, rhs) ? this : add(fieldName, () -> ArrayUtils.toObject(lhs), () -> ArrayUtils.toObject(rhs), Integer[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final long lhs, final long rhs) {
        return objectsAreEqual || lhs == rhs ? this : add(fieldName, () -> Long.valueOf(lhs), () -> Long.valueOf(rhs), Long.class);
    }

    public DiffBuilder<T> append(final String fieldName, final long[] lhs, final long[] rhs) {
        return objectsAreEqual || Arrays.equals(lhs, rhs) ? this : add(fieldName, () -> ArrayUtils.toObject(lhs), () -> ArrayUtils.toObject(rhs), Long[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final Object lhs, final Object rhs) {
        if (objectsAreEqual || lhs == rhs) {
            return this;
        }
        final Object objectToTest = lhs != null ? lhs : rhs;
        if (ObjectUtils.isArray(objectToTest)) {
            if (objectToTest instanceof boolean[]) {
                return append(fieldName, (boolean[]) lhs, (boolean[]) rhs);
            }
            if (objectToTest instanceof byte[]) {
                return append(fieldName, (byte[]) lhs, (byte[]) rhs);
            }
            if (objectToTest instanceof char[]) {
                return append(fieldName, (char[]) lhs, (char[]) rhs);
            }
            if (objectToTest instanceof double[]) {
                return append(fieldName, (double[]) lhs, (double[]) rhs);
            }
            if (objectToTest instanceof float[]) {
                return append(fieldName, (float[]) lhs, (float[]) rhs);
            }
            if (objectToTest instanceof int[]) {
                return append(fieldName, (int[]) lhs, (int[]) rhs);
            }
            if (objectToTest instanceof long[]) {
                return append(fieldName, (long[]) lhs, (long[]) rhs);
            }
            if (objectToTest instanceof short[]) {
                return append(fieldName, (short[]) lhs, (short[]) rhs);
            }
            return append(fieldName, (Object[]) lhs, (Object[]) rhs);
        }
        if (Objects.equals(lhs, rhs)) {
            return this;
        }
        add(fieldName, () -> lhs, () -> rhs, Object.class);
        return this;
    }

    public DiffBuilder<T> append(final String fieldName, final Object[] lhs, final Object[] rhs) {
        return objectsAreEqual || Arrays.equals(lhs, rhs) ? this : add(fieldName, () -> lhs, () -> rhs, Object[].class);
    }

    public DiffBuilder<T> append(final String fieldName, final short lhs, final short rhs) {
        return objectsAreEqual || lhs == rhs ? this : add(fieldName, () -> Short.valueOf(lhs), () -> Short.valueOf(rhs), Short.class);
    }

    public DiffBuilder<T> append(final String fieldName, final short[] lhs, final short[] rhs) {
        return objectsAreEqual || Arrays.equals(lhs, rhs) ? this : add(fieldName, () -> ArrayUtils.toObject(lhs), () -> ArrayUtils.toObject(rhs), Short[].class);
    }

    @Override
    public DiffResult<T> build() {
        return new DiffResult<>(left, right, diffs, style, toStringFormat);
    }

}
```

---

**Summary of Renaming:**
- `leftS` → `leftSupplier`
- `rightS` → `rightSupplier`
- `objectsEquals` → `objectsAreEqual`

If you have any questions or would like further refactorings (for example, method renames), let me know!
