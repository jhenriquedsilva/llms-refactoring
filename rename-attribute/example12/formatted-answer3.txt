package org.eclipse.jgit.revwalk;

import java.io.IOException;
import java.util.Arrays;

import org.eclipse.jgit.errors.IncorrectObjectTypeException;
import org.eclipse.jgit.errors.MissingObjectException;
import org.eclipse.jgit.internal.revwalk.AddToBitmapFilter;
import org.eclipse.jgit.internal.revwalk.AddToBitmapWithCacheFilter;
import org.eclipse.jgit.internal.revwalk.AddUnseenToBitmapFilter;
import org.eclipse.jgit.lib.AnyObjectId;
import org.eclipse.jgit.lib.BitmapIndex;
import org.eclipse.jgit.lib.BitmapIndex.Bitmap;
import org.eclipse.jgit.lib.BitmapIndex.BitmapBuilder;
import org.eclipse.jgit.lib.NullProgressMonitor;
import org.eclipse.jgit.lib.ObjectId;
import org.eclipse.jgit.lib.ProgressMonitor;
import org.eclipse.jgit.revwalk.filter.ObjectFilter;

public final class BitmapWalker {

    private final ObjectWalk walker;

    private final BitmapIndex bitmapIndex;

    private final ProgressMonitor progressMonitor;

    private long countOfBitmapIndexMisses;

    private AnyObjectId cachedCommit;

    private Bitmap cachedBitmap;

    public interface BitmapWalkListener {
        void onCommitSeen(ObjectId oid);

        void onCommitWithBitmap(ObjectId oid);

        void onCommitWithoutBitmap(ObjectId oid);

    }

    public static final BitmapWalkListener NO_LISTENER = new BitmapWalkListener() {
        @Override
        public void onCommitSeen(ObjectId oid) {
        }

        @Override
        public void onCommitWithBitmap(ObjectId oid) {
        }

        @Override
        public void onCommitWithoutBitmap(ObjectId oid) {
        }
    };

    private final BitmapWalkListener listener;

    public BitmapWalker(ObjectWalk walker, BitmapIndex bitmapIndex, ProgressMonitor progressMonitor) {
        this(walker, bitmapIndex, progressMonitor, NO_LISTENER);
    }

    public BitmapWalker(ObjectWalk walker, BitmapIndex bitmapIndex, ProgressMonitor progressMonitor, BitmapWalkListener listener) {
        this.walker = walker;
        this.bitmapIndex = bitmapIndex;
        this.progressMonitor = (progressMonitor == null) ? NullProgressMonitor.INSTANCE : progressMonitor;
        this.listener = listener;
    }

    public void setCachedCommit(AnyObjectId cachedCommit) {
        this.cachedCommit = cachedCommit;
    }

    public void setCachedBitmap(Bitmap cachedBitmap) {
        this.cachedBitmap = cachedBitmap;
    }

    public long getCountOfBitmapIndexMisses() {
        return countOfBitmapIndexMisses;
    }

    public BitmapBuilder findObjects(Iterable<? extends ObjectId> start, BitmapBuilder seen, boolean ignoreMissing) throws MissingObjectException, IncorrectObjectTypeException, IOException {
        if (!ignoreMissing) {
            return findObjectsWalk(start, seen, false);
        }
        try {
            return findObjectsWalk(start, seen, true);
        } catch (MissingObjectException ignore) {
        }
        final BitmapBuilder result = bitmapIndex.newBitmapBuilder();
        for (ObjectId obj : start) {
            Bitmap bitmap = bitmapIndex.getBitmap(obj);
            if (bitmap != null) {
                result.or(bitmap);
                listener.onCommitWithBitmap(obj);
            }
        }
        for (ObjectId obj : start) {
            if (result.contains(obj)) {
                continue;
            }
            try {
                result.or(findObjectsWalk(Arrays.asList(obj), result, false));
            } catch (MissingObjectException ignore) {
            }
        }
        return result;
    }

    private BitmapBuilder findObjectsWalk(Iterable<? extends ObjectId> start, BitmapBuilder seen, boolean ignoreMissingStart) throws MissingObjectException, IncorrectObjectTypeException, IOException {
        walker.reset();
        final BitmapBuilder resultBitmap = bitmapIndex.newBitmapBuilder();
        for (ObjectId obj : start) {
            Bitmap bitmap = bitmapIndex.getBitmap(obj);
            if (bitmap != null) {
                resultBitmap.or(bitmap);
                listener.onCommitWithBitmap(obj);
            }
        }
        boolean marked = false;
        for (ObjectId obj : start) {
            try {
                if (!resultBitmap.contains(obj)) {
                    walker.markStart(walker.parseAny(obj));
                    marked = true;
                }
            } catch (MissingObjectException e) {
                if (ignoreMissingStart) continue;
                throw e;
            }
        }
        if (marked) {
            if (cachedCommit != null) {
                walker.setRevFilter(new AddToBitmapWithCacheFilter(cachedCommit, cachedBitmap, resultBitmap));
            } else if (seen == null) {
                walker.setRevFilter(new AddToBitmapFilter(resultBitmap));
            } else {
                walker.setRevFilter(new AddUnseenToBitmapFilter(seen, resultBitmap));
            }
            walker.setObjectFilter(new BitmapObjectFilter(resultBitmap));
            ObjectId oid;
            while ((oid = walker.next()) != null) {
                progressMonitor.update(1);
                countOfBitmapIndexMisses++;
                listener.onCommitWithoutBitmap(oid);
            }
            RevObject ro;
            while ((ro = walker.nextObject()) != null) {
                resultBitmap.addObject(ro, ro.getType());
                progressMonitor.update(1);
            }
        }
        return resultBitmap;
    }

    static class BitmapObjectFilter extends ObjectFilter {
        private final BitmapBuilder bitmap;

        BitmapObjectFilter(BitmapBuilder bitmap) {
            this.bitmap = bitmap;
        }

        @Override
        public final boolean include(ObjectWalk walker, AnyObjectId objid) throws MissingObjectException, IncorrectObjectTypeException, IOException {
            return !bitmap.contains(objid);
        }
    }
}