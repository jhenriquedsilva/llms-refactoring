28-04-2025, 21:18

### Review of Code for Rename Method Refactoring Opportunities

Upon close inspection, several methods within `BasePackFetchConnection` are named with short, generic verbs or nouns. In large, long-lived, or collaborative projects like JGit, **clear and expressive method names** are vital for maintainability and comprehensibility.

Some potential improvements are as follows:

| Current Name         | Issues / Justification                                                           | Suggested New Name                         |
|----------------------|----------------------------------------------------------------------------------|--------------------------------------------|
| `doFetch`            | "doFetch" is generic; doesn't convey V0/1 vs V2 protocol (there is doFetchV2).   | `fetchWithProtocolV0V1`                      |
| `sendWants`          | A bit technical; could indicate it's about sending "want" refs/objects.          | `sendWantedRefs`                           |
| `markReachable`      | Slightly vague—what is being marked reachable?                                   | `markLocallyReachableCommits`              |
| `parseReachable`     | Noun/verb ambiguity; it's about adding reachable commits                         | `addReachableCommit`                       |
| `markRefsAdvertised` | 'Refs' might be redundant; "markAdvertisedRefs" clarifies                        | `markAdvertisedRefs`                       |
| `markAdvertised`     | Accepts an ID only; clarify what is advertised                                   | `markObjectAdvertised`                     |
| `markCommon`         | Which commonality? Could be clearer                                              | `markCommitAsCommon`                       |

Some method names are very clear and domain-specific, e.g., `sendShallow`, `receivePack`, `handleShallowUnshallow`, etc., so I will leave these as-is.

Below is the **refactored class** with improved method names, and all usages updated accordingly.

---

```java
// ... (imports and Javadoc unchanged)
public abstract class BasePackFetchConnection extends BasePackConnection
        implements FetchConnection {
    // ... fields unchanged

    // ... constructor unchanged

    // ... FetchConfig inner class unchanged

    @Override
    public final void fetch(final ProgressMonitor monitor,
                            final Collection<Ref> want, final Set<ObjectId> have)
            throws TransportException {
        fetch(monitor, want, have, null);
    }

    @Override
    public final void fetch(final ProgressMonitor monitor,
                            final Collection<Ref> want, final Set<ObjectId> have,
                            OutputStream outputStream) throws TransportException {
        markStartedOperation();
        fetchWithProtocolV0V1(monitor, want, have, outputStream);
    }

    @Override
    public boolean didFetchIncludeTags() {
        return false;
    }

    @Override
    public boolean didFetchTestConnectivity() {
        return false;
    }

    @Override
    public void setPackLockMessage(String message) {
        lockMessage = message;
    }

    @Override
    public Collection<PackLock> getPackLocks() {
        if (packLock != null)
            return Collections.singleton(packLock);
        return Collections.<PackLock> emptyList();
    }

    private void clearState() {
        walk.dispose();
        reachableCommits = null;
        state = null;
        pckState = null;
    }

    /**
     * Execute common ancestor negotiation and fetch the objects.
     *
     * @param monitor ...
     */
    protected void fetchWithProtocolV0V1(final ProgressMonitor monitor,
                                         final Collection<Ref> want, final Set<ObjectId> have,
                                         OutputStream outputStream) throws TransportException {
        try {
            noProgress = monitor == NullProgressMonitor.INSTANCE;

            markAdvertisedRefs();
            markLocallyReachableCommits(want, have, maxTimeWanted(want));

            if (TransferConfig.ProtocolVersion.V2.equals(getProtocolVersion())) {
                state = new TemporaryBuffer.Heap(Integer.MAX_VALUE);
                pckState = new PacketLineOut(state);
                try {
                    doFetchV2(monitor, want, outputStream);
                } finally {
                    clearState();
                }
                return;
            }
            // Protocol V0/1
            if (statelessRPC) {
                state = new TemporaryBuffer.Heap(Integer.MAX_VALUE);
                pckState = new PacketLineOut(state);
            }
            PacketLineOut output = statelessRPC ? pckState : pckOut;
            if (sendWantedRefs(want, output)) {
                boolean mayHaveShallow = depth != null || deepenSince != null || !deepenNots.isEmpty();
                Set<ObjectId> shallowCommits = local.getObjectDatabase().getShallowCommits();
                if (isCapableOf(GitProtocolConstants.CAPABILITY_SHALLOW)) {
                    sendShallow(shallowCommits, output);
                } else if (mayHaveShallow) {
                    throw new PackProtocolException(JGitText.get().shallowNotSupported);
                }
                output.end();
                outNeedsEnd = false;

                negotiate(monitor, mayHaveShallow, shallowCommits);

                clearState();

                receivePack(monitor, outputStream);
            }
        } catch (CancelledException ce) {
            close();
            return; // Caller should test (or just know) this themselves.
        } catch (IOException | RuntimeException err) {
            close();
            throw new TransportException(err.getMessage(), err);
        }
    }

    private void doFetchV2(ProgressMonitor monitor, Collection<Ref> want,
                           OutputStream outputStream) throws IOException, CancelledException {
        sideband = true;
        negotiateBegin();

        pckState.writeString("command=" + GitProtocolConstants.COMMAND_FETCH); //$NON-NLS-1$
        // Capabilities are sent as command arguments in protocol V2
        String agent = UserAgent.get();
        if (agent != null && isCapableOf(GitProtocolConstants.OPTION_AGENT)) {
            pckState.writeString(
                    GitProtocolConstants.OPTION_AGENT + '=' + agent);
        }
        Set<String> capabilities = new HashSet<>();
        String advertised = getCapability(GitProtocolConstants.COMMAND_FETCH);
        if (!StringUtils.isEmptyOrNull(advertised)) {
            capabilities.addAll(Arrays.asList(advertised.split("\\s+"))); //$NON-NLS-1$
        }
        // Arguments
        pckState.writeDelim();
        for (String capability : getCapabilitiesV2(capabilities)) {
            pckState.writeString(capability);
        }

        if (!sendWantedRefs(want, pckState)) {
            // We already have everything we wanted.
            return;
        }

        Set<ObjectId> shallowCommits = local.getObjectDatabase().getShallowCommits();
        if (capabilities.contains(GitProtocolConstants.CAPABILITY_SHALLOW)) {
            sendShallow(shallowCommits, pckState);
        } else if (depth != null || deepenSince != null || !deepenNots.isEmpty()) {
            throw new PackProtocolException(JGitText.get().shallowNotSupported);
        }
        // If we send something, we always close it properly ourselves.
        outNeedsEnd = false;

        FetchStateV2 fetchState = new FetchStateV2();
        boolean sentDone = false;
        for (;;) {
            // The "state" buffer contains the full fetch request with all
            // common objects found so far.
            state.writeTo(out, monitor);
            sentDone = sendNextHaveBatch(fetchState, pckOut, monitor);
            if (sentDone) {
                break;
            }
            if (readAcknowledgments(fetchState, pckIn, monitor)) {
                // We got a "ready": next should be a patch file.
                break;
            }
            // Note: C git reads and requires here (and after a packfile) a
            // "0002" packet in stateless RPC transports (https). This "response
            // end" packet is even mentioned in the protocol V2 technical
            // documentation. However, it is not actually part of the public
            // protocol; it occurs only in an internal protocol wrapper in the C
            // git implementation.
        }
        clearState();
        String line = pckIn.readString();
        // If we sent a done, we may have an error reply here.
        if (sentDone && line.startsWith(PACKET_ERR)) {
            throw new RemoteRepositoryException(uri, line.substring(4));
        }

        if (GitProtocolConstants.SECTION_SHALLOW_INFO.equals(line)) {
            line = handleShallowUnshallow(shallowCommits, pckIn);
            if (!PacketLineIn.isDelimiter(line)) {
                throw new PackProtocolException(MessageFormat
                        .format(JGitText.get().expectedGot, PACKET_DELIM,
                                line));
            }
            line = pckIn.readString();
        }

        // "wanted-refs" and "packfile-uris" would have to be
        // handled here in that order.
        if (!GitProtocolConstants.SECTION_PACKFILE.equals(line)) {
            throw new PackProtocolException(
                    MessageFormat.format(JGitText.get().expectedGot,
                            GitProtocolConstants.SECTION_PACKFILE, line));
        }
        receivePack(monitor, outputStream);
    }

    private boolean sendNextHaveBatch(FetchStateV2 fetchState,
                                      PacketLineOut output, ProgressMonitor monitor)
            throws IOException, CancelledException {
        long n = 0;
        while (n < fetchState.havesToSend) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            output.writeString(PACKET_HAVE + c.getId().name() + '\n');
            n++;
            if (n % 10 == 0 && monitor.isCancelled()) {
                throw new CancelledException();
            }
        }
        fetchState.havesTotal += n;
        if (n == 0
                || (fetchState.hadAcks
                && fetchState.havesWithoutAck > MAX_HAVES)
                || fetchState.havesTotal > maxHaves) {
            output.writeString(PACKET_DONE + '\n');
            output.end();
            return true;
        }
        // Increment only after the test above. Of course we have no ACKs yet
        // for the newly added "have"s, so it makes no sense to count them
        // against the MAX_HAVES limit.
        fetchState.havesWithoutAck += n;
        output.end();
        fetchState.incHavesToSend(statelessRPC);
        return false;
    }

    private boolean readAcknowledgments(FetchStateV2 fetchState,
                                        PacketLineIn input, ProgressMonitor monitor)
            throws IOException, CancelledException {
        String line = input.readString();
        if (!GitProtocolConstants.SECTION_ACKNOWLEDGMENTS.equals(line)) {
            throw new PackProtocolException(MessageFormat.format(
                    JGitText.get().expectedGot,
                    GitProtocolConstants.SECTION_ACKNOWLEDGMENTS, line));
        }
        MutableObjectId returnedId = new MutableObjectId();
        line = input.readString();
        boolean gotReady = false;
        long n = 0;
        while (!PacketLineIn.isEnd(line) && !PacketLineIn.isDelimiter(line)) {
            AckNackResult ack = PacketLineIn.parseACKv2(line, returnedId);
            // If we got a "ready", we just skip the remaining lines after
            // having checked them for being valid. (Normally, the "ready"
            // should be the last line anyway.)
            if (!gotReady) {
                if (ack == AckNackResult.ACK_COMMON) {
                    // markCommon appends the object to the "state"
                    markCommitAsCommon(walk.parseAny(returnedId), ack, true);
                    fetchState.havesWithoutAck = 0;
                    fetchState.hadAcks = true;
                } else if (ack == AckNackResult.ACK_READY) {
                    gotReady = true;
                }
            }
            n++;
            if (n % 10 == 0 && monitor.isCancelled()) {
                throw new CancelledException();
            }
            line = input.readString();
        }
        if (gotReady) {
            if (!PacketLineIn.isDelimiter(line)) {
                throw new PackProtocolException(MessageFormat
                        .format(JGitText.get().expectedGot, PACKET_DELIM,
                                line));
            }
        } else if (!PacketLineIn.isEnd(line)) {
            throw new PackProtocolException(MessageFormat
                    .format(JGitText.get().expectedGot, PACKET_END, line));
        }
        return gotReady;
    }

    @Override
    public void close() {
        if (walk != null)
            walk.close();
        super.close();
    }

    FetchConfig getFetchConfig() {
        return local.getConfig().get(FetchConfig::new);
    }

    private int maxTimeWanted(Collection<Ref> wants) {
        int maxTime = 0;
        for (Ref r : wants) {
            try {
                final RevObject obj = walk.parseAny(r.getObjectId());
                if (obj instanceof RevCommit) {
                    final int cTime = ((RevCommit) obj).getCommitTime();
                    if (maxTime < cTime)
                        maxTime = cTime;
                }
            } catch (IOException error) {
                // We don't have it, but we want to fetch (thus fixing error).
            }
        }
        return maxTime;
    }

    private void markLocallyReachableCommits(Collection<Ref> want, Set<ObjectId> have,
                               int maxTime) throws IOException {
        Collection<Ref> refsToMark;
        if (useNegotiationTip) {
            refsToMark = translateToLocalTips(want);
            if (refsToMark.size() < want.size()) {
                refsToMark.addAll(local.getRefDatabase().getRefs());
            }
        } else {
            refsToMark = local.getRefDatabase().getRefs();
        }
        markReachableRefTips(refsToMark);

        for (ObjectId id : local.getAdditionalHaves())
            addReachableCommit(id);

        for (ObjectId id : have)
            addReachableCommit(id);

        if (maxTime > 0) {
            final Date maxWhen = new Date(maxTime * 1000L);
            walk.sort(RevSort.COMMIT_TIME_DESC);
            walk.markStart(reachableCommits);
            walk.setRevFilter(CommitTimeRevFilter.after(maxWhen));
            for (;;) {
                final RevCommit c = walk.next();
                if (c == null)
                    break;
                if (c.has(ADVERTISED) && !c.has(COMMON)) {
                    c.add(COMMON);
                    c.carry(COMMON);
                    reachableCommits.add(c);
                }
            }
        }
    }

    private Collection<Ref> translateToLocalTips(Collection<Ref> want)
            throws IOException {
        String[] refs = want.stream().map(Ref::getName)
                .collect(Collectors.toSet()).toArray(new String[0]);
        Map<String, Ref> wantRefMap = local.getRefDatabase().exactRef(refs);
        return wantRefMap.values().stream()
                .filter(r -> getRefObjectId(r) != null)
                .collect(Collectors.toList());
    }

    /**
     * Marks commits reachable.
     *
     * @param refsToMark references that client is requesting to be marked.
     */
    private void markReachableRefTips(Collection<Ref> refsToMark) {
        refsToMark.stream().map(BasePackFetchConnection::getRefObjectId)
                .filter(Objects::nonNull)
                .forEach(oid -> addReachableCommit(oid));
    }

    private static ObjectId getRefObjectId(Ref ref) {
        ObjectId id = ref.getPeeledObjectId();
        if (id == null) {
            id = ref.getObjectId();
        }
        return id;
    }

    private void addReachableCommit(ObjectId id) {
        try {
            RevCommit o = walk.parseCommit(id);
            if (!o.has(REACHABLE)) {
                o.add(REACHABLE);
                reachableCommits.add(o);
            }
        } catch (IOException readError) {
            // If we cannot read the value of the ref skip it.
        }
    }

    private boolean sendWantedRefs(Collection<Ref> want, PacketLineOut p)
            throws IOException {
        boolean first = true;
        for (Ref r : want) {
            ObjectId objectId = r.getObjectId();
            if (objectId == null) {
                continue;
            }
            // if depth is set we need to fetch the objects even if they are already available
            if (transport.getDepth() == null) {
                try {
                    if (walk.parseAny(objectId).has(REACHABLE)) {
                        // We already have this object.
                        continue;
                    }
                } catch (IOException err) {
                    // Its OK, we don't have it, but we want to fix that
                    // by fetching the object from the other side.
                }
            }

            final StringBuilder line = new StringBuilder(46);
            line.append(PACKET_WANT).append(objectId.name());
            if (first && TransferConfig.ProtocolVersion.V0
                    .equals(getProtocolVersion())) {
                line.append(enableCapabilities());
            }
            first = false;
            line.append('\n');
            p.writeString(line.toString());
        }
        if (first) {
            return false;
        }
        if (!filterSpec.isNoOp()) {
            p.writeString(filterSpec.filterLine());
        }
        return true;
    }

    private Set<String> getCapabilitiesV2(Set<String> advertisedCapabilities)
            throws TransportException {
        Set<String> capabilities = new LinkedHashSet<>();
        if (noProgress) {
            capabilities.add(OPTION_NO_PROGRESS);
        }
        if (includeTags) {
            capabilities.add(OPTION_INCLUDE_TAG);
        }
        if (allowOfsDelta) {
            capabilities.add(OPTION_OFS_DELTA);
        }
        if (thinPack) {
            capabilities.add(OPTION_THIN_PACK);
        }
        if (!filterSpec.isNoOp()
                && !advertisedCapabilities.contains(OPTION_FILTER)) {
            throw new PackProtocolException(uri,
                    JGitText.get().filterRequiresCapability);
        }
        return capabilities;
    }

    private String enableCapabilities() throws TransportException {
        final StringBuilder line = new StringBuilder();
        if (noProgress)
            wantCapability(line, OPTION_NO_PROGRESS);
        if (includeTags)
            includeTags = wantCapability(line, OPTION_INCLUDE_TAG);
        if (allowOfsDelta)
            wantCapability(line, OPTION_OFS_DELTA);

        if (wantCapability(line, OPTION_MULTI_ACK_DETAILED)) {
            multiAck = MultiAck.DETAILED;
            if (statelessRPC)
                noDone = wantCapability(line, OPTION_NO_DONE);
        } else if (wantCapability(line, OPTION_MULTI_ACK))
            multiAck = MultiAck.CONTINUE;
        else
            multiAck = MultiAck.OFF;

        if (thinPack)
            thinPack = wantCapability(line, OPTION_THIN_PACK);
        if (wantCapability(line, OPTION_SIDE_BAND_64K))
            sideband = true;
        else if (wantCapability(line, OPTION_SIDE_BAND))
            sideband = true;

        if (statelessRPC && multiAck != MultiAck.DETAILED) {
            throw new PackProtocolException(uri, MessageFormat.format(
                    JGitText.get().statelessRPCRequiresOptionToBeEnabled,
                    OPTION_MULTI_ACK_DETAILED));
        }

        if (!filterSpec.isNoOp() && !wantCapability(line, OPTION_FILTER)) {
            throw new PackProtocolException(uri,
                    JGitText.get().filterRequiresCapability);
        }

        addUserAgentCapability(line);
        return line.toString();
    }

    private void negotiate(ProgressMonitor monitor, boolean mayHaveShallow, Set<ObjectId> shallowCommits)
            throws IOException, CancelledException {
        final MutableObjectId ackId = new MutableObjectId();
        int resultsPending = 0;
        int havesSent = 0;
        int havesSinceLastContinue = 0;
        boolean receivedContinue = false;
        boolean receivedAck = false;
        boolean receivedReady = false;

        if (statelessRPC) {
            state.writeTo(out, null);
        }

        negotiateBegin();
        SEND_HAVES: for (;;) {
            final RevCommit c = walk.next();
            if (c == null) {
                break SEND_HAVES;
            }

            ObjectId o = c.getId();
            pckOut.writeString(PACKET_HAVE + o.name() + '\n');
            havesSent++;
            havesSinceLastContinue++;

            if ((31 & havesSent) != 0) {
                continue;
            }

            if (monitor.isCancelled()) {
                throw new CancelledException();
            }

            pckOut.end();
            resultsPending++;

            if (havesSent == 32 && !statelessRPC) {
                continue;
            }

            READ_RESULT: for (;;) {
                final AckNackResult anr = pckIn.readACK(ackId);
                switch (anr) {
                    case NAK:
                        resultsPending--;
                        break READ_RESULT;

                    case ACK:
                        multiAck = MultiAck.OFF;
                        resultsPending = 0;
                        receivedAck = true;
                        if (statelessRPC) {
                            state.writeTo(out, null);
                        }
                        break SEND_HAVES;

                    case ACK_CONTINUE:
                    case ACK_COMMON:
                    case ACK_READY:
                        markCommitAsCommon(walk.parseAny(ackId), anr, statelessRPC);
                        receivedAck = true;
                        receivedContinue = true;
                        havesSinceLastContinue = 0;
                        if (anr == AckNackResult.ACK_READY) {
                            receivedReady = true;
                        }
                        break;
                }

                if (monitor.isCancelled()) {
                    throw new CancelledException();
                }
            }

            if (noDone && receivedReady) {
                break SEND_HAVES;
            }
            if (statelessRPC) {
                state.writeTo(out, null);
            }

            if ((receivedContinue && havesSinceLastContinue > MAX_HAVES)
                    || havesSent >= maxHaves) {
                break SEND_HAVES;
            }
        }

        if (monitor.isCancelled()) {
            throw new CancelledException();
        }

        if (!receivedReady || !noDone) {
            pckOut.writeString(PACKET_DONE + '\n');
            pckOut.flush();
        }

        if (!receivedAck) {
            multiAck = MultiAck.OFF;
            resultsPending++;
        }

        if (mayHaveShallow) {
            String line = handleShallowUnshallow(shallowCommits, pckIn);
            if (!PacketLineIn.isEnd(line)) {
                throw new PackProtocolException(MessageFormat
                        .format(JGitText.get().expectedGot, PACKET_END, line));
            }
        }

        READ_RESULT: while (resultsPending > 0 || multiAck != MultiAck.OFF) {
            final AckNackResult anr = pckIn.readACK(ackId);
            resultsPending--;
            switch (anr) {
                case NAK:
                    break;

                case ACK:
                    break READ_RESULT;

                case ACK_CONTINUE:
                case ACK_COMMON:
                case ACK_READY:
                    multiAck = MultiAck.CONTINUE;
                    break;
            }

            if (monitor.isCancelled()) {
                throw new CancelledException();
            }
        }
    }

    private void negotiateBegin() throws IOException {
        walk.resetRetain(REACHABLE, ADVERTISED);
        walk.markStart(reachableCommits);
        walk.sort(RevSort.COMMIT_TIME_DESC);
        walk.setRevFilter(new RevFilter() {
            @Override
            public RevFilter clone() {
                return this;
            }

            @Override
            public boolean include(RevWalk walker, RevCommit c) {
                final boolean remoteKnowsIsCommon = c.has(COMMON);
                if (c.has(ADVERTISED)) {
                    c.add(COMMON);
                }
                return !remoteKnowsIsCommon;
            }

            @Override
            public boolean requiresCommitBody() {
                return false;
            }
        });
    }

    private void markAdvertisedRefs() {
        for (Ref r : getRefs()) {
            markObjectAdvertised(r.getObjectId());
            if (r.getPeeledObjectId() != null)
                markObjectAdvertised(r.getPeeledObjectId());
        }
    }

    private void markObjectAdvertised(AnyObjectId id) {
        try {
            walk.parseAny(id).add(ADVERTISED);
        } catch (IOException readError) {
            // We probably just do not have this object locally.
        }
    }

    private void markCommitAsCommon(RevObject obj, AckNackResult anr, boolean useState)
            throws IOException {
        if (useState && anr == AckNackResult.ACK_COMMON && !obj.has(STATE)) {
            pckState.writeString(PACKET_HAVE + obj.name() + '\n');
            obj.add(STATE);
        }
        obj.add(COMMON);
        if (obj instanceof RevCommit)
            ((RevCommit) obj).carry(COMMON);
    }

    private void receivePack(final ProgressMonitor monitor,
                             OutputStream outputStream) throws IOException {
        onReceivePack();
        InputStream input = in;
        SideBandInputStream sidebandIn = null;
        if (sideband) {
            sidebandIn = new SideBandInputStream(input, monitor,
                    getMessageWriter(), outputStream);
            input = sidebandIn;
        }

        try (ObjectInserter ins = local.newObjectInserter()) {
            PackParser parser = ins.newPackParser(input);
            parser.setAllowThin(thinPack);
            parser.setObjectChecker(transport.getObjectChecker());
            parser.setLockMessage(lockMessage);
            packLock = parser.parse(monitor);
            ins.flush();
        } finally {
            if (sidebandIn != null) {
                sidebandIn.drainMessages();
            }
        }
    }

    private void sendShallow(Set<ObjectId> shallowCommits, PacketLineOut output)
            throws IOException {
        for (ObjectId shallowCommit : shallowCommits) {
            output.writeString(PACKET_SHALLOW + shallowCommit.name());
        }

        if (depth != null) {
            output.writeString(PACKET_DEEPEN + depth);
        }

        if (deepenSince != null) {
            output.writeString(
                    PACKET_DEEPEN_SINCE + deepenSince.getEpochSecond());
        }

        if (deepenNots != null) {
            for (String deepenNotRef : deepenNots) {
                output.writeString(PACKET_DEEPEN_NOT + deepenNotRef);
            }
        }
    }

    private String handleShallowUnshallow(
            Set<ObjectId> advertisedShallowCommits, PacketLineIn input)
            throws IOException {
        String line = input.readString();
        ObjectDatabase objectDatabase = local.getObjectDatabase();
        HashSet<ObjectId> newShallowCommits = new HashSet<>(
                advertisedShallowCommits);
        while (!PacketLineIn.isDelimiter(line) && !PacketLineIn.isEnd(line)) {
            if (line.startsWith(PACKET_SHALLOW)) {
                newShallowCommits.add(ObjectId
                        .fromString(line.substring(PACKET_SHALLOW.length())));
            } else if (line.startsWith(PACKET_UNSHALLOW)) {
                ObjectId unshallow = ObjectId
                        .fromString(line.substring(PACKET_UNSHALLOW.length()));
                if (!advertisedShallowCommits.contains(unshallow)) {
                    throw new PackProtocolException(MessageFormat.format(
                            JGitText.get().notShallowedUnshallow,
                            unshallow.name()));
                }
                newShallowCommits.remove(unshallow);
            }
            line = input.readString();
        }
        objectDatabase.setShallowCommits(newShallowCommits);
        return line;
    }

    /**
     * Notification event delivered just before the pack is received from the
     * network. This event can be used by RPC such as {@link org.eclipse.jgit.transport.TransportHttp} to
     * disable its request magic and ensure the pack stream is read correctly.
     *
     * @since 2.0
     */
    protected void onReceivePack() {
        // By default do nothing for TCP based protocols.
    }

    private static class CancelledException extends Exception {
        private static final long serialVersionUID = 1L;
    }

    private static class FetchStateV2 {

        long havesToSend = 32;

        long havesTotal;

        // Set to true if we got at least one ACK in protocol V2.
        boolean hadAcks;

        // Counts haves without ACK. Use as cutoff for negotiation only once
        // hadAcks == true.
        long havesWithoutAck;

        void incHavesToSend(boolean statelessRPC) {
            if (statelessRPC) {
                if (havesToSend < 16384) {
                    havesToSend *= 2;
                } else {
                    havesToSend = havesToSend * 11 / 10;
                }
            } else {
                havesToSend += 32;
            }
        }
    }
}
```

---

**Summary of changes:**

- `doFetch` → `fetchWithProtocolV0V1`
- `sendWants` → `sendWantedRefs`
- `markReachable` → `markLocallyReachableCommits`
- `parseReachable` → `addReachableCommit`
- `markRefsAdvertised` → `markAdvertisedRefs`
- `markAdvertised` → `markObjectAdvertised`
- `markCommon` → `markCommitAsCommon`

All usages within this class were refactored too.

---

**These name improvements enhance readability and self-documentation of your codebase!**
