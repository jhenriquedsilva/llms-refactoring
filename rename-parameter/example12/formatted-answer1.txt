package org.eclipse.jgit.gpg.bc.internal;

import static java.nio.file.Files.exists;
import static java.nio.file.Files.newInputStream;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.net.URISyntaxException;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.InvalidPathException;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.text.MessageFormat;
import java.util.Iterator;
import java.util.Locale;
import java.util.function.Consumer;
import java.util.function.Function;

import org.bouncycastle.gpg.keybox.BlobType;
import org.bouncycastle.gpg.keybox.KeyBlob;
import org.bouncycastle.gpg.keybox.KeyBox;
import org.bouncycastle.gpg.keybox.KeyInformation;
import org.bouncycastle.gpg.keybox.PublicKeyRingBlob;
import org.bouncycastle.gpg.keybox.UserID;
import org.bouncycastle.gpg.keybox.jcajce.JcaKeyBoxBuilder;
import org.bouncycastle.openpgp.PGPException;
import org.bouncycastle.openpgp.PGPKeyFlags;
import org.bouncycastle.openpgp.PGPPublicKey;
import org.bouncycastle.openpgp.PGPPublicKeyRing;
import org.bouncycastle.openpgp.PGPPublicKeyRingCollection;
import org.bouncycastle.openpgp.PGPSecretKey;
import org.bouncycastle.openpgp.PGPSecretKeyRing;
import org.bouncycastle.openpgp.PGPSecretKeyRingCollection;
import org.bouncycastle.openpgp.PGPSignature;
import org.bouncycastle.openpgp.PGPUtil;
import org.bouncycastle.openpgp.operator.PGPDigestCalculatorProvider;
import org.bouncycastle.openpgp.operator.jcajce.JcaKeyFingerprintCalculator;
import org.bouncycastle.openpgp.operator.jcajce.JcaPGPDigestCalculatorProviderBuilder;
import org.bouncycastle.util.encoders.Hex;
import org.eclipse.jgit.annotations.NonNull;
import org.eclipse.jgit.api.errors.CanceledException;
import org.eclipse.jgit.errors.UnsupportedCredentialItem;
import org.eclipse.jgit.gpg.bc.internal.keys.KeyGrip;
import org.eclipse.jgit.gpg.bc.internal.keys.SecretKeys;
import org.eclipse.jgit.util.FS;
import org.eclipse.jgit.util.StringUtils;
import org.eclipse.jgit.util.SystemReader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class BouncyCastleGpgKeyLocator {

    private static class NoOpenPgpKeyException extends Exception {

        private static final long serialVersionUID = 1L;

    }

    private static final Logger log = LoggerFactory.getLogger(BouncyCastleGpgKeyLocator.class);

    static final Path GPG_DIRECTORY = findGpgDirectory();

    private static final Path USER_KEYBOX_PATH = GPG_DIRECTORY.resolve("pubring.kbx");

    private static final Path USER_SECRET_KEY_DIR = GPG_DIRECTORY.resolve("private-keys-v1.d");

    private static final Path USER_PGP_PUBRING_FILE = GPG_DIRECTORY.resolve("pubring.gpg");

    private static final Path USER_PGP_LEGACY_SECRING_FILE = GPG_DIRECTORY.resolve("secring.gpg");

    private final String signingKey;

    private BouncyCastleGpgKeyPassphrasePrompt passphrasePrompt;

    private static Path findGpgDirectory() {
        SystemReader system = SystemReader.getInstance();
        Function<String, Path> resolveTilde = pathString -> {
            if (pathString.startsWith("~/") || pathString.startsWith("~" + File.separatorChar)) {
                return new File(FS.DETECTED.userHome(), pathString.substring(2)).getAbsoluteFile().toPath();
            }
            return Paths.get(pathString);
        };
        Path path = checkDirectory(system.getProperty("jgit.gpg.home"), resolveTilde, dir -> log.warn(BCText.get().logWarnGpgHomeProperty, dir));
        if (path != null) {
            return path;
        }
        path = checkDirectory(system.getenv("GNUPGHOME"), resolveTilde, envVar -> log.warn(BCText.get().logWarnGnuPGHome, envVar));
        if (path != null) {
            return path;
        }
        if (system.isWindows()) {
            path = checkDirectory(system.getenv("APPDATA"), appDataPathString -> Paths.get(appDataPathString).resolve("gnupg"), null);
            if (path != null) {
                return path;
            }
        }
        return resolveTilde.apply("~/.gnupg");
    }

    private static Path checkDirectory(String directoryString, Function<String, Path> toPath, Consumer<String> warn) {
        if (!StringUtils.isEmptyOrNull(directoryString)) {
            try {
                Path directory = toPath.apply(directoryString);
                if (Files.isDirectory(directory)) {
                    return directory;
                }
            } catch (SecurityException | InvalidPathException e) {
            }
            if (warn != null) {
                warn.accept(directoryString);
            }
        }
        return null;
    }

    public BouncyCastleGpgKeyLocator(String signingKey, @NonNull BouncyCastleGpgKeyPassphrasePrompt passphrasePrompt) {
        this.signingKey = signingKey;
        this.passphrasePrompt = passphrasePrompt;
    }

    private PGPSecretKey attemptParseSecretKey(Path keyFile, PGPDigestCalculatorProvider calculatorProvider, SecretKeys.PassphraseSupplier passphraseSupplier, PGPPublicKey publicKey) throws IOException, PGPException, CanceledException, UnsupportedCredentialItem, URISyntaxException {
        try (InputStream in = newInputStream(keyFile)) {
            return SecretKeys.readSecretKey(in, calculatorProvider, passphraseSupplier, publicKey);
        }
    }

    static boolean containsSigningKey(String userId, String signingKeySpec) {
        if (StringUtils.isEmptyOrNull(userId) || StringUtils.isEmptyOrNull(signingKeySpec)) {
            return false;
        }
        String toMatch = signingKeySpec;
        if (toMatch.startsWith("0x") && toMatch.trim().length() > 2) {
            return false;
        }
        int command = toMatch.charAt(0);
        switch (command) {
            case '=':
            case '<':
            case '@':
            case '*':
                toMatch = toMatch.substring(1);
                if (toMatch.isEmpty()) {
                    return false;
                }
                break;
            default:
                break;
        }
        switch (command) {
            case '=':
                return userId.equals(toMatch);
            case '<': {
                int begin = userId.indexOf('<');
                int end = userId.indexOf('>', begin + 1);
                int stop = toMatch.indexOf('>');
                return begin >= 0 && end > begin + 1 && stop > 0 && userId.substring(begin + 1, end).equalsIgnoreCase(toMatch.substring(0, stop));
            }
            case '@': {
                int begin = userId.indexOf('<');
                int end = userId.indexOf('>', begin + 1);
                return begin >= 0 && end > begin + 1 && containsIgnoreCase(userId.substring(begin + 1, end), toMatch);
            }
            default:
                if (toMatch.trim().isEmpty()) {
                    return false;
                }
                return containsIgnoreCase(userId, toMatch);
        }
    }

    private static boolean containsIgnoreCase(String string, String substring) {
        int stringLength = string.length();
        int substringLength = substring.length();
        for (int i = 0; i + substringLength <= stringLength; i++) {
            if (string.regionMatches(true, i, substring, 0, substringLength)) {
                return true;
            }
        }
        return false;
    }

    private static String toFingerprint(String keyId) {
        if (keyId.startsWith("0x")) {
            return keyId.substring(2);
        }
        return keyId;
    }

    static PGPPublicKey findPublicKey(String fingerprint, String keySpec) throws IOException, PGPException {
        PGPPublicKey result = findPublicKeyInPubring(USER_PGP_PUBRING_FILE, fingerprint, keySpec);
        if (result == null && exists(USER_KEYBOX_PATH)) {
            try {
                result = findPublicKeyInKeyBox(USER_KEYBOX_PATH, fingerprint, keySpec);
            } catch (NoSuchAlgorithmException | NoSuchProviderException | IOException | NoOpenPgpKeyException e) {
                log.error(e.getMessage(), e);
            }
        }
        return result;
    }

    private static PGPPublicKey findPublicKeyByKeyId(KeyBlob keyBlob, String keyId) throws IOException {
        if (keyId.isEmpty()) {
            return null;
        }
        for (KeyInformation keyInfo : keyBlob.getKeyInformation()) {
            String fingerprint = Hex.toHexString(keyInfo.getFingerprint()).toLowerCase(Locale.ROOT);
            if (fingerprint.endsWith(keyId)) {
                return getPublicKey(keyBlob, keyInfo.getFingerprint());
            }
        }
        return null;
    }

    private static PGPPublicKey findPublicKeyByUserId(KeyBlob keyBlob, String keySpec) throws IOException {
        for (UserID userID : keyBlob.getUserIds()) {
            if (containsSigningKey(userID.getUserIDAsString(), keySpec)) {
                return getSigningPublicKey(keyBlob);
            }
        }
        return null;
    }

    private static PGPPublicKey findPublicKeyInKeyBox(Path keyboxFile, String keyId, String keySpec) throws IOException, NoSuchAlgorithmException, NoSuchProviderException, NoOpenPgpKeyException {
        KeyBox keyBox = readKeyBoxFile(keyboxFile);
        String id = keyId != null ? keyId : toFingerprint(keySpec).toLowerCase(Locale.ROOT);
        boolean hasOpenPgpKey = false;
        for (KeyBlob keyBlob : keyBox.getKeyBlobs()) {
            if (keyBlob.getType() == BlobType.OPEN_PGP_BLOB) {
                hasOpenPgpKey = true;
                PGPPublicKey key = findPublicKeyByKeyId(keyBlob, id);
                if (key != null) {
                    return key;
                }
                key = findPublicKeyByUserId(keyBlob, keySpec);
                if (key != null) {
                    return key;
                }
            }
        }
        if (!hasOpenPgpKey) {
            throw new NoOpenPgpKeyException();
        }
        return null;
    }

    @NonNull
    public BouncyCastleGpgKey findSecretKey() throws IOException, NoSuchAlgorithmException, NoSuchProviderException, PGPException, CanceledException, UnsupportedCredentialItem, URISyntaxException {
        BouncyCastleGpgKey key;
        PGPPublicKey publicKey = null;
        if (hasKeyFiles(USER_SECRET_KEY_DIR)) {
            if (exists(USER_KEYBOX_PATH)) {
                try {
                    publicKey = findPublicKeyInKeyBox(USER_KEYBOX_PATH, null, signingKey);
                    if (publicKey != null) {
                        key = findSecretKeyForKeyBoxPublicKey(publicKey, USER_KEYBOX_PATH);
                        if (key != null) {
                            return key;
                        }
                        throw new PGPException(MessageFormat.format(BCText.get().gpgNoSecretKeyForPublicKey, Long.toHexString(publicKey.getKeyID())));
                    }
                    throw new PGPException(MessageFormat.format(BCText.get().gpgNoPublicKeyFound, signingKey));
                } catch (NoOpenPgpKeyException e) {
                    if (log.isDebugEnabled()) {
                        log.debug("{} does not contain any OpenPGP keys", USER_KEYBOX_PATH);
                    }
                }
            }
            if (exists(USER_PGP_PUBRING_FILE)) {
                publicKey = findPublicKeyInPubring(USER_PGP_PUBRING_FILE, null, signingKey);
                if (publicKey != null) {
                    key = findSecretKeyForKeyBoxPublicKey(publicKey, USER_PGP_PUBRING_FILE);
                    if (key != null) {
                        return key;
                    }
                }
            }
            if (publicKey == null) {
                throw new PGPException(MessageFormat.format(BCText.get().gpgNoPublicKeyFound, signingKey));
            }
        }
        boolean hasSecring = false;
        if (exists(USER_PGP_LEGACY_SECRING_FILE)) {
            hasSecring = true;
            key = loadKeyFromSecring(USER_PGP_LEGACY_SECRING_FILE);
            if (key != null) {
                return key;
            }
        }
        if (publicKey != null) {
            throw new PGPException(MessageFormat.format(BCText.get().gpgNoSecretKeyForPublicKey, Long.toHexString(publicKey.getKeyID())));
        } else if (hasSecring) {
            throw new PGPException(MessageFormat.format(BCText.get().gpgNoKeyInLegacySecring, signingKey));
        } else {
            throw new PGPException(BCText.get().gpgNoKeyring);
        }
    }

    private boolean hasKeyFiles(Path directory) {
        try (DirectoryStream<Path> contents = Files.newDirectoryStream(directory, "*.key")) {
            return contents.iterator().hasNext();
        } catch (IOException e) {
            return false;
        }
    }

    private BouncyCastleGpgKey loadKeyFromSecring(Path secringFile) throws IOException, PGPException {
        PGPSecretKey secretKey = findSecretKeyInLegacySecring(signingKey, secringFile);
        if (secretKey != null) {
            if (!secretKey.isSigningKey()) {
                throw new PGPException(MessageFormat.format(BCText.get().gpgNotASigningKey, signingKey));
            }
            return new BouncyCastleGpgKey(secretKey, secringFile);
        }
        return null;
    }

    private BouncyCastleGpgKey findSecretKeyForKeyBoxPublicKey(PGPPublicKey publicKey, Path keyboxPath) throws PGPException, CanceledException, UnsupportedCredentialItem, URISyntaxException {
        byte[] keyGrip = null;
        try {
            keyGrip = KeyGrip.getKeyGrip(publicKey);
        } catch (PGPException e) {
            throw new PGPException(MessageFormat.format(BCText.get().gpgNoKeygrip, Hex.toHexString(publicKey.getFingerprint())), e);
        }
        String filename = Hex.toHexString(keyGrip).toUpperCase(Locale.ROOT) + ".key";
        Path keyFile = USER_SECRET_KEY_DIR.resolve(filename);
        if (!Files.exists(keyFile)) {
            return null;
        }
        boolean clearPrompt = false;
        try {
            PGPDigestCalculatorProvider calculatorProvider = new JcaPGPDigestCalculatorProviderBuilder().build();
            clearPrompt = true;
            PGPSecretKey secretKey = null;
            try {
                secretKey = attemptParseSecretKey(keyFile, calculatorProvider, () -> passphrasePrompt.getPassphrase(publicKey.getFingerprint(), keyboxPath), publicKey);
            } catch (PGPException e) {
                throw new PGPException(MessageFormat.format(BCText.get().gpgFailedToParseSecretKey, keyFile.toAbsolutePath()), e);
            }
            if (secretKey != null) {
                if (!secretKey.isSigningKey()) {
                    throw new PGPException(MessageFormat.format(BCText.get().gpgNotASigningKey, signingKey));
                }
                clearPrompt = false;
                return new BouncyCastleGpgKey(secretKey, keyboxPath);
            }
            return null;
        } catch (RuntimeException e) {
            throw e;
        } catch (FileNotFoundException | NoSuchFileException e) {
            clearPrompt = false;
            return null;
        } catch (IOException e) {
            throw new PGPException(MessageFormat.format(BCText.get().gpgFailedToParseSecretKey, keyFile.toAbsolutePath()), e);
        } finally {
            if (clearPrompt) {
                passphrasePrompt.clear();
            }
        }
    }

    private PGPSecretKey findSecretKeyInLegacySecring(String signingKey, Path secringFile) throws IOException, PGPException {
        try (InputStream in = newInputStream(secringFile)) {
            PGPSecretKeyRingCollection pgpSec = new PGPSecretKeyRingCollection(PGPUtil.getDecoderStream(new BufferedInputStream(in)), new JcaKeyFingerprintCalculator());
            String keyId = toFingerprint(signingKey).toLowerCase(Locale.ROOT);
            Iterator<PGPSecretKeyRing> keyrings = pgpSec.getKeyRings();
            while (keyrings.hasNext()) {
                PGPSecretKeyRing keyRing = keyrings.next();
                Iterator<PGPSecretKey> keys = keyRing.getSecretKeys();
                while (keys.hasNext()) {
                    PGPSecretKey key = keys.next();
                    String fingerprint = Hex.toHexString(key.getPublicKey().getFingerprint()).toLowerCase(Locale.ROOT);
                    if (fingerprint.endsWith(keyId)) {
                        return key;
                    }
                    Iterator<String> userIDs = key.getUserIDs();
                    while (userIDs.hasNext()) {
                        String userId = userIDs.next();
                        if (containsSigningKey(userId, signingKey)) {
                            return key;
                        }
                    }
                }
            }
        }
        return null;
    }

    private static PGPPublicKey findPublicKeyInPubring(Path publicKeyRingFile, String keyId, String keySpec) throws IOException, PGPException {
        try (InputStream in = newInputStream(publicKeyRingFile)) {
            PGPPublicKeyRingCollection pgpPub = new PGPPublicKeyRingCollection(new BufferedInputStream(in), new JcaKeyFingerprintCalculator());
            String id = keyId != null ? keyId : toFingerprint(keySpec).toLowerCase(Locale.ROOT);
            Iterator<PGPPublicKeyRing> keyrings = pgpPub.getKeyRings();
            while (keyrings.hasNext()) {
                PGPPublicKeyRing keyRing = keyrings.next();
                Iterator<PGPPublicKey> keys = keyRing.getPublicKeys();
                while (keys.hasNext()) {
                    PGPPublicKey key = keys.next();
                    String fingerprint = Hex.toHexString(key.getFingerprint()).toLowerCase(Locale.ROOT);
                    if (fingerprint.endsWith(id)) {
                        return key;
                    }
                    Iterator<String> userIDs = key.getUserIDs();
                    while (userIDs.hasNext()) {
                        String userId = userIDs.next();
                        if (containsSigningKey(userId, keySpec)) {
                            return key;
                        }
                    }
                }
            }
        } catch (FileNotFoundException | NoSuchFileException e) {
        }
        return null;
    }

    private static PGPPublicKey getPublicKey(KeyBlob blob, byte[] fingerprint) throws IOException {
        return ((PublicKeyRingBlob) blob).getPGPPublicKeyRing().getPublicKey(fingerprint);
    }

    private static PGPPublicKey getSigningPublicKey(KeyBlob blob) throws IOException {
        PGPPublicKey masterKey = null;
        Iterator<PGPPublicKey> keys = ((PublicKeyRingBlob) blob).getPGPPublicKeyRing().getPublicKeys();
        while (keys.hasNext()) {
            PGPPublicKey key = keys.next();
            if (isSigningKey(key)) {
                if (key.isMasterKey()) {
                    masterKey = key;
                } else {
                    return key;
                }
            }
        }
        return masterKey;
    }

    private static boolean isSigningKey(PGPPublicKey key) {
        Iterator<?> signatures = key.getSignatures();
        while (signatures.hasNext()) {
            PGPSignature sig = (PGPSignature) signatures.next();
            if ((sig.getHashedSubPackets().getKeyFlags() & PGPKeyFlags.CAN_SIGN) > 0) {
                return true;
            }
        }
        return false;
    }

    private static KeyBox readKeyBoxFile(Path keyboxFile) throws IOException, NoSuchAlgorithmException, NoSuchProviderException, NoOpenPgpKeyException {
        if (keyboxFile.toFile().length() == 0) {
            throw new NoOpenPgpKeyException();
        }
        KeyBox keyBox;
        try (InputStream in = new BufferedInputStream(newInputStream(keyboxFile))) {
            keyBox = new JcaKeyBoxBuilder().build(in);
        }
        return keyBox;
    }
}