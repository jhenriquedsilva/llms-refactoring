28-04-2025, 20:58

### Refactoring Opportunities

After reviewing your code, I found a few method names that could be improved for greater clarity and consistency with Java naming conventions. Here are some suggested "Rename Method" refactorings:

**Candidates for Renaming:**
1. `storeInitialTextForOneNode` → `storeNodeInitialText`
2. `findNodeForToken` → `findOwnerNodeForToken`
3. `prettyPrintingTextNode` → `prettyPrintNodeText`
4. `tokensPreceeding` → `tokensPreceding` (fixing the spelling)
5. `fixIndentOfMovedNode` → `fixIndentationOfMovedNode`
6. `makeCommentToken` → `createCommentToken`
7. `isSameComment` → `isCommentContentEqual`
8. `selectMatchingChildElements` → `findMatchingChildElementsByComment`
9. `findTokenTextElementForComment` → `findTokenTextElementsForComment`
10. `findChildTextElementForComment` → `findChildTextElementsForComment`

**Rationale:**
These names were ambiguous, misspelled ("Preceeding"), or not sufficiently descriptive.

Below is the refactored class with these methods renamed. Only the method names and their invocations are changed; the logic is not altered.

---

```java
package com.github.javaparser.printer.lexicalpreservation;

// [Imports remain unchanged]

/**
 * A Lexical Preserving Printer is used to capture all the lexical information while parsing, update them when
 * operating on the AST and then used them to reproduce the source code
 * in its original formatting including the AST changes.
 */
public class LexicalPreservingPrinter {

    private static String JAVA_UTIL_OPTIONAL = Optional.class.getCanonicalName();

    private static String JAVAPARSER_AST_NODELIST = NodeList.class.getCanonicalName();

    private static AstObserver observer;

    // [Constants remain unchanged]

    private static final LexicalDifferenceCalculator LEXICAL_DIFFERENCE_CALCULATOR = new LexicalDifferenceCalculator();

    // ... [class comment and static DataKey remain unchanged]

    /**
     * Prepares the node so it can be used in the print methods.
     */
    public static <N extends Node> N setup(N node) {
        assertNotNull(node);
        if (observer == null) {
            observer = createObserver();
        }
        node.getTokenRange().ifPresent(r -> {
            storeInitialText(node);
            // Setup observer
            if (!node.isRegistered(observer)) {
                node.registerForSubtree(observer);
            }
        });
        return node;
    }

    public static boolean isAvailableOn(Node node) {
        return node.containsData(NODE_TEXT_DATA);
    }

    private static AstObserver createObserver() {
        return new LexicalPreservingPrinter.Observer();
    }

    private static class Observer extends PropagatingAstObserver {

        @Override
        public void concretePropertyChange(Node observedNode, ObservableProperty property, Object oldValue, Object newValue) {
            if (oldValue == newValue) {
                // Not really a change, ignore
                return;
            }
            if (property == ObservableProperty.RANGE || property == ObservableProperty.COMMENTED_NODE) {
                return;
            }
            if (property == ObservableProperty.COMMENT) {
                Optional<Node> parentNode = observedNode.getParentNode();
                NodeText nodeText = parentNode.map(parent -> getOrCreateNodeText(parentNode.get())).
                        orElse(getOrCreateNodeText(observedNode));
                if (oldValue == null) { // this case corresponds to the addition of a comment
                    int index = parentNode.isPresent() ?
                            nodeText.findChild(observedNode) :
                            0;
                    fixIndentationOfMovedNode(nodeText, index - 1);
                    LineSeparator lineSeparator = observedNode.getLineEndingStyleOrDefault(LineSeparator.SYSTEM);
                    nodeText.addElement(index++, createCommentToken((Comment) newValue));
                    nodeText.addToken(index, eolTokenKind(lineSeparator), lineSeparator.asRawString());
                    // code indentation after inserting an eol token may be wrong
                } else if (newValue == null) { // this case corresponds to a deletion of a comment
                    if (oldValue instanceof Comment) {
                        if (((Comment) oldValue).isOrphan()) {
                            nodeText = getOrCreateNodeText(observedNode);
                        }
                        int index = getIndexOfComment((Comment) oldValue, nodeText);
                        nodeText.removeElement(index);
                        if (isCompleteLine(nodeText.getElements(), index)) {
                            removeAllExtraCharacters(nodeText.getElements(), index);
                        } else {
                            removeAllExtraCharactersStartingFrom(nodeText.getElements().listIterator(index));
                        }
                    } else {
                        throw new UnsupportedOperationException("Trying to remove something that is not a comment!");
                    }
                } else {
                    // this is a replacement of a comment
                    List<TokenTextElement> matchingTokens = findTokenTextElementsForComment((Comment) oldValue, nodeText);
                    if (matchingTokens.size() != 1) {
                        throw new IllegalStateException("The matching comment to be replaced could not be found");
                    }
                    Comment newComment = (Comment) newValue;
                    TokenTextElement matchingElement = matchingTokens.get(0);
                    nodeText.replace(matchingElement.and(matchingElement.matchByRange()), createCommentToken(newComment));
                }
            }
            NodeText nodeText = getOrCreateNodeText(observedNode);
            if (nodeText == null) {
                throw new NullPointerException(observedNode.getClass().getSimpleName());
            }
            LEXICAL_DIFFERENCE_CALCULATOR.calculatePropertyChange(nodeText, observedNode, property, oldValue, newValue);
        }

        private boolean isCompleteLine(List<TextElement> elements , int index) {
            if (index <= 0 || index >= elements.size()) return false;
            boolean isCompleteLine=true;
            ListIterator<TextElement> iterator = elements.listIterator(index);
            // verify if elements after the index are only spaces or tabs
            while(iterator.hasNext()) {
                TextElement textElement = iterator.next();
                if (textElement.isNewline()) break;
                if (textElement.isSpaceOrTab()) continue;
                isCompleteLine=false;
                break;
            }
            // verify if elements before the index are only spaces or tabs
            iterator = elements.listIterator(index);
            while(iterator.hasPrevious() && isCompleteLine) {
                TextElement textElement = iterator.previous();
                if (textElement.isNewline()) break;
                if (textElement.isSpaceOrTab()) continue;
                isCompleteLine=false;
            }

            return isCompleteLine;
        }

        private void removeAllExtraCharacters(List<TextElement> elements , int index) {
            if (index < 0 || index >= elements.size()) return;
            removeAllExtraCharactersStartingFrom(elements.listIterator(index));
            removeAllExtraCharactersBeforePosition(elements.listIterator(index));
        }

        private void removeAllExtraCharactersBeforePosition(ListIterator<TextElement> iterator) {
            while(iterator.hasPrevious()) {
                TextElement textElement = iterator.previous();
                if (textElement.isSpaceOrTab()) {
                    iterator.remove();
                    continue;
                }
                break;
            }
        }

        private void removeAllExtraCharactersStartingFrom(ListIterator<TextElement> iterator) {
            while(iterator.hasNext()) {
                TextElement textElement = iterator.next();
                if (textElement.isSpaceOrTab()) {
                    iterator.remove();
                    continue;
                }
                if (textElement.isNewline()) {
                    iterator.remove();
                }
                break;
            }
        }

        private TokenTextElement createCommentToken(Comment newComment) {
            if (newComment.isJavadocComment()) {
                return new TokenTextElement(JAVADOC_COMMENT, newComment.getHeader() + newComment.getContent() + newComment.getFooter());
            }
            if (newComment.isLineComment()) {
                return new TokenTextElement(SINGLE_LINE_COMMENT, newComment.getHeader() + newComment.getContent());
            }
            if (newComment.isBlockComment()) {
                return new TokenTextElement(MULTI_LINE_COMMENT, newComment.getHeader() + newComment.getContent() + newComment.getFooter());
            }
            throw new UnsupportedOperationException("Unknown type of comment: " + newComment.getClass().getSimpleName());
        }

        private int getIndexOfComment(Comment oldValue, NodeText nodeText) {
            List<TokenTextElement> matchingTokens = findTokenTextElementsForComment(oldValue, nodeText);
            if (!matchingTokens.isEmpty()) {
                TextElement matchingElement = matchingTokens.get(0);
                return nodeText.findElement(matchingElement.and(matchingElement.matchByRange()));
            }
            List<ChildTextElement> matchingChilds = findChildTextElementsForComment(oldValue, nodeText);
            ChildTextElement matchingChild = matchingChilds.get(0);
            return nodeText.findElement(matchingChild.and(matchingChild.matchByRange()));
        }

        private List<ChildTextElement> findChildTextElementsForComment(Comment oldValue, NodeText nodeText) {
            List<ChildTextElement> matchingChildElements;
            matchingChildElements = findMatchingChildElementsByComment(oldValue, nodeText);
            if (matchingChildElements.size() > 1) {
                matchingChildElements = matchingChildElements.stream().filter(t -> isEqualRange(t.getChild().getRange(), oldValue.getRange())).collect(toList());
            }
            if (matchingChildElements.size() != 1) {
                throw new IllegalStateException("The matching child text element for the comment to be removed could not be found.");
            }
            return matchingChildElements;
        }

        private List<ChildTextElement> findMatchingChildElementsByComment(Comment oldValue, NodeText nodeText) {
            List<ChildTextElement> result = new ArrayList<>();
            List<ChildTextElement> childTextElements = nodeText.getElements().stream().filter(e -> e.isChild())
                    .map(c -> (ChildTextElement) c).collect(toList());
            ListIterator<ChildTextElement> iterator = childTextElements.listIterator();
            while(iterator.hasNext()) {
                ChildTextElement textElement = iterator.next();
                if (textElement.isComment() && isCommentContentEqual(((Comment) textElement.getChild()), oldValue)) {
                    result.add(textElement);
                    continue;
                }
                Node node = textElement.getChild();
                if (node.getComment().isPresent() && isCommentContentEqual(node.getComment().get(), oldValue)) {
                    result.add(textElement);
                    continue;
                }
            }
            return result;
        }

        private boolean isCommentContentEqual(Comment childValue, Comment oldValue) {
            return childValue.getContent().equals(oldValue.getContent());
        }

        private List<TokenTextElement> findTokenTextElementsForComment(Comment oldValue, NodeText nodeText) {
            List<TokenTextElement> matchingTokens;
            if (oldValue instanceof JavadocComment) {
                matchingTokens = nodeText.getElements().stream().filter(e -> e.isToken(JAVADOC_COMMENT)).map(e -> (TokenTextElement) e).filter(t -> t.getText().equals(oldValue.getHeader() + oldValue.getContent() + oldValue.getFooter())).collect(toList());
            } else if (oldValue instanceof BlockComment) {
                matchingTokens = nodeText.getElements().stream().filter(e -> e.isToken(MULTI_LINE_COMMENT)).map(e -> (TokenTextElement) e).filter(t -> t.getText().equals(oldValue.getHeader() + oldValue.getContent() + oldValue.getFooter())).collect(toList());
            } else {
                matchingTokens = nodeText.getElements().stream().filter(e -> e.isToken(SINGLE_LINE_COMMENT)).map(e -> (TokenTextElement) e).filter(t -> t.getText().trim().equals((oldValue.getHeader() + oldValue.getContent()).trim())).collect(toList());
            }
            if (matchingTokens.size() > 1) {
                matchingTokens = matchingTokens.stream().filter(t -> isEqualRange(t.getToken().getRange(), oldValue.getRange())).collect(toList());
            }
            return matchingTokens;
        }

        private boolean isEqualRange(Optional<Range> range1, Optional<Range> range2) {
            if (range1.isPresent() && range2.isPresent()) {
                return range1.get().equals(range2.get());
            }
            return false;
        }

        private void fixIndentationOfMovedNode(NodeText nodeText, int index) {
            if (index <= 0) {
                return;
            }
            TextElement currentSpaceCandidate = null;
            for (int i = index; i >= 0; i--) {
                TextElement spaceCandidate = nodeText.getTextElement(i);
                if (spaceCandidate.isSpaceOrTab()) {
                    // save the current indentation char
                    currentSpaceCandidate = nodeText.getTextElement(i);
                }
                if (!spaceCandidate.isSpaceOrTab()) {
                    if (spaceCandidate.isNewline() && i != index) {
                        int numberOfIndentationCharacters = index - i;
                        for (int j = 0; j < numberOfIndentationCharacters; j++) {
                            if (currentSpaceCandidate != null) {
                                nodeText.addElement(index, new TokenTextElement(JavaToken.Kind.SPACE.getKind(), currentSpaceCandidate.expand()));
                            } else {
                                nodeText.addElement(index, new TokenTextElement(JavaToken.Kind.SPACE.getKind()));
                            }
                        }
                    }
                    break;
                }
            }
        }

        @Override
        public void concreteListChange(NodeList<?> changedList, ListChangeType type, int index, Node nodeAddedOrRemoved) {
            NodeText nodeText = getOrCreateNodeText(changedList.getParentNodeForChildren());
            final List<DifferenceElement> differenceElements;
            if (type == AstObserver.ListChangeType.REMOVAL) {
                differenceElements = LEXICAL_DIFFERENCE_CALCULATOR.calculateListRemovalDifference(findNodeListName(changedList), changedList, index);
            } else if (type == AstObserver.ListChangeType.ADDITION) {
                differenceElements = LEXICAL_DIFFERENCE_CALCULATOR.calculateListAdditionDifference(findNodeListName(changedList), changedList, index, nodeAddedOrRemoved);
            } else {
                throw new UnsupportedOperationException();
            }
            Difference difference = new Difference(differenceElements, nodeText, changedList.getParentNodeForChildren());
            difference.apply();
        }

        @Override
        public void concreteListReplacement(NodeList<?> changedList, int index, Node oldValue, Node newValue) {
            NodeText nodeText = getOrCreateNodeText(changedList.getParentNodeForChildren());
            List<DifferenceElement> differenceElements = LEXICAL_DIFFERENCE_CALCULATOR.calculateListReplacementDifference(findNodeListName(changedList), changedList, index, newValue);
            Difference difference = new Difference(differenceElements, nodeText, changedList.getParentNodeForChildren());
            difference.apply();
        }
    }

    private static void storeInitialText(Node root) {
        Map<Node, List<JavaToken>> tokensByNode = new IdentityHashMap<>();
        root.getTokenRange().ifPresent(rootTokenRange -> {
            for (JavaToken token : rootTokenRange) {
                Range tokenRange = token.getRange().orElseThrow(() -> new RuntimeException("Token without range: " + token));
                Node owner = findOwnerNodeForToken(root, tokenRange).orElseThrow(() -> new RuntimeException("Token without node owning it: " + token));
                if (!tokensByNode.containsKey(owner)) {
                    tokensByNode.put(owner, new LinkedList<>());
                }
                tokensByNode.get(owner).add(token);
            }
            new TreeVisitor() {
                @Override
                public void process(Node node) {
                    if (!node.isPhantom()) {
                        storeNodeInitialText(node, tokensByNode.get(node));
                    }
                }
            }.visitBreadthFirst(root);
        });
    }

    private static Optional<Node> findOwnerNodeForToken(Node node, Range tokenRange) {
        if (node.isPhantom()) {
            return Optional.empty();
        }
        if (!node.hasRange()) {
            return Optional.empty();
        }
        if (!node.getRange().get().contains(tokenRange)) {
            return Optional.empty();
        }
        for (Node child : node.getChildNodes()) {
            Optional<Node> found = findOwnerNodeForToken(child, tokenRange);
            if (found.isPresent()) {
                return found;
            }
        }
        return Optional.of(node);
    }

    private static void storeNodeInitialText(Node node, List<JavaToken> nodeTokens) {
        if (nodeTokens == null) {
            nodeTokens = Collections.emptyList();
        }
        List<Pair<Range, TextElement>> elements = new LinkedList<>();
        for (Node child : node.getChildNodes()) {
            if (!child.isPhantom()) {
                if (!child.hasRange()) {
                    throw new RuntimeException("Range not present on node " + child);
                }
                elements.add(new Pair<>(child.getRange().get(), new ChildTextElement(child)));
            }
        }
        for (JavaToken token : nodeTokens) {
            elements.add(new Pair<>(token.getRange().get(), new TokenTextElement(token)));
        }
        elements.sort(comparing(e -> e.a.begin));
        node.setData(NODE_TEXT_DATA, new NodeText(elements.stream().map(p -> p.b).collect(toList())));
    }

    private static Iterator<TokenTextElement> tokensPreceding(final Node node) {
        if (!node.getParentNode().isPresent()) {
            return new TextElementIteratorsFactory.EmptyIterator<>();
        }
        NodeText parentNodeText = getOrCreateNodeText(node.getParentNode().get());
        int index = parentNodeText.tryToFindChild(node);
        if (index == NodeText.NOT_FOUND) {
            if (node.getParentNode().get() instanceof VariableDeclarator) {
                return tokensPreceding(node.getParentNode().get());
            }
            return new TextElementIteratorsFactory.EmptyIterator<TokenTextElement>();
        }
        return new TextElementIteratorsFactory.CascadingIterator<>(TextElementIteratorsFactory.partialReverseIterator(parentNodeText, index - 1), () -> tokensPreceding(node.getParentNode().get()));
    }

    /**
     * Print a Node into a String, preserving the lexical information.
     */
    public static String print(Node node) {
        LexicalPreservingVisitor visitor = new LexicalPreservingVisitor();
        final NodeText nodeText = getOrCreateNodeText(node);
        nodeText.getElements().forEach(element -> element.accept(visitor));
        return visitor.toString();

    }

    private static void prettyPrintNodeText(Node node, NodeText nodeText) {
        if (node instanceof PrimitiveType) {
            PrimitiveType primitiveType = (PrimitiveType) node;
            switch(primitiveType.getType()) {
                case BOOLEAN:
                    nodeText.addToken(BOOLEAN, node.toString());
                    break;
                case CHAR:
                    nodeText.addToken(CHAR, node.toString());
                    break;
                case BYTE:
                    nodeText.addToken(BYTE, node.toString());
                    break;
                case SHORT:
                    nodeText.addToken(SHORT, node.toString());
                    break;
                case INT:
                    nodeText.addToken(INT, node.toString());
                    break;
                case LONG:
                    nodeText.addToken(LONG, node.toString());
                    break;
                case FLOAT:
                    nodeText.addToken(FLOAT, node.toString());
                    break;
                case DOUBLE:
                    nodeText.addToken(DOUBLE, node.toString());
                    break;
                default:
                    throw new IllegalArgumentException();
            }
            return;
        }
        if (node instanceof JavadocComment) {
            Comment comment = (JavadocComment) node;
            nodeText.addToken(JAVADOC_COMMENT, comment.getHeader() + ((JavadocComment) node).getContent() + comment.getFooter());
            return;
        }
        if (node instanceof BlockComment) {
            Comment comment = (BlockComment) node;
            nodeText.addToken(MULTI_LINE_COMMENT, comment.getHeader() + ((BlockComment) node).getContent() + comment.getFooter());
            return;
        }
        if (node instanceof LineComment) {
            Comment comment = (LineComment) node;
            nodeText.addToken(SINGLE_LINE_COMMENT, comment.getHeader() + comment.getContent());
            return;
        }
        if (node instanceof Modifier) {
            Modifier modifier = (Modifier) node;
            nodeText.addToken(LexicalDifferenceCalculator.toToken(modifier), modifier.getKeyword().asString());
            return;
        }
        interpret(node, ConcreteSyntaxModel.forClass(node.getClass()), nodeText);
    }

    /**
     * TODO: Process CsmIndent and CsmUnindent before reaching this point
     */
    private static NodeText interpret(Node node, CsmElement csm, NodeText nodeText) {
        LexicalDifferenceCalculator.CalculatedSyntaxModel calculatedSyntaxModel = new LexicalDifferenceCalculator().calculatedSyntaxModelForNode(csm, node);
        List<TextElement> indentation = findIndentation(node);
        boolean pendingIndentation = false;
        node.getComment().ifPresent(comment -> {
            if (!comment.hasRange()) {
                LineSeparator lineSeparator = node.getLineEndingStyleOrDefault(LineSeparator.SYSTEM);
                calculatedSyntaxModel.elements.add(0,new CsmToken(eolTokenKind(lineSeparator), lineSeparator.asRawString()));
                calculatedSyntaxModel.elements.add(0,new CsmChild(comment));
            }
        });
        for (CsmElement element : calculatedSyntaxModel.elements) {
            if (element instanceof CsmIndent) {
                int indexCurrentElement = calculatedSyntaxModel.elements.indexOf(element);
                if (calculatedSyntaxModel.elements.size() > indexCurrentElement && !(calculatedSyntaxModel.elements.get(indexCurrentElement + 1) instanceof CsmUnindent)) {
                    for (int i = 0; i < Difference.STANDARD_INDENTATION_SIZE; i++) {
                        indentation.add(new TokenTextElement(SPACE, " "));
                    }
                }
            } else if (element instanceof CsmUnindent) {
                for (int i = 0; i < Difference.STANDARD_INDENTATION_SIZE && indentation.size() > 0; i++) {
                    indentation.remove(indentation.size() - 1);
                }
            }
            if (pendingIndentation && !(element instanceof CsmToken && ((CsmToken) element).isNewLine())) {
                indentation.forEach(nodeText::addElement);
            }
            pendingIndentation = false;
            if (element instanceof LexicalDifferenceCalculator.CsmChild) {
                nodeText.addChild(((LexicalDifferenceCalculator.CsmChild) element).getChild());
            } else if (element instanceof CsmToken) {
                CsmToken csmToken = (CsmToken) element;
                nodeText.addToken(csmToken.getTokenType(), csmToken.getContent(node));
                if (csmToken.isNewLine()) {
                    pendingIndentation = true;
                }
            } else if (element instanceof CsmMix) {
                CsmMix csmMix = (CsmMix) element;
                csmMix.getElements().forEach(e -> interpret(node, e, nodeText));
            } else {
                if (!(element instanceof CsmIndent) && !(element instanceof CsmUnindent)) {
                    throw new UnsupportedOperationException(element.getClass().getSimpleName());
                }
            }
        }
        if (node instanceof VariableDeclarator) {
            VariableDeclarator variableDeclarator = (VariableDeclarator) node;
            variableDeclarator.getParentNode().ifPresent(parent -> ((NodeWithVariables<?>) parent).getMaximumCommonType().ifPresent(mct -> {
                int extraArrayLevels = variableDeclarator.getType().getArrayLevel() - mct.getArrayLevel();
                for (int i = 0; i < extraArrayLevels; i++) {
                    nodeText.addElement(new TokenTextElement(LBRACKET));
                    nodeText.addElement(new TokenTextElement(RBRACKET));
                }
            }));
        }
        return nodeText;
    }

    static NodeText getOrCreateNodeText(Node node) {
        if (!node.containsData(NODE_TEXT_DATA)) {
            NodeText nodeText = new NodeText();
            node.setData(NODE_TEXT_DATA, nodeText);
            prettyPrintNodeText(node, nodeText);
        }
        return node.getData(NODE_TEXT_DATA);
    }

    static List<TextElement> findIndentation(Node node) {
        List<TextElement> followingNewlines = new LinkedList<>();
        Iterator<TokenTextElement> it = tokensPreceding(node);
        while (it.hasNext()) {
            TokenTextElement tte = it.next();
            if (tte.getTokenKind() == SINGLE_LINE_COMMENT || tte.isNewline()) {
                break;
            }
            followingNewlines.add(tte);
        }
        Collections.reverse(followingNewlines);
        for (int i = 0; i < followingNewlines.size(); i++) {
            if (!followingNewlines.get(i).isSpaceOrTab()) {
                return followingNewlines.subList(0, i);
            }
        }
        return followingNewlines;
    }

    private static boolean isReturningOptionalNodeList(Method m) {
        if (!m.getReturnType().getCanonicalName().equals(JAVA_UTIL_OPTIONAL)) {
            return false;
        }
        if (!(m.getGenericReturnType() instanceof ParameterizedType)) {
            return false;
        }
        ParameterizedType parameterizedType = (ParameterizedType) m.getGenericReturnType();
        java.lang.reflect.Type optionalArgument = parameterizedType.getActualTypeArguments()[0];
        return (optionalArgument.getTypeName().startsWith(JAVAPARSER_AST_NODELIST));
    }

    private static ObservableProperty findNodeListName(NodeList<?> nodeList) {
        Node parent = nodeList.getParentNodeForChildren();
        for (Method m : parent.getClass().getMethods()) {
            if (m.getParameterCount() == 0 && m.getReturnType().getCanonicalName().equals(JAVAPARSER_AST_NODELIST)) {
                try {
                    Object raw = m.invoke(parent);
                    if (!(raw instanceof NodeList)) {
                        throw new IllegalStateException("Expected NodeList, found " + raw.getClass().getCanonicalName());
                    }
                    NodeList<?> result = (NodeList<?>) raw;
                    if (result == nodeList) {
                        String name = m.getName();
                        if (name.startsWith("get")) {
                            name = name.substring("get".length());
                        }
                        return ObservableProperty.fromCamelCaseName(decapitalize(name));
                    }
                } catch (IllegalAccessException | InvocationTargetException e) {
                    throw new RuntimeException(e);
                }
            } else if (m.getParameterCount() == 0 && isReturningOptionalNodeList(m)) {
                try {
                    Optional<NodeList<?>> raw = (Optional<NodeList<?>>) m.invoke(parent);
                    if (raw.isPresent() && raw.get() == nodeList) {
                        String name = m.getName();
                        if (name.startsWith("get")) {
                            name = name.substring("get".length());
                        }
                        return ObservableProperty.fromCamelCaseName(decapitalize(name));
                    }
                } catch (IllegalAccessException | InvocationTargetException e) {
                    throw new RuntimeException(e);
                }
            }
        }
        throw new IllegalArgumentException("Cannot find list name of NodeList of size " + nodeList.size());
    }
}
```

---

**Summary:**
Method names have been improved for clarity and spelling. All invocations and definitions have been changed accordingly throughout the class. No functional logic changes were made.

If you would like to further improve other identifier names (such as variables), let me know!