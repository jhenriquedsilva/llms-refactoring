23-04-2025, 19:48
This code is a great candidate for **Extract Method Refactoring**, especially to simplify long test methods and repeated blocks. Here are some clear refactoring opportunities:

1. **Extract Data Setup**: Data setup for test tables is verbose and repeated in several places.
2. **Extract JSON Plan Modification Logic**: The function body that modifies the JSON plan appears almost verbatim twice.
3. **Extract Expected Results Creation (optional)**: Though less urgent, building the expected results lists could be extracted.
4. **Consistent Naming and Reuse**: Improve naming and reuse extracted methods within test methods for better readability.

Below is your refactored code with these improvements:

```java
package org.apache.flink.table.planner.runtime.stream.jsonplan;

import org.apache.flink.table.api.TableException;
import org.apache.flink.table.data.GenericRowData;
import org.apache.flink.table.data.StringData;
import org.apache.flink.table.planner.factories.TestValuesTableFactory;
import org.apache.flink.table.planner.utils.JsonPlanTestBase;
import org.apache.flink.table.planner.utils.JsonTestUtils;

import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;

import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;

/**
 * Tests for configuring operator-level state TTL via {@link
 * org.apache.flink.table.api.CompiledPlan}.
 */
class ConfigureOperatorLevelStateTtlJsonITCase extends JsonPlanTestBase {

    @Test
    void testDifferentStateTtlForDifferentOneInputOperator() throws Exception {
        String dataId = registerOrdersSourceData();
        createOrdersSourceTable(dataId);
        createOrdersStatsSinkTable();

        compileSqlAndExecutePlan(getOrderStatsInsertSql(), getOneInputOperatorTtlSetter()).await();

        assertResult(getExpectedOrderStats(), TestValuesTableFactory.getResultsAsStrings("OrdersStats"));
    }

    @Test
    void testDifferentStateTtlForSameTwoInputStreamOperator() throws Exception {
        innerTestRegularJoin(
                getOrdersShipInfoInsertSql(),
                getTwoInputJoinOperatorTtlSetter());
    }

    @Test
    void testDifferentStateTtlThroughSqlHintForSameTwoInputStreamOperator() throws Exception {
        innerTestRegularJoin(
                getOrdersShipInfoInsertSqlWithHint(),
                Function.identity());
    }

    // ====== Extraction of Inner Test, Data, and Helper Methods ======

    private String registerOrdersSourceData() {
        return TestValuesTableFactory.registerRowData(
                Arrays.asList(
                        GenericRowData.of(1, StringData.fromString("Tom"), 1, 199.9d),
                        GenericRowData.of(2, StringData.fromString("Jerry"), 2, 99.9d),
                        GenericRowData.of(1, StringData.fromString("Tom"), 1, 199.9d),
                        GenericRowData.of(3, StringData.fromString("Tom"), 1, 29.9d),
                        GenericRowData.of(4, StringData.fromString("Olivia"), 1, 100d),
                        GenericRowData.of(4, StringData.fromString("Olivia"), 1, 100d),
                        GenericRowData.of(2, StringData.fromString("Jerry"), 2, 99.9d),
                        GenericRowData.of(5, StringData.fromString("Michael"), 3, 599.9d),
                        GenericRowData.of(6, StringData.fromString("Olivia"), 3, 1000d)
                ));
    }

    private void createOrdersSourceTable(String dataId) {
        createTestSourceTable(
            "Orders",
            new String[] {
                    "`order_id` INT", "`buyer` STRING", "`quantity` INT", "`amount` DOUBLE"
            },
            null,
            getProperties(dataId, 1, "2s")
        );
    }

    private void createOrdersStatsSinkTable() {
        createTestNonInsertOnlyValuesSinkTable(
                "OrdersStats",
                "`buyer` STRING",
                "`ord_cnt` BIGINT",
                "`quantity_cnt` BIGINT",
                "`total_amount` DOUBLE"
        );
    }

    private String getOrderStatsInsertSql() {
        return "INSERT INTO OrdersStats \n" +
                "SELECT buyer, COUNT(1) AS ord_cnt, SUM(quantity) AS quantity_cnt, SUM(amount) AS total_amount FROM (\n" +
                "SELECT *, ROW_NUMBER() OVER(PARTITION BY order_id, buyer, quantity, amount ORDER BY proctime() ASC) AS rk FROM Orders) tmp\n" +
                "WHERE rk = 1\n" +
                "GROUP BY buyer";
    }

    private Function<String, String> getOneInputOperatorTtlSetter() {
        return json -> {
            try {
                JsonNode target = JsonTestUtils.readFromString(json);
                JsonTestUtils.setExecNodeStateMetadata(
                        target, "stream-exec-deduplicate", 0, 6000L);
                JsonTestUtils.setExecNodeStateMetadata(
                        target, "stream-exec-group-aggregate", 0, 9000L);
                return JsonTestUtils.writeToString(target);
            } catch (IOException e) {
                throw new TableException("Cannot modify compiled json plan.", e);
            }
        };
    }

    private List<String> getExpectedOrderStats() {
        return Arrays.asList(
                "+I[Tom, 2, 2, 229.8]",
                "+I[Jerry, 1, 2, 99.9]",
                "+I[Jerry, 1, 2, 99.9]",
                "+I[Olivia, 2, 4, 1100.0]",
                "+I[Michael, 1, 3, 599.9]");
    }

    private String getOrdersShipInfoInsertSql() {
        return "INSERT INTO OrdersShipInfo \n" +
               "SELECT a.order_id, a.line_order_id, b.ship_mode FROM Orders a JOIN LineOrders b ON a.line_order_id = b.line_order_id";
    }

    private String getOrdersShipInfoInsertSqlWithHint() {
        return "INSERT INTO OrdersShipInfo \n" +
               "SELECT /*+ STATE_TTL('a' = '3s', 'b' = '9s') */\n" +
               " a.order_id, a.line_order_id, b.ship_mode " +
               "FROM Orders a JOIN LineOrders b ON a.line_order_id = b.line_order_id";
    }

    private Function<String, String> getTwoInputJoinOperatorTtlSetter() {
        return json -> {
            try {
                JsonNode target = JsonTestUtils.readFromString(json);
                JsonTestUtils.setExecNodeStateMetadata(
                        target, "stream-exec-join", 0, 3000L);
                JsonTestUtils.setExecNodeStateMetadata(
                        target, "stream-exec-join", 1, 9000L);
                return JsonTestUtils.writeToString(target);
            } catch (IOException e) {
                throw new TableException("Cannot modify compiled json plan.", e);
            }
        };
    }

    private void innerTestRegularJoin(String sql, Function<String, String> jsonPlanTransformer)
            throws Exception {
        String leftTableDataId = registerOrdersJoinLeftSourceData();
        createTestSourceTable(
                "Orders",
                new String[] {"`order_id` INT", "`line_order_id` INT"},
                null,
                getProperties(leftTableDataId, 1, "2s"));

        String rightTableDataId = registerOrdersJoinRightSourceData();
        createTestSourceTable(
                "LineOrders",
                new String[] {"`line_order_id` INT", "`ship_mode` STRING"},
                null,
                getProperties(rightTableDataId, 2, "4s"));

        createTestValuesSinkTable(
                "OrdersShipInfo", "`order_id` INT", "`line_order_id` INT", "`ship_mode` STRING");
        compileSqlAndExecutePlan(sql, jsonPlanTransformer).await();

        assertResult(getExpectedOrdersShipInfo(), TestValuesTableFactory.getResultsAsStrings("OrdersShipInfo"));
    }

    private String registerOrdersJoinLeftSourceData() {
        return TestValuesTableFactory.registerRowData(
                Arrays.asList(
                        GenericRowData.of(1, 1000001),
                        GenericRowData.of(1, 1000002),
                        GenericRowData.of(1, 1000003),
                        GenericRowData.of(1, 1000004),
                        GenericRowData.of(1, 1000005),
                        GenericRowData.of(2, 2000001)
                ));
    }

    private String registerOrdersJoinRightSourceData() {
        return TestValuesTableFactory.registerRowData(
                Arrays.asList(
                        GenericRowData.of(2000001, StringData.fromString("TRUCK")),
                        GenericRowData.of(1000005, StringData.fromString("AIR")),
                        GenericRowData.of(1000001, StringData.fromString("SHIP")),
                        GenericRowData.of(1000002, StringData.fromString("TRUCK")),
                        GenericRowData.of(1000003, StringData.fromString("RAIL")),
                        GenericRowData.of(1000004, StringData.fromString("RAIL"))
                ));
    }

    private List<String> getExpectedOrdersShipInfo() {
        return Arrays.asList(
                "+I[1, 1000002, TRUCK]", "+I[1, 1000004, RAIL]", "+I[1, 1000005, AIR]");
    }

    private static Map<String, String> getProperties(
            String dataId, int sleepAfterElements, String sleepTime) {
        return new HashMap<String, String>() {
            {
                put("connector", "values");
                put("bounded", "false");
                put("register-internal-data", "true");
                put("source.sleep-after-elements", String.valueOf(sleepAfterElements));
                put("source.sleep-time", sleepTime);
                put("data-id", dataId);
            }
        };
    }
}
```

**Summary of Refactorings:**
- **Methods like** `registerOrdersSourceData()`, `createOrdersSourceTable`, `createOrdersStatsSinkTable`, and SQL getter methods have been extracted.
- **JSON plan transformer functions** are extracted so their logic is clear and easily maintained.
- **Repeated data setup for join-related tests** is extracted.
- **Expected results list** is extracted for clarity.

**Benefit:**
All test methods now read at a higher level of abstraction, focusing on the "what" rather than the "how," which makes future maintenance and understanding much easier.