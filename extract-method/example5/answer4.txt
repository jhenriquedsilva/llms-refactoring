23-04-2025, 19:57
Your code provides several refactoring opportunities, especially suited for **Extract Method** refactoring, which makes it easier to understand, maintain, and test individual units. Below are some concrete suggestions and a refactored version.

---

## Identified **Extract Method** Opportunities

1. **Data Registration for Tables:**
   The repeated `TestValuesTableFactory.registerRowData(...)` followed by `createTestSourceTable(...)` can be abstracted into a helper method to avoid duplication.

2. **Sink Table Creation:**
   The invocations of `createTestNonInsertOnlyValuesSinkTable` and `createTestValuesSinkTable` could be similarly abstracted.

3. **Plan Transformation for JSON:**
   The inline anonymous plan transformer functions repeated similar logic.

---

## Refactored Code

```java
package org.apache.flink.table.planner.runtime.stream.jsonplan;

// ... (imports stay the same) ...

class ConfigureOperatorLevelStateTtlJsonITCase extends JsonPlanTestBase {

    @Test
    void testDifferentStateTtlForDifferentOneInputOperator() throws Exception {
        List<GenericRowData> orderRows = Arrays.asList(
            GenericRowData.of(1, StringData.fromString("Tom"), 1, 199.9d),
            GenericRowData.of(2, StringData.fromString("Jerry"), 2, 99.9d),
            GenericRowData.of(1, StringData.fromString("Tom"), 1, 199.9d),
            GenericRowData.of(3, StringData.fromString("Tom"), 1, 29.9d),
            GenericRowData.of(4, StringData.fromString("Olivia"), 1, 100d),
            GenericRowData.of(4, StringData.fromString("Olivia"), 1, 100d),
            GenericRowData.of(2, StringData.fromString("Jerry"), 2, 99.9d),
            GenericRowData.of(5, StringData.fromString("Michael"), 3, 599.9d),
            GenericRowData.of(6, StringData.fromString("Olivia"), 3, 1000d)
        );
        registerOrdersSourceTable(orderRows, 1, "2s");

        createOrdersStatsSinkTable();

        compileSqlAndExecutePlan("INSERT INTO OrdersStats \n"
                + "SELECT buyer, COUNT(1) AS ord_cnt, SUM(quantity) AS quantity_cnt, SUM(amount) AS total_amount FROM (\n"
                + "SELECT *, ROW_NUMBER() OVER(PARTITION BY order_id, buyer, quantity, amount ORDER BY proctime() ASC) AS rk FROM Orders) tmp\n"
                + "WHERE rk = 1\n"
                + "GROUP BY buyer", createOneInputStateTtlPlanTransformer())
            .await();

        List<String> expected = Arrays.asList(
                "+I[Tom, 2, 2, 229.8]",
                "+I[Jerry, 1, 2, 99.9]",
                "+I[Jerry, 1, 2, 99.9]",
                "+I[Olivia, 2, 4, 1100.0]",
                "+I[Michael, 1, 3, 599.9]"
        );
        assertResult(expected, TestValuesTableFactory.getResultsAsStrings("OrdersStats"));
    }

    @Test
    void testDifferentStateTtlForSameTwoInputStreamOperator() throws Exception {
        innerTestRegularJoin(
            "INSERT INTO OrdersShipInfo \n"
                + "SELECT a.order_id, a.line_order_id, b.ship_mode FROM Orders a JOIN LineOrders b ON a.line_order_id = b.line_order_id",
            createTwoInputStateTtlPlanTransformer()
        );
    }

    @Test
    void testDifferentStateTtlThroughSqlHintForSameTwoInputStreamOperator() throws Exception {
        innerTestRegularJoin(
            "INSERT INTO OrdersShipInfo \n"
                + "SELECT /*+ STATE_TTL('a' = '3s', 'b' = '9s') */\n"
                + " a.order_id, a.line_order_id, b.ship_mode \n"
                + "FROM Orders a JOIN LineOrders b ON a.line_order_id = b.line_order_id",
            Function.identity()
        );
    }

    private void innerTestRegularJoin(String sql, Function<String, String> jsonPlanTransformer)
            throws Exception {
        registerOrdersSourceTable(
            Arrays.asList(
                GenericRowData.of(1, 1000001),
                GenericRowData.of(1, 1000002),
                GenericRowData.of(1, 1000003),
                GenericRowData.of(1, 1000004),
                GenericRowData.of(1, 1000005),
                GenericRowData.of(2, 2000001)
            ), 1, "2s"
        );

        registerLineOrdersSourceTable(
            Arrays.asList(
                GenericRowData.of(2000001, StringData.fromString("TRUCK")),
                GenericRowData.of(1000005, StringData.fromString("AIR")),
                GenericRowData.of(1000001, StringData.fromString("SHIP")),
                GenericRowData.of(1000002, StringData.fromString("TRUCK")),
                GenericRowData.of(1000003, StringData.fromString("RAIL")),
                GenericRowData.of(1000004, StringData.fromString("RAIL"))
            ), 2, "4s"
        );

        createOrdersShipInfoSinkTable();

        compileSqlAndExecutePlan(sql, jsonPlanTransformer).await();

        List<String> expected = Arrays.asList(
                "+I[1, 1000002, TRUCK]",
                "+I[1, 1000004, RAIL]",
                "+I[1, 1000005, AIR]"
        );
        assertResult(expected, TestValuesTableFactory.getResultsAsStrings("OrdersShipInfo"));
    }

    // ---------- Extracted Helper Methods ---------

    private void registerOrdersSourceTable(List<GenericRowData> rows, int sleepAfterElements, String sleepTime) {
        String dataId = TestValuesTableFactory.registerRowData(rows);
        createTestSourceTable(
                "Orders",
                new String[]{"`order_id` INT", rows.get(0).getArity() > 2 ? "`buyer` STRING" : "`line_order_id` INT",
                        rows.get(0).getArity() > 2 ? "`quantity` INT" : null,
                        rows.get(0).getArity() > 2 ? "`amount` DOUBLE" : null},
                null,
                getProperties(dataId, sleepAfterElements, sleepTime)
        );
    }

    private void registerLineOrdersSourceTable(List<GenericRowData> rows, int sleepAfterElements, String sleepTime) {
        String dataId = TestValuesTableFactory.registerRowData(rows);
        createTestSourceTable(
                "LineOrders",
                new String[]{"`line_order_id` INT", "`ship_mode` STRING"},
                null,
                getProperties(dataId, sleepAfterElements, sleepTime)
        );
    }

    private void createOrdersStatsSinkTable() {
        createTestNonInsertOnlyValuesSinkTable(
            "OrdersStats",
            "`buyer` STRING",
            "`ord_cnt` BIGINT",
            "`quantity_cnt` BIGINT",
            "`total_amount` DOUBLE"
        );
    }

    private void createOrdersShipInfoSinkTable() {
        createTestValuesSinkTable(
            "OrdersShipInfo", "`order_id` INT", "`line_order_id` INT", "`ship_mode` STRING"
        );
    }

    private Function<String, String> createOneInputStateTtlPlanTransformer() {
        return json -> {
            try {
                JsonNode target = JsonTestUtils.readFromString(json);
                JsonTestUtils.setExecNodeStateMetadata(target, "stream-exec-deduplicate", 0, 6000L);
                JsonTestUtils.setExecNodeStateMetadata(target, "stream-exec-group-aggregate", 0, 9000L);
                return JsonTestUtils.writeToString(target);
            } catch (IOException e) {
                throw new TableException("Cannot modify compiled json plan.", e);
            }
        };
    }

    private Function<String, String> createTwoInputStateTtlPlanTransformer() {
        return json -> {
            try {
                JsonNode target = JsonTestUtils.readFromString(json);
                JsonTestUtils.setExecNodeStateMetadata(target, "stream-exec-join", 0, 3000L);
                JsonTestUtils.setExecNodeStateMetadata(target, "stream-exec-join", 1, 9000L);
                return JsonTestUtils.writeToString(target);
            } catch (IOException e) {
                throw new TableException("Cannot modify compiled json plan.", e);
            }
        };
    }

    // (No changes to getProperties)
    private static Map<String, String> getProperties(
            String dataId, int sleepAfterElements, String sleepTime) {
        return new HashMap<String, String>() {
            {
                put("connector", "values");
                put("bounded", "false");
                put("register-internal-data", "true");
                put("source.sleep-after-elements", String.valueOf(sleepAfterElements));
                put("source.sleep-time", sleepTime);
                put("data-id", dataId);
            }
        };
    }
}
```

---

### **Summary of Changes**
- **Extracted repeated code** for test table creation and plan transformation into private helper methods with meaningful names.
- **Improved readability** and **reduced code duplication**.
- The test logic in the top-level test methods is now much clearer and shorter.
- Any logic relating to "how a source/sink table is registered" or "how the plan transformation is done for different TTL scenarios" is **centralized**.

---

If you have more test cases in the future, the extracted methods will make it much easier to extend your suite.