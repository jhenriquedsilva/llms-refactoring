28-05-2025, 21:15
### Review and Refactoring Opportunities

Upon reviewing the code, **the three guessMimeType methods** (overloaded for `Path`, `InputStream`, and `byte[]`) all repeat the same pattern:

- call `util.findMatch(...)`
- check if the result is `null` and return `ContentType.OTHER.getMimeType()`
- else return the result's mime type
- each of the two methods (`Path` and `InputStream`) wrap this in exception handling

**Refactoring Opportunity:**
We can extract the repeated "extract mime type from ContentInfo" logic into a **private helper method**.
Also, we can extract the try-catch into another helper or consolidate input handling to reduce boilerplate and improve testability.

Letâ€™s apply **extract method refactoring** here for clarity and maintainability.

------------------

## Refactored Class

```java
package org.apache.solr.util;

import com.j256.simplemagic.ContentInfo;
import com.j256.simplemagic.ContentInfoUtil;
import com.j256.simplemagic.ContentType;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Locale;
import java.util.Set;
import org.apache.solr.common.SolrException;

/** Utility class to guess the mime type of file based on its magic number. */
public class FileTypeMagicUtil implements ContentInfoUtil.ErrorCallBack {
    private final ContentInfoUtil util;
    private static final Set<String> SKIP_FOLDERS = new HashSet<>(Arrays.asList(".", ".."));

    public static FileTypeMagicUtil INSTANCE = new FileTypeMagicUtil();

    FileTypeMagicUtil() {
        try {
            util = new ContentInfoUtil("/magic/executables", this);
        } catch (IOException e) {
            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Error parsing magic file", e);
        }
    }

    public static void assertConfigSetFolderLegal(Path confPath) throws IOException {
        Files.walkFileTree(
                confPath,
                new SimpleFileVisitor<>() {
                    @Override
                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
                        if (FileTypeMagicUtil.isFileForbiddenInConfigset(file)) {
                            throw new SolrException(
                                    SolrException.ErrorCode.BAD_REQUEST,
                                    String.format(
                                            Locale.ROOT,
                                            "Not uploading file %s to configset, as it matched the MAGIC signature of a forbidden mime type %s",
                                            file,
                                            FileTypeMagicUtil.INSTANCE.guessMimeType(file)));
                        }
                        return FileVisitResult.CONTINUE;
                    }

                    @Override
                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
                        if (SKIP_FOLDERS.contains(dir.getFileName().toString()))
                            return FileVisitResult.SKIP_SUBTREE;

                        return FileVisitResult.CONTINUE;
                    }
                });
    }

    /**
     * Guess the mime type of file based on its magic number.
     *
     * @param file file to check
     * @return string with content-type or "application/octet-stream" if unknown
     */
    public String guessMimeType(Path file) {
        try {
            return extractMimeType(util.findMatch(file.toFile()));
        } catch (IOException e) {
            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);
        }
    }

    /**
     * Guess the mime type of file based on its magic number.
     *
     * @param stream input stream of the file
     * @return string with content-type or "application/octet-stream" if unknown
     */
    String guessMimeType(InputStream stream) {
        try {
            return extractMimeType(util.findMatch(stream));
        } catch (IOException e) {
            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);
        }
    }

    /**
     * Guess the mime type of file bytes based on its magic number.
     *
     * @param bytes the first bytes at start of the file
     * @return string with content-type or "application/octet-stream" if unknown
     */
    public String guessMimeType(byte[] bytes) {
        return extractMimeType(util.findMatch(bytes));
    }

    /**
     * Private helper method to extract the mime type from ContentInfo, or return "application/octet-stream" if unknown.
     */
    private String extractMimeType(ContentInfo contentInfo) {
        if (contentInfo == null) {
            return ContentType.OTHER.getMimeType();
        } else {
            return contentInfo.getContentType().getMimeType();
        }
    }

    @Override
    public void error(String line, String details, Exception e) {
        throw new SolrException(
                SolrException.ErrorCode.SERVER_ERROR,
                String.format(Locale.ROOT, "%s: %s", line, details),
                e);
    }

    public static boolean isFileForbiddenInConfigset(Path file) {
        try (InputStream fileStream = Files.newInputStream(file)) {
            return isFileForbiddenInConfigset(fileStream);
        } catch (IOException e) {
            throw new SolrException(
                    SolrException.ErrorCode.SERVER_ERROR,
                    String.format(Locale.ROOT, "Error reading file %s", file),
                    e);
        }
    }

    static boolean isFileForbiddenInConfigset(InputStream fileStream) {
        return forbiddenTypes.contains(FileTypeMagicUtil.INSTANCE.guessMimeType(fileStream));
    }

    public static boolean isFileForbiddenInConfigset(byte[] bytes) {
        if (bytes == null || bytes.length == 0)
            return false; // A ZK znode may be a folder with no content
        return forbiddenTypes.contains(FileTypeMagicUtil.INSTANCE.guessMimeType(bytes));
    }

    private static final Set<String> forbiddenTypes =
            new HashSet<>(
                    Arrays.asList(
                            System.getProperty(
                                            "solr.configset.upload.mimetypes.forbidden",
                                            "application/x-java-applet,application/zip,application/x-tar,text/x-shellscript")
                                    .split(",")));
}
```

---

### **Explanation**
#### Main refactoring:
- **Extracted a private `extractMimeType(ContentInfo)` method.**
- **All three public guessMimeType methods** now delegate to this method after retrieving the `ContentInfo` object.

**Benefits:**
- Removes code duplication
- Centralizes the fallback to `application/octet-stream`
- Simplifies future changes to mime-type handling

---

**This refactoring improves readability, maintainability, and testability.**

Levenshtein edit-distance: 567
Compiles
Tests pass