29-04-2025, 21:46

Yes, there are **multiple opportunities for Extract Variable refactoring** in this code to improve readability, especially where constructor-style or method chains are used, or complex expressions are repeatedly used as method arguments. Iâ€™ll list prominent examples, **apply the refactoring**, and generate the whole refactored class.

## Notable spots for Extract Variable

**1. Complex argument composition & nested calls**
For example, in `evictEntity`:
```java
final Object ck = cache.generateCacheKey(
    id,
    persister,
    source.getFactory(),
    source.getTenantIdentifier()
);
final SoftLock lock = cache.lockItem( source, ck, previousVersion );
cache.remove( source, ck );
source.getActionQueue().registerProcess( (success, session) -> cache.unlockItem( session, ck, lock ) );
```
Here, both the computation of `ck` and the lambda for registering the unlockItem can be much clearer with variables.

**2. Repeated fetches**
For example:
```java
final SessionFactoryImplementor factory = source.getFactory();
final MappingMetamodelImplementor metamodel = factory.getRuntimeMetamodels().getMappingMetamodel();
```
Each time we fetch these, we should extract as variable at the scope intended.

**3. Complex conditional branches & chaining**
Any complex chained expressions (such as type casts) benefit from naming.

---

## Refactored class with Extract Variable Improvements

```java
package org.hibernate.event.internal;

import org.hibernate.HibernateException;
import org.hibernate.LockMode;
import org.hibernate.LockOptions;
import org.hibernate.NonUniqueObjectException;
import org.hibernate.TransientObjectException;
import org.hibernate.UnresolvableObjectException;
import org.hibernate.cache.spi.access.CollectionDataAccess;
import org.hibernate.cache.spi.access.EntityDataAccess;
import org.hibernate.cache.spi.access.SoftLock;
import org.hibernate.engine.internal.Cascade;
import org.hibernate.engine.internal.CascadePoint;
import org.hibernate.engine.spi.ActionQueue;
import org.hibernate.engine.spi.CascadingActions;
import org.hibernate.engine.spi.EntityEntry;
import org.hibernate.engine.spi.EntityKey;
import org.hibernate.engine.spi.PersistenceContext;
import org.hibernate.engine.spi.SessionFactoryImplementor;
import org.hibernate.event.spi.EventSource;
import org.hibernate.event.spi.RefreshContext;
import org.hibernate.event.spi.RefreshEvent;
import org.hibernate.event.spi.RefreshEventListener;
import org.hibernate.internal.CoreLogging;
import org.hibernate.internal.CoreMessageLogger;
import org.hibernate.loader.ast.spi.CascadingFetchProfile;
import org.hibernate.metamodel.spi.MappingMetamodelImplementor;
import org.hibernate.persister.collection.CollectionPersister;
import org.hibernate.persister.entity.EntityPersister;
import org.hibernate.proxy.HibernateProxy;
import org.hibernate.proxy.LazyInitializer;
import org.hibernate.type.CollectionType;
import org.hibernate.type.CompositeType;
import org.hibernate.type.Type;

import static org.hibernate.pretty.MessageHelper.infoString;

public class DefaultRefreshEventListener implements RefreshEventListener {
    private static final CoreMessageLogger LOG = CoreLogging.messageLogger( DefaultRefreshEventListener.class );

    public void onRefresh(RefreshEvent event) throws HibernateException {
        onRefresh( event, RefreshContext.create() );
    }

    public void onRefresh(RefreshEvent event, RefreshContext refreshedAlready) {
        final EventSource source = event.getSession();
        final PersistenceContext persistenceContext = source.getPersistenceContextInternal();
        final Object object = event.getObject();
        if ( persistenceContext.reassociateIfUninitializedProxy( object ) ) {
            final LazyInitializer lazyInitializer = HibernateProxy.extractLazyInitializer( object );
            final String entityName = lazyInitializer.getEntityName();
            final EntityPersister persister = source.getEntityPersister( entityName, object );
            final Object identifier = persister.getIdentifier( object, event.getSession() );
            refresh(
                    event,
                    null,
                    source,
                    persister,
                    lazyInitializer,
                    null,
                    identifier,
                    persistenceContext
            );
            if ( isTransient( event, source, object )  ) {
                source.setReadOnly( object, source.isDefaultReadOnly() );
            }
        }
        else {
            final Object entity = persistenceContext.unproxyAndReassociate( object );
            if ( refreshedAlready.add( entity ) ) {
                refresh( event, refreshedAlready, entity );
            } else {
                LOG.trace( "Already refreshed" );
            }
        }
    }

    private static boolean isTransient(RefreshEvent event, EventSource source, Object object) {
        final String entityName = event.getEntityName();
        return entityName != null ? !source.contains( entityName, object ) : !source.contains(object);
    }

    private static void refresh(RefreshEvent event, RefreshContext refreshedAlready, Object object) {
        final EventSource source = event.getSession();
        final PersistenceContext persistenceContext = source.getPersistenceContextInternal();
        final EntityEntry entry = persistenceContext.getEntry( object );
        final EntityPersister persister;
        final Object id;
        if ( entry == null ) {
            persister = source.getEntityPersister( event.getEntityName(), object );
            id = persister.getIdentifier( object, event.getSession() );
            if ( id == null ) {
                throw new TransientObjectException( "transient instance passed to refresh");
            }
            if ( LOG.isTraceEnabled() ) {
                String info = infoString( persister, id, source.getFactory() );
                LOG.tracev( "Refreshing transient {0}", info );
            }
            EntityKey entityKey = source.generateEntityKey( id, persister );
            if ( persistenceContext.getEntry( entityKey ) != null ) {
                throw new NonUniqueObjectException( id, persister.getEntityName() );
            }
        }
        else {
            if ( LOG.isTraceEnabled() ) {
                String info = infoString( entry.getPersister(), entry.getId(), source.getFactory() );
                LOG.tracev( "Refreshing ", info );
            }
            if ( !entry.isExistsInDatabase() ) {
                throw new UnresolvableObjectException(
                        entry.getId(),
                        "this instance does not yet exist as a row in the database"
                );
            }
            persister = entry.getPersister();
            id = entry.getId();
        }

        // cascade the refresh prior to refreshing this entity
        Cascade.cascade(
                CascadingActions.REFRESH,
                CascadePoint.BEFORE_REFRESH,
                source,
                persister,
                object,
                refreshedAlready
        );

        if ( entry != null ) {
            final EntityKey key = source.generateEntityKey( id, persister );
            persistenceContext.removeEntity( key );
            if ( persister.hasCollections() ) {
                EvictVisitor evictVisitor = new EvictVisitor( source, object );
                evictVisitor.process( object, persister );
            }
        }

        evictEntity( object, persister, id, source );
        evictCachedCollections( persister, id, source );

        refresh( event, object, source, persister, null, entry, id, persistenceContext );
    }

    private static void refresh(
            RefreshEvent event,
            Object object,
            EventSource source,
            EntityPersister persister,
            LazyInitializer lazyInitializer,
            EntityEntry entry,
            Object id,
            PersistenceContext persistenceContext) {

        final Object result = source.getLoadQueryInfluencers().fromInternalFetchProfile(
                CascadingFetchProfile.REFRESH,
                () -> doRefresh( event, source, object, entry, persister, lazyInitializer, id, persistenceContext )
        );
        final String entityName = persister.getEntityName();
        UnresolvableObjectException.throwIfNull( result, id, entityName );
    }

    private static void evictEntity(Object object, EntityPersister persister, Object id, EventSource source) {
        if ( persister.canWriteToCache() ) {
            Object previousVersion = null;
            if ( persister.isVersionPropertyGenerated() ) {
                previousVersion = persister.getVersion( object );
            }
            final EntityDataAccess cache = persister.getCacheAccessStrategy();
            final SessionFactoryImplementor factory = source.getFactory();
            final String tenantIdentifier = source.getTenantIdentifier();
            final Object cacheKey = cache.generateCacheKey( id, persister, factory, tenantIdentifier );
            final SoftLock lock = cache.lockItem( source, cacheKey, previousVersion );
            cache.remove( source, cacheKey );
            ActionQueue actionQueue = source.getActionQueue();
            actionQueue.registerProcess(
                (success, session) -> cache.unlockItem( session, cacheKey, lock )
            );
        }
    }

    private static Object doRefresh(
            RefreshEvent event,
            EventSource source,
            Object object,
            EntityEntry entry,
            EntityPersister persister,
            LazyInitializer lazyInitializer,
            Object id,
            PersistenceContext persistenceContext) {
        // Handle the requested lock-mode (if one) in relation to the entry's (if one) current lock-mode
        LockOptions eventLockOptions = event.getLockOptions();
        final LockMode requestedLockMode = eventLockOptions.getLockMode();
        final LockMode postRefreshLockMode;
        LockOptions lockOptionsToUse = eventLockOptions;

        if ( entry != null ) {
            final LockMode currentLockMode = entry.getLockMode();
            if ( currentLockMode.greaterThan( requestedLockMode ) ) {
                // pass along the current lock-mode (after accounting for WRITE)
                lockOptionsToUse = eventLockOptions.makeCopy();
                if ( currentLockMode == LockMode.WRITE
                        || currentLockMode == LockMode.PESSIMISTIC_WRITE
                        || currentLockMode == LockMode.PESSIMISTIC_READ ) {
                    lockOptionsToUse.setLockMode( LockMode.READ );
                    postRefreshLockMode = currentLockMode;
                }
                else {
                    lockOptionsToUse.setLockMode( currentLockMode );
                    postRefreshLockMode = null;
                }
            }
            else {
                postRefreshLockMode = null;
            }
        }
        else {
            postRefreshLockMode = null;
        }

        final Object result = persister.load( id, object, lockOptionsToUse, source );
        if ( result != null ) {
            // apply postRefreshLockMode, if needed
            if ( postRefreshLockMode != null ) {
                final EntityEntry refreshedEntry = persistenceContext.getEntry( result );
                refreshedEntry.setLockMode( postRefreshLockMode );
            }
            boolean readOnly = isReadOnly( entry, persister, lazyInitializer, source );
            source.setReadOnly( result, readOnly );
        }
        return result;
    }

    private static boolean isReadOnly(
            EntityEntry entry,
            EntityPersister persister,
            LazyInitializer lazyInitializer,
            EventSource source) {
        if ( !persister.isMutable() ) {
            return true;
        }
        else if ( entry != null ) {
            return entry.isReadOnly();
        }
        else if ( lazyInitializer != null ) {
            return lazyInitializer.isReadOnly();
        }
        else {
            return source.isDefaultReadOnly();
        }
    }

    private static void evictCachedCollections(EntityPersister persister, Object id, EventSource source) {
        Type[] propertyTypes = persister.getPropertyTypes();
        evictCachedCollections( propertyTypes, id, source );
    }

    private static void evictCachedCollections(Type[] types, Object id, EventSource source)
            throws HibernateException {
        final ActionQueue actionQueue = source.getActionQueue();
        final SessionFactoryImplementor factory = source.getFactory();
        final String tenantIdentifier = source.getTenantIdentifier();
        final MappingMetamodelImplementor metamodel = factory.getRuntimeMetamodels().getMappingMetamodel();
        for ( Type type : types ) {
            if ( type.isCollectionType() ) {
                final CollectionType collectionType = (CollectionType) type;
                final String role = collectionType.getRole();
                final CollectionPersister collectionPersister = metamodel.getCollectionDescriptor( role );
                if ( collectionPersister.hasCache() ) {
                    final CollectionDataAccess cache = collectionPersister.getCacheAccessStrategy();
                    final Object cacheKey = cache.generateCacheKey( id, collectionPersister, factory, tenantIdentifier );
                    final SoftLock lock = cache.lockItem( source, cacheKey, null );
                    cache.remove( source, cacheKey );
                    actionQueue.registerProcess(
                        (success, session) -> cache.unlockItem( session, cacheKey, lock )
                    );
                }
            }
            else if ( type.isComponentType() ) {
                final CompositeType compositeType = (CompositeType) type;
                Type[] subtypes = compositeType.getSubtypes();
                evictCachedCollections( subtypes, id, source );
            }
        }
    }
}
```

---

### **Summary of the Extract Variable Refactoring**
- Named intermediate values (e.g., variables for tenant ID, cache key, factory, roles, etc.).
- Extracted result of type casts and method chains used multiple times in a block.
- Used descriptive variable names to help identify what is being constructed (e.g., `cacheKey`, `actionQueue`, `info`, etc.).
- Broke down lambdas and chained calls for cache eviction for clarity.

**This should improve readability and ease future maintenance. If you notice further complex expressions specific to your team's coding standards needing lifting, similar extraction can be done throughout.**
