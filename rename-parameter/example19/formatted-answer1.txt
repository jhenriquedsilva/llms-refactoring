package org.springframework.boot.autoconfigure.pulsar;

import java.time.Duration;
import java.util.ArrayList;
import java.util.Map;
import java.util.TreeMap;
import java.util.concurrent.TimeUnit;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

import org.apache.pulsar.client.admin.PulsarAdminBuilder;
import org.apache.pulsar.client.api.ClientBuilder;
import org.apache.pulsar.client.api.ConsumerBuilder;
import org.apache.pulsar.client.api.ProducerBuilder;
import org.apache.pulsar.client.api.PulsarClientException.UnsupportedAuthenticationException;
import org.apache.pulsar.client.api.ReaderBuilder;
import org.apache.pulsar.common.util.ObjectMapperFactory;

import org.springframework.boot.context.properties.PropertyMapper;
import org.springframework.pulsar.listener.PulsarContainerProperties;
import org.springframework.pulsar.reader.PulsarReaderContainerProperties;
import org.springframework.util.StringUtils;

final class PulsarPropertiesMapper {

    private final PulsarProperties properties;

    PulsarPropertiesMapper(PulsarProperties properties) {
        this.properties = properties;
    }

    void customizeClientBuilder(ClientBuilder clientBuilder, PulsarConnectionDetails connectionDetails) {
        PulsarProperties.Client clientProperties = this.properties.getClient();
        PropertyMapper propertyMapper = PropertyMapper.get().alwaysApplyingWhenNonNull();
        propertyMapper.from(connectionDetails::getBrokerUrl).to(clientBuilder::serviceUrl);
        propertyMapper.from(clientProperties::getConnectionTimeout).to(timeoutProperty(clientBuilder::connectionTimeout));
        propertyMapper.from(clientProperties::getOperationTimeout).to(timeoutProperty(clientBuilder::operationTimeout));
        propertyMapper.from(clientProperties::getLookupTimeout).to(timeoutProperty(clientBuilder::lookupTimeout));
        customizeAuthentication(clientBuilder::authentication, clientProperties.getAuthentication());
    }

    void customizeAdminBuilder(PulsarAdminBuilder adminBuilder, PulsarConnectionDetails connectionDetails) {
        PulsarProperties.Admin adminProperties = this.properties.getAdmin();
        PropertyMapper propertyMapper = PropertyMapper.get().alwaysApplyingWhenNonNull();
        propertyMapper.from(connectionDetails::getAdminUrl).to(adminBuilder::serviceHttpUrl);
        propertyMapper.from(adminProperties::getConnectionTimeout).to(timeoutProperty(adminBuilder::connectionTimeout));
        propertyMapper.from(adminProperties::getReadTimeout).to(timeoutProperty(adminBuilder::readTimeout));
        propertyMapper.from(adminProperties::getRequestTimeout).to(timeoutProperty(adminBuilder::requestTimeout));
        customizeAuthentication(adminBuilder::authentication, adminProperties.getAuthentication());
    }

    private void customizeAuthentication(AuthenticationConsumer authentication, PulsarProperties.Authentication authenticationProperties) {
        if (!StringUtils.hasText(authenticationProperties.getPluginClassName())) {
            return;
        }
        try {
            Map<String, String> authParamsMap = new TreeMap<>(authenticationProperties.getParam());
            String authParamString;
            try {
                authParamString = ObjectMapperFactory.create().writeValueAsString(authParamsMap);
            } catch (Exception ex) {
                throw new IllegalStateException("Could not convert auth parameters to encoded string", ex);
            }
            authentication.accept(authenticationProperties.getPluginClassName(), authParamString);
        } catch (UnsupportedAuthenticationException ex) {
            throw new IllegalStateException("Unable to configure Pulsar authentication", ex);
        }
    }

    <T> void customizeProducerBuilder(ProducerBuilder<T> producerBuilder) {
        PulsarProperties.Producer producerProperties = this.properties.getProducer();
        PropertyMapper propertyMapper = PropertyMapper.get().alwaysApplyingWhenNonNull();
        propertyMapper.from(producerProperties::getName).to(producerBuilder::producerName);
        propertyMapper.from(producerProperties::getTopicName).to(producerBuilder::topic);
        propertyMapper.from(producerProperties::getSendTimeout).to(timeoutProperty(producerBuilder::sendTimeout));
        propertyMapper.from(producerProperties::getMessageRoutingMode).to(producerBuilder::messageRoutingMode);
        propertyMapper.from(producerProperties::getHashingScheme).to(producerBuilder::hashingScheme);
        propertyMapper.from(producerProperties::isBatchingEnabled).to(producerBuilder::enableBatching);
        propertyMapper.from(producerProperties::isChunkingEnabled).to(producerBuilder::enableChunking);
        propertyMapper.from(producerProperties::getCompressionType).to(producerBuilder::compressionType);
        propertyMapper.from(producerProperties::getAccessMode).to(producerBuilder::accessMode);
    }

    <T> void customizeConsumerBuilder(ConsumerBuilder<T> consumerBuilder) {
        PulsarProperties.Consumer consumerProperties = this.properties.getConsumer();
        PropertyMapper propertyMapper = PropertyMapper.get().alwaysApplyingWhenNonNull();
        propertyMapper.from(consumerProperties::getName).to(consumerBuilder::consumerName);
        propertyMapper.from(consumerProperties::getTopics).as(ArrayList::new).to(consumerBuilder::topics);
        propertyMapper.from(consumerProperties::getTopicsPattern).to(consumerBuilder::topicsPattern);
        propertyMapper.from(consumerProperties::getPriorityLevel).to(consumerBuilder::priorityLevel);
        propertyMapper.from(consumerProperties::isReadCompacted).to(consumerBuilder::readCompacted);
        propertyMapper.from(consumerProperties::getDeadLetterPolicy).as(DeadLetterPolicyMapper::map).to(consumerBuilder::deadLetterPolicy);
        propertyMapper.from(consumerProperties::isRetryEnable).to(consumerBuilder::enableRetry);
        customizeConsumerBuilderSubscription(consumerBuilder);
    }

    private void customizeConsumerBuilderSubscription(ConsumerBuilder<?> consumerBuilder) {
        PulsarProperties.Consumer.Subscription subscriptionProperties = this.properties.getConsumer().getSubscription();
        PropertyMapper propertyMapper = PropertyMapper.get().alwaysApplyingWhenNonNull();
        propertyMapper.from(subscriptionProperties::getName).to(consumerBuilder::subscriptionName);
        propertyMapper.from(subscriptionProperties::getInitialPosition).to(consumerBuilder::subscriptionInitialPosition);
        propertyMapper.from(subscriptionProperties::getMode).to(consumerBuilder::subscriptionMode);
        propertyMapper.from(subscriptionProperties::getTopicsMode).to(consumerBuilder::subscriptionTopicsMode);
        propertyMapper.from(subscriptionProperties::getType).to(consumerBuilder::subscriptionType);
    }

    void customizeContainerProperties(PulsarContainerProperties containerProperties) {
        customizePulsarContainerConsumerSubscriptionProperties(containerProperties);
        customizePulsarContainerListenerProperties(containerProperties);
    }

    private void customizePulsarContainerConsumerSubscriptionProperties(PulsarContainerProperties containerProperties) {
        PulsarProperties.Consumer.Subscription subscriptionProperties = this.properties.getConsumer().getSubscription();
        PropertyMapper propertyMapper = PropertyMapper.get().alwaysApplyingWhenNonNull();
        propertyMapper.from(subscriptionProperties::getType).to(containerProperties::setSubscriptionType);
    }

    private void customizePulsarContainerListenerProperties(PulsarContainerProperties containerProperties) {
        PulsarProperties.Listener listenerProperties = this.properties.getListener();
        PropertyMapper propertyMapper = PropertyMapper.get().alwaysApplyingWhenNonNull();
        propertyMapper.from(listenerProperties::getSchemaType).to(containerProperties::setSchemaType);
        propertyMapper.from(listenerProperties::isObservationEnabled).to(containerProperties::setObservationEnabled);
    }

    <T> void customizeReaderBuilder(ReaderBuilder<T> readerBuilder) {
        PulsarProperties.Reader readerProperties = this.properties.getReader();
        PropertyMapper propertyMapper = PropertyMapper.get().alwaysApplyingWhenNonNull();
        propertyMapper.from(readerProperties::getName).to(readerBuilder::readerName);
        propertyMapper.from(readerProperties::getTopics).to(readerBuilder::topics);
        propertyMapper.from(readerProperties::getSubscriptionName).to(readerBuilder::subscriptionName);
        propertyMapper.from(readerProperties::getSubscriptionRolePrefix).to(readerBuilder::subscriptionRolePrefix);
        propertyMapper.from(readerProperties::isReadCompacted).to(readerBuilder::readCompacted);
    }

    void customizeReaderContainerProperties(PulsarReaderContainerProperties readerContainerProperties) {
        PulsarProperties.Reader readerProperties = this.properties.getReader();
        PropertyMapper propertyMapper = PropertyMapper.get().alwaysApplyingWhenNonNull();
        propertyMapper.from(readerProperties::getTopics).to(readerContainerProperties::setTopics);
    }

    private Consumer<Duration> timeoutProperty(BiConsumer<Integer, TimeUnit> setter) {
        return (duration) -> setter.accept((int) duration.toMillis(), TimeUnit.MILLISECONDS);
    }

    private interface AuthenticationConsumer {

        void accept(String authPluginClassName, String authParams) throws UnsupportedAuthenticationException;

    }
}