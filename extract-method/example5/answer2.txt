23-04-2025, 19:55

### Analysis

Yes, there are clear **Extract Method** refactoring opportunities in the provided code. The methods `testDifferentStateTtlForDifferentOneInputOperator()` and `innerTestRegularJoin()` both include repetitive or complex logic blocks that would benefit from extraction to improve readability and maintainability.

#### Candidates for Extraction:

1. **Data Registration:**
   The process of registering data via `TestValuesTableFactory.registerRowData(...)` is repeated and verbose. This can be extracted to methods such as `registerOrdersTableData()` and `registerLineOrdersTableData()`.

2. **Sink Table Creation:**
   Table creation logic (`createTestSourceTable`, `createTestNonInsertOnlyValuesSinkTable`, and `createTestValuesSinkTable`) can also be extracted.

3. **Json Transformation for Test:**
   The JSON transformation lambda is a bit long and can be extracted into methods for clarity.

---

## Refactored Code

```java
package org.apache.flink.table.planner.runtime.stream.jsonplan;

import org.apache.flink.table.api.TableException;
import org.apache.flink.table.data.GenericRowData;
import org.apache.flink.table.data.StringData;
import org.apache.flink.table.planner.factories.TestValuesTableFactory;
import org.apache.flink.table.planner.utils.JsonPlanTestBase;
import org.apache.flink.table.planner.utils.JsonTestUtils;

import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;

import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;

class ConfigureOperatorLevelStateTtlJsonITCase extends JsonPlanTestBase {

    @Test
    void testDifferentStateTtlForDifferentOneInputOperator() throws Exception {
        String dataId = registerOrdersTableData();
        createOrdersTable(dataId);
        createOrdersStatsSinkTable();

        compileSqlAndExecutePlan(
                getOrdersStatsInsertSql(),
                this::deduplicateAndAggregateJsonTransformer)
        .await();

        List<String> expected = Arrays.asList(
                "+I[Tom, 2, 2, 229.8]",
                "+I[Jerry, 1, 2, 99.9]",
                "+I[Jerry, 1, 2, 99.9]",
                "+I[Olivia, 2, 4, 1100.0]",
                "+I[Michael, 1, 3, 599.9]");
        assertResult(expected, TestValuesTableFactory.getResultsAsStrings("OrdersStats"));
    }

    @Test
    void testDifferentStateTtlForSameTwoInputStreamOperator() throws Exception {
        innerTestRegularJoin(
                getOrdersShipInfoJoinSql(),
                this::joinOperatorJsonTransformer);
    }

    @Test
    void testDifferentStateTtlThroughSqlHintForSameTwoInputStreamOperator() throws Exception {
        innerTestRegularJoin(
                getOrdersShipInfoJoinSqlWithHint(),
                json -> json
        );
    }

    private void innerTestRegularJoin(String sql, Function<String, String> jsonPlanTransformer)
            throws Exception {

        String leftTableDataId = registerLeftOrdersTableData();
        createTestSourceTable(
                "Orders",
                new String[] {"`order_id` INT", "`line_order_id` INT"},
                null,
                getProperties(leftTableDataId, 1, "2s"));

        String rightTableDataId = registerLineOrdersTableData();
        createTestSourceTable(
                "LineOrders",
                new String[] {"`line_order_id` INT", "`ship_mode` STRING"},
                null,
                getProperties(rightTableDataId, 2, "4s"));

        createTestValuesSinkTable(
                "OrdersShipInfo", "`order_id` INT", "`line_order_id` INT", "`ship_mode` STRING");
        compileSqlAndExecutePlan(sql, jsonPlanTransformer).await();

        List<String> expected = Arrays.asList(
                "+I[1, 1000002, TRUCK]", "+I[1, 1000004, RAIL]", "+I[1, 1000005, AIR]");
        assertResult(expected, TestValuesTableFactory.getResultsAsStrings("OrdersShipInfo"));
    }

    /** Extracted method for orders table test data registration for one input operator test. */
    private String registerOrdersTableData() {
        return TestValuesTableFactory.registerRowData(
                Arrays.asList(
                        GenericRowData.of(1, StringData.fromString("Tom"), 1, 199.9d),
                        GenericRowData.of(2, StringData.fromString("Jerry"), 2, 99.9d),
                        GenericRowData.of(1, StringData.fromString("Tom"), 1, 199.9d),
                        GenericRowData.of(3, StringData.fromString("Tom"), 1, 29.9d),
                        GenericRowData.of(4, StringData.fromString("Olivia"), 1, 100d),
                        GenericRowData.of(4, StringData.fromString("Olivia"), 1, 100d),
                        GenericRowData.of(2, StringData.fromString("Jerry"), 2, 99.9d),
                        GenericRowData.of(5, StringData.fromString("Michael"), 3, 599.9d),
                        GenericRowData.of(6, StringData.fromString("Olivia"), 3, 1000d)));
    }

    /** Extracted method for left orders table test data registration for join tests. */
    private String registerLeftOrdersTableData() {
        return TestValuesTableFactory.registerRowData(
                Arrays.asList(
                        GenericRowData.of(1, 1000001),
                        GenericRowData.of(1, 1000002),
                        GenericRowData.of(1, 1000003),
                        GenericRowData.of(1, 1000004),
                        GenericRowData.of(1, 1000005),
                        GenericRowData.of(2, 2000001)));
    }

    /** Extracted method for right line orders test data registration for join tests. */
    private String registerLineOrdersTableData() {
        return TestValuesTableFactory.registerRowData(
                Arrays.asList(
                        GenericRowData.of(2000001, StringData.fromString("TRUCK")),
                        GenericRowData.of(1000005, StringData.fromString("AIR")),
                        GenericRowData.of(1000001, StringData.fromString("SHIP")),
                        GenericRowData.of(1000002, StringData.fromString("TRUCK")),
                        GenericRowData.of(1000003, StringData.fromString("RAIL")),
                        GenericRowData.of(1000004, StringData.fromString("RAIL"))));
    }

    /** Extracted method to create the Orders source table. */
    private void createOrdersTable(String dataId) {
        createTestSourceTable(
                "Orders",
                new String[] {
                        "`order_id` INT", "`buyer` STRING", "`quantity` INT", "`amount` DOUBLE"
                },
                null,
                getProperties(dataId, 1, "2s"));
    }

    /** Extracted method to create the OrdersStats sink table. */
    private void createOrdersStatsSinkTable() {
        createTestNonInsertOnlyValuesSinkTable(
                "OrdersStats",
                "`buyer` STRING",
                "`ord_cnt` BIGINT",
                "`quantity_cnt` BIGINT",
                "`total_amount` DOUBLE");
    }

    /** Extracted method supplying the SQL for OrdersStats insertion. */
    private String getOrdersStatsInsertSql() {
        return "INSERT INTO OrdersStats \n"
                + "SELECT buyer, COUNT(1) AS ord_cnt, SUM(quantity) AS quantity_cnt, SUM(amount) AS total_amount FROM (\n"
                + "SELECT *, ROW_NUMBER() OVER(PARTITION BY order_id, buyer, quantity, amount ORDER BY proctime() ASC) AS rk FROM Orders) tmp\n"
                + "WHERE rk = 1\n"
                + "GROUP BY buyer";
    }

    /** Extracted method for join SQL string without hint. */
    private String getOrdersShipInfoJoinSql() {
        return "INSERT INTO OrdersShipInfo \n"
                + "SELECT a.order_id, a.line_order_id, b.ship_mode FROM Orders a JOIN LineOrders b ON a.line_order_id = b.line_order_id";
    }

    /** Extracted method for join SQL string with hint. */
    private String getOrdersShipInfoJoinSqlWithHint() {
        return "INSERT INTO OrdersShipInfo \n"
                + "SELECT /*+ STATE_TTL('a' = '3s', 'b' = '9s') */\n"
                + " a.order_id, a.line_order_id, b.ship_mode "
                + "FROM Orders a JOIN LineOrders b ON a.line_order_id = b.line_order_id";
    }

    /** Extracted method for OrdersStats plan JSON transformation. */
    private String deduplicateAndAggregateJsonTransformer(String json) {
        try {
            JsonNode target = JsonTestUtils.readFromString(json);
            JsonTestUtils.setExecNodeStateMetadata(
                    target, "stream-exec-deduplicate", 0, 6000L);
            JsonTestUtils.setExecNodeStateMetadata(
                    target, "stream-exec-group-aggregate", 0, 9000L);
            return JsonTestUtils.writeToString(target);
        } catch (IOException e) {
            throw new TableException("Cannot modify compiled json plan.", e);
        }
    }

    /** Extracted method for join operator plan JSON transformation. */
    private String joinOperatorJsonTransformer(String json) {
        try {
            JsonNode target = JsonTestUtils.readFromString(json);
            JsonTestUtils.setExecNodeStateMetadata(
                    target, "stream-exec-join", 0, 3000L);
            JsonTestUtils.setExecNodeStateMetadata(
                    target, "stream-exec-join", 1, 9000L);
            return JsonTestUtils.writeToString(target);
        } catch (IOException e) {
            throw new TableException("Cannot modify compiled json plan.", e);
        }
    }

    private static Map<String, String> getProperties(
            String dataId, int sleepAfterElements, String sleepTime) {
        return new HashMap<String, String>() {
            {
                put("connector", "values");
                put("bounded", "false");
                put("register-internal-data", "true");
                put("source.sleep-after-elements", String.valueOf(sleepAfterElements));
                put("source.sleep-time", sleepTime);
                put("data-id", dataId);
            }
        };
    }
}
```

---

### **Summary of Refactorings**

- **Method Extractions:**
  - Data registration for tables (`registerOrdersTableData`, `registerLeftOrdersTableData`, `registerLineOrdersTableData`)
  - Table creation logic (`createOrdersTable`, `createOrdersStatsSinkTable`)
  - SQL provision (`getOrdersStatsInsertSql`, `getOrdersShipInfoJoinSql`, `getOrdersShipInfoJoinSqlWithHint`)
  - JSON transformation functions (`deduplicateAndAggregateJsonTransformer`, `joinOperatorJsonTransformer`)

- **Benefits:**
  - Improved **readability** and **maintainability**
  - Clear separation of *setup*, *execution*, and *result assertion* in tests

---

**If you want further decompositions or extractions (for example, further splitting the test logic), let me know!**