02-05-2025, 08:44

Certainly! Below is a review focusing on **attribute (field) names** that could benefit from **Rename Attribute Refactoring** for improved readability and alignment with Java naming conventions.

## Identified Refactoring Opportunities

### 1. Field Naming: `customImportOrderRules`
- **Current**: `private static final String customImportOrderRules = "";`
- **Problem**: It appears to be an instance configuration, but is both `static` and named as a plural "Rules" when it's a `String`. However, it's only used in one `if` for equality checking and not updated elsewhere.
- **Suggested Rename**: If kept as a static config, `EMPTY_CUSTOM_IMPORT_ORDER_RULES` would be more appropriate (since it's always `""`), but this field is essentially redundant because it's always blank and only for equality checking against an input.
- **Suggested Action**: Remove this field and replace usage in `setCustomImportOrderRules` with a direct check on the input String.

### 2. Field Naming: `customOrderRules`
- **Current**: `private final List<String> customOrderRules = new ArrayList<>();`
- **Problem**: Acceptable but could be more explicit as `importOrderRuleList` or `importOrderRules`.
- **Action**: Optional, but not critical; fairly clear.

### 3. Field Naming: `importToGroupList`
- **Current**: `private final List<ImportDetails> importToGroupList = new ArrayList<>();`
- **Problem**: The name is awkward; it’s a list of ImportDetails, not a "toGroupList".
- **Suggested Rename**: `importDetailsList`

### 4. Field Naming: `samePackageDomainsRegExp`
- **Current**: `private String samePackageDomainsRegExp`
- **Problem**: Not a RegExp but a string holding the package prefix.
- **Suggested Rename**: `samePackageDomainPrefix` or `samePackagePrefix`

### 5. Field Naming: `standardPackageRegExp`, `thirdPartyPackageRegExp`, `specialImportsRegExp`
- **Current**:
  - `standardPackageRegExp`
  - `thirdPartyPackageRegExp`
  - `specialImportsRegExp`
- **Problem**: "RegExp" is non-idiomatic in Java, "Pattern" is more standard. The suffix "Pattern" is preferred.
- **Suggested Rename**:
  - `standardPackagePattern`
  - `thirdPartyPackagePattern`
  - `specialImportsPattern`

### 6. Method/Parameter: Some parameters use names like `regexp` when passing a Pattern, should be `pattern`.

---

## Refactored Code

**Below is your class with the clarified field names and the `customImportOrderRules` field removed (checked directly against the empty string in the setter).**

```java
package com.puppycrawl.tools.checkstyle.checks.imports;

import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.puppycrawl.tools.checkstyle.FileStatefulCheck;
import com.puppycrawl.tools.checkstyle.api.AbstractCheck;
import com.puppycrawl.tools.checkstyle.api.DetailAST;
import com.puppycrawl.tools.checkstyle.api.FullIdent;
import com.puppycrawl.tools.checkstyle.api.TokenTypes;
import com.puppycrawl.tools.checkstyle.utils.CommonUtil;

@FileStatefulCheck
public class CustomImportOrderCheck extends AbstractCheck {

    public static final String MSG_LINE_SEPARATOR = "custom.import.order.line.separator";
    public static final String MSG_SEPARATED_IN_GROUP = "custom.import.order.separated.internally";
    public static final String MSG_LEX = "custom.import.order.lex";
    public static final String MSG_NONGROUP_IMPORT = "custom.import.order.nonGroup.import";
    public static final String MSG_NONGROUP_EXPECTED = "custom.import.order.nonGroup.expected";
    public static final String MSG_ORDER = "custom.import.order";

    public static final String STATIC_RULE_GROUP = "STATIC";
    public static final String SAME_PACKAGE_RULE_GROUP = "SAME_PACKAGE";
    public static final String THIRD_PARTY_PACKAGE_RULE_GROUP = "THIRD_PARTY_PACKAGE";
    public static final String STANDARD_JAVA_PACKAGE_RULE_GROUP = "STANDARD_JAVA_PACKAGE";
    public static final String SPECIAL_IMPORTS_RULE_GROUP = "SPECIAL_IMPORTS";
    private static final String NON_GROUP_RULE_GROUP = "NOT_ASSIGNED_TO_ANY_GROUP";

    private static final Pattern GROUP_SEPARATOR_PATTERN = Pattern.compile("\\s*###\\s*");

    /** Processed list of import order rules. */
    private final List<String> importOrderRules = new ArrayList<>();

    /** Contains objects with import attributes. */
    private final List<ImportDetails> importDetailsList = new ArrayList<>();

    /** The same package prefix (domain) as a String for matching. */
    private String samePackageDomainPrefix = "";

    /** Specify Pattern for STANDARD_JAVA_PACKAGE group imports. */
    private Pattern standardPackagePattern = Pattern.compile("^(java|javax)\\.");

    /** Specify Pattern for THIRD_PARTY_PACKAGE group imports. */
    private Pattern thirdPartyPackagePattern = Pattern.compile(".*");

    /** Specify Pattern for SPECIAL_IMPORTS group imports. */
    private Pattern specialImportsPattern = Pattern.compile("^$");

    /** Force empty line separator between import groups. */
    private boolean separateLineBetweenGroups = true;

    private boolean sortImportsInGroupAlphabetically;

    private int samePackageMatchingDepth = 2;

    public final void setStandardPackagePattern(Pattern pattern) {
        standardPackagePattern = pattern;
    }

    public final void setThirdPartyPackagePattern(Pattern pattern) {
        thirdPartyPackagePattern = pattern;
    }

    public final void setSpecialImportsPattern(Pattern pattern) {
        specialImportsPattern = pattern;
    }

    public final void setSeparateLineBetweenGroups(boolean value) {
        separateLineBetweenGroups = value;
    }

    public final void setSortImportsInGroupAlphabetically(boolean value) {
        sortImportsInGroupAlphabetically = value;
    }

    public final void setCustomImportOrderRules(final String inputCustomImportOrder) {
        if (!"".equals(inputCustomOrder)) {
            for (String currentState : GROUP_SEPARATOR_PATTERN.split(inputCustomOrder)) {
                addRulesToList(currentState);
            }
            importOrderRules.add(NON_GROUP_RULE_GROUP);
        }
    }

    @Override
    public int[] getDefaultTokens() {
        return getRequiredTokens();
    }

    @Override
    public int[] getAcceptableTokens() {
        return getRequiredTokens();
    }

    @Override
    public int[] getRequiredTokens() {
        return new int[] {
                TokenTypes.IMPORT,
                TokenTypes.STATIC_IMPORT,
                TokenTypes.PACKAGE_DEF,
        };
    }

    @Override
    public void beginTree(DetailAST rootAST) {
        importDetailsList.clear();
    }

    @Override
    public void visitToken(DetailAST ast) {
        if (ast.getType() == TokenTypes.PACKAGE_DEF) {
            samePackageDomainPrefix = createSamePackagePrefix(
                    samePackageMatchingDepth, ast);
        } else {
            final String importFullPath = getFullImportIdent(ast);
            final boolean isStatic = ast.getType() == TokenTypes.STATIC_IMPORT;
            importDetailsList.add(new ImportDetails(importFullPath,
                    getImportGroup(isStatic, importFullPath), isStatic, ast));
        }
    }

    @Override
    public void finishTree(DetailAST rootAST) {
        if (!importDetailsList.isEmpty()) {
            finishImportList();
        }
    }

    private void finishImportList() {
        String currentGroup = getFirstGroup();
        int currentGroupNumber = importOrderRules.lastIndexOf(currentGroup);
        ImportDetails previousImportObjectFromCurrentGroup = null;
        String previousImportFromCurrentGroup = null;

        for (ImportDetails importObject : importDetailsList) {
            final String importGroup = importObject.getImportGroup();
            final String fullImportIdent = importObject.getImportFullPath();

            if (importGroup.equals(currentGroup)) {
                validateExtraEmptyLine(previousImportObjectFromCurrentGroup,
                        importObject, fullImportIdent);
                if (isAlphabeticalOrderBroken(previousImportFromCurrentGroup, fullImportIdent)) {
                    log(importObject.getImportAST(), MSG_LEX,
                            fullImportIdent, previousImportFromCurrentGroup);
                } else {
                    previousImportFromCurrentGroup = fullImportIdent;
                }
                previousImportObjectFromCurrentGroup = importObject;
            } else {
                // not the last group, last one is always NON_GROUP
                if (importOrderRules.size() > currentGroupNumber + 1) {
                    final String nextGroup = getNextImportGroup(currentGroupNumber + 1);
                    if (importGroup.equals(nextGroup)) {
                        validateMissedEmptyLine(previousImportObjectFromCurrentGroup,
                                importObject, fullImportIdent);
                        currentGroup = nextGroup;
                        currentGroupNumber = importOrderRules.lastIndexOf(nextGroup);
                        previousImportFromCurrentGroup = fullImportIdent;
                    } else {
                        logWrongImportGroupOrder(importObject.getImportAST(),
                                importGroup, nextGroup, fullImportIdent);
                    }
                    previousImportObjectFromCurrentGroup = importObject;
                } else {
                    logWrongImportGroupOrder(importObject.getImportAST(),
                            importGroup, currentGroup, fullImportIdent);
                }
            }
        }
    }

    private void validateMissedEmptyLine(ImportDetails previousImport,
                                         ImportDetails importObject, String fullImportIdent) {
        if (isEmptyLineMissed(previousImport, importObject)) {
            log(importObject.getImportAST(), MSG_LINE_SEPARATOR, fullImportIdent);
        }
    }

    private void validateExtraEmptyLine(ImportDetails previousImport,
                                        ImportDetails importObject, String fullImportIdent) {
        if (isSeparatedByExtraEmptyLine(previousImport, importObject)) {
            log(importObject.getImportAST(), MSG_SEPARATED_IN_GROUP, fullImportIdent);
        }
    }

    private String getFirstGroup() {
        final ImportDetails firstImport = importDetailsList.get(0);
        return getImportGroup(firstImport.isStaticImport(),
                firstImport.getImportFullPath());
    }

    private boolean isAlphabeticalOrderBroken(String previousImport,
                                              String currentImport) {
        return sortImportsInGroupAlphabetically
                && previousImport != null
                && compareImports(currentImport, previousImport) < 0;
    }

    private boolean isEmptyLineMissed(ImportDetails previousImportObject,
                                      ImportDetails currentImportObject) {
        return separateLineBetweenGroups
                && getCountOfEmptyLinesBetween(
                previousImportObject.getEndLineNumber(),
                currentImportObject.getStartLineNumber()) != 1;
    }

    private boolean isSeparatedByExtraEmptyLine(ImportDetails previousImportObject,
                                                ImportDetails currentImportObject) {
        return previousImportObject != null
                && getCountOfEmptyLinesBetween(
                previousImportObject.getEndLineNumber(),
                currentImportObject.getStartLineNumber()) > 0;
    }

    private void logWrongImportGroupOrder(DetailAST importAST, String importGroup,
                                          String currentGroupNumber, String fullImportIdent) {
        if (NON_GROUP_RULE_GROUP.equals(importGroup)) {
            log(importAST, MSG_NONGROUP_IMPORT, fullImportIdent);
        } else if (NON_GROUP_RULE_GROUP.equals(currentGroupNumber)) {
            log(importAST, MSG_NONGROUP_EXPECTED, importGroup, fullImportIdent);
        } else {
            log(importAST, MSG_ORDER, importGroup, currentGroupNumber, fullImportIdent);
        }
    }

    private String getNextImportGroup(int currentGroupNumber) {
        int nextGroupNumber = currentGroupNumber;

        while (importOrderRules.size() > nextGroupNumber + 1) {
            if (hasAnyImportInCurrentGroup(importOrderRules.get(nextGroupNumber))) {
                break;
            }
            nextGroupNumber++;
        }
        return importOrderRules.get(nextGroupNumber);
    }

    private boolean hasAnyImportInCurrentGroup(String currentGroup) {
        boolean result = false;
        for (ImportDetails currentImport : importDetailsList) {
            if (currentGroup.equals(currentImport.getImportGroup())) {
                result = true;
                break;
            }
        }
        return result;
    }

    private String getImportGroup(boolean isStatic, String importPath) {
        RuleMatchForImport bestMatch = new RuleMatchForImport(NON_GROUP_RULE_GROUP, 0, 0);
        if (isStatic && importOrderRules.contains(STATIC_RULE_GROUP)) {
            bestMatch.group = STATIC_RULE_GROUP;
            bestMatch.matchLength = importPath.length();
        } else if (importOrderRules.contains(SAME_PACKAGE_RULE_GROUP)) {
            final String importPathTrimmedToSamePackageDepth =
                    getFirstDomainsFromIdent(samePackageMatchingDepth, importPath);
            if (samePackageDomainPrefix.equals(importPathTrimmedToSamePackageDepth)) {
                bestMatch.group = SAME_PACKAGE_RULE_GROUP;
                bestMatch.matchLength = importPath.length();
            }
        }
        for (String group : importOrderRules) {
            if (STANDARD_JAVA_PACKAGE_RULE_GROUP.equals(group)) {
                bestMatch = findBetterPatternMatch(importPath,
                        STANDARD_JAVA_PACKAGE_RULE_GROUP, standardPackagePattern, bestMatch);
            }
            if (SPECIAL_IMPORTS_RULE_GROUP.equals(group)) {
                bestMatch = findBetterPatternMatch(importPath,
                        group, specialImportsPattern, bestMatch);
            }
        }

        if (NON_GROUP_RULE_GROUP.equals(bestMatch.group)
                && importOrderRules.contains(THIRD_PARTY_PACKAGE_RULE_GROUP)
                && thirdPartyPackagePattern.matcher(importPath).find()) {
            bestMatch.group = THIRD_PARTY_PACKAGE_RULE_GROUP;
        }
        return bestMatch.group;
    }

    private static RuleMatchForImport findBetterPatternMatch(String importPath, String group,
                                                             Pattern pattern, RuleMatchForImport currentBestMatch) {
        RuleMatchForImport betterMatchCandidate = currentBestMatch;
        final Matcher matcher = pattern.matcher(importPath);
        while (matcher.find()) {
            final int matchStart = matcher.start();
            final int length = matcher.end() - matchStart;
            if (length > betterMatchCandidate.matchLength
                    || length == betterMatchCandidate.matchLength
                    && matchStart < betterMatchCandidate.matchPosition) {
                betterMatchCandidate = new RuleMatchForImport(group, length, matchStart);
            }
        }
        return betterMatchCandidate;
    }

    private static int compareImports(String import1, String import2) {
        int result = 0;
        final String separator = "\\.";
        final String[] import1Tokens = import1.split(separator);
        final String[] import2Tokens = import2.split(separator);
        for (int i = 0; i != import1Tokens.length && i != import2Tokens.length; i++) {
            final String import1Token = import1Tokens[i];
            final String import2Token = import2Tokens[i];
            result = import1Token.compareTo(import2Token);
            if (result != 0) {
                break;
            }
        }
        if (result == 0) {
            result = Integer.compare(import1Tokens.length, import2Tokens.length);
        }
        return result;
    }

    private int getCountOfEmptyLinesBetween(int fromLineNo, int toLineNo) {
        int result = 0;
        final String[] lines = getLines();

        for (int i = fromLineNo + 1; i <= toLineNo - 1; i++) {
            // "- 1" because the numbering is one-based
            if (CommonUtil.isBlank(lines[i - 1])) {
                result++;
            }
        }
        return result;
    }

    private static String getFullImportIdent(DetailAST token) {
        String ident = "";
        if (token != null) {
            ident = FullIdent.createFullIdent(token.findFirstToken(TokenTypes.DOT)).getText();
        }
        return ident;
    }

    private void addRulesToList(String ruleStr) {
        if (STATIC_RULE_GROUP.equals(ruleStr)
                || THIRD_PARTY_PACKAGE_RULE_GROUP.equals(ruleStr)
                || STANDARD_JAVA_PACKAGE_RULE_GROUP.equals(ruleStr)
                || SPECIAL_IMPORTS_RULE_GROUP.equals(ruleStr)) {
            importOrderRules.add(ruleStr);
        } else if (ruleStr.startsWith(SAME_PACKAGE_RULE_GROUP)) {
            final String rule = ruleStr.substring(ruleStr.indexOf('(') + 1,
                    ruleStr.indexOf(')'));
            samePackageMatchingDepth = Integer.parseInt(rule);
            if (samePackageMatchingDepth <= 0) {
                throw new IllegalArgumentException(
                        "SAME_PACKAGE rule parameter should be positive integer: " + ruleStr);
            }
            importOrderRules.add(SAME_PACKAGE_RULE_GROUP);
        } else {
            throw new IllegalStateException("Unexpected rule: " + ruleStr);
        }
    }

    private static String createSamePackagePrefix(int firstPackageDomainsCount,
                                                  DetailAST packageNode) {
        final String packageFullPath = getFullImportIdent(packageNode);
        return getFirstDomainsFromIdent(firstPackageDomainsCount, packageFullPath);
    }

    private static String getFirstDomainsFromIdent(
            final int firstPackageDomainsCount, final String packageFullPath) {
        final StringBuilder builder = new StringBuilder(256);
        final StringTokenizer tokens = new StringTokenizer(packageFullPath, ".");
        int count = firstPackageDomainsCount;

        while (count > 0 && tokens.hasMoreTokens()) {
            builder.append(tokens.nextToken()).append('.');
            count--;
        }
        return builder.toString();
    }

    private static final class ImportDetails {

        private final String importFullPath;
        private final String importGroup;
        private final boolean staticImport;
        private final DetailAST importAST;

        private ImportDetails(String importFullPath, String importGroup, boolean staticImport,
                              DetailAST importAST) {
            this.importFullPath = importFullPath;
            this.importGroup = importGroup;
            this.staticImport = staticImport;
            this.importAST = importAST;
        }

        public String getImportFullPath() {
            return importFullPath;
        }

        public int getStartLineNumber() {
            return importAST.getLineNo();
        }

        public int getEndLineNumber() {
            return importAST.getLastChild().getLineNo();
        }

        public String getImportGroup() {
            return importGroup;
        }

        public boolean isStaticImport() {
            return staticImport;
        }

        public DetailAST getImportAST() {
            return importAST;
        }
    }

    private static final class RuleMatchForImport {

        private final int matchPosition;
        private int matchLength;
        private String group;

        private RuleMatchForImport(String group, int length, int position) {
            this.group = group;
            matchLength = length;
            matchPosition = position;
        }
    }
}
```

---

## Summary of Main Changes
- Removed the `customImportOrderRules` static field.
- Renamed fields to more expressive, Java-idiomatic names:
    - `customOrderRules` → `importOrderRules`
    - `importToGroupList` → `importDetailsList`
    - `samePackageDomainsRegExp` → `samePackageDomainPrefix`
    - `standardPackageRegExp` → `standardPackagePattern`
    - `thirdPartyPackageRegExp` → `thirdPartyPackagePattern`
    - `specialImportsRegExp` → `specialImportsPattern`
- Changed method and variable parameter names for consistency.

---

**This improves clarity, maintainability, and adherence to Java best practices.**
