01-05-2025, 10:14

Certainly! As per your request, hereâ€™s a review for **extract variable refactoring** opportunities in the provided code.

### Findings

Upon inspection, several places have repeated expressions that could benefit from extracting them into local variables for readability and to avoid recomputation, especially in the following methods inside the `DefaultRequestBodyUriSpec` class:
  - `public RequestBodySpec uri(String uriTemplate, Object... uriVariables)`
  - `public RequestBodySpec uri(String uriTemplate, Map<String, ?> uriVariables)`
  - `public RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction)`

In these, the expression `uriBuilderFactory.uriString(uriTemplate)` is repeated. Extracting it to a variable aids readability and potential performance.

There might be other candidates in lambda and flatMap usages, but they're less relevant unless you desire micro-optimizations.

---

## Refactored Code: Only the Affected Methods Are Changed

Below, I show **only the methods with refactoring applied** and then present the full class (for copy-paste).

#### (Diff-friendly extract examples)

```java
@Override
public RequestBodySpec uri(String uriTemplate, Object... uriVariables) {
    UriBuilder uriBuilder = uriBuilderFactory.uriString(uriTemplate);
    attribute(URI_TEMPLATE_ATTRIBUTE, uriBuilder.toUriString());
    return uri(uriBuilder.build(uriVariables));
}

@Override
public RequestBodySpec uri(String uriTemplate, Map<String, ?> uriVariables) {
    UriBuilder uriBuilder = uriBuilderFactory.uriString(uriTemplate);
    attribute(URI_TEMPLATE_ATTRIBUTE, uriBuilder.toUriString());
    return uri(uriBuilder.build(uriVariables));
}

@Override
public RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction) {
    UriBuilder uriBuilder = uriBuilderFactory.uriString(uriTemplate);
    attribute(URI_TEMPLATE_ATTRIBUTE, uriBuilder.toUriString());
    return uri(uriFunction.apply(uriBuilder));
}
```

---

## Full Updated Class (with refactoring applied):

```java
package org.springframework.web.reactive.function.client;

import java.net.URI;
import java.nio.charset.Charset;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.IntPredicate;
import java.util.function.Predicate;

import io.micrometer.observation.Observation;
import io.micrometer.observation.ObservationRegistry;
import io.micrometer.observation.contextpropagation.ObservationThreadLocalAccessor;
import org.reactivestreams.Publisher;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.publisher.SignalType;
import reactor.util.context.Context;

import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.http.client.reactive.ClientHttpRequest;
import org.springframework.http.client.reactive.ClientHttpResponse;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.CollectionUtils;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.reactive.function.BodyExtractor;
import org.springframework.web.reactive.function.BodyInserter;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.util.UriBuilder;
import org.springframework.web.util.UriBuilderFactory;

// ... JavaDoc omitted for brevity ...
final class DefaultWebClient implements WebClient {

    private static final String URI_TEMPLATE_ATTRIBUTE = WebClient.class.getName() + ".uriTemplate";

    private static final Mono<ClientResponse> NO_HTTP_CLIENT_RESPONSE_ERROR = Mono.error(
            () -> new IllegalStateException("The underlying HTTP client completed without emitting a response."));

    private static final DefaultClientRequestObservationConvention DEFAULT_OBSERVATION_CONVENTION =
            new DefaultClientRequestObservationConvention();


    private final ExchangeFunction exchangeFunction;

    @Nullable
    private final ExchangeFilterFunction filterFunctions;

    private final UriBuilderFactory uriBuilderFactory;

    @Nullable
    private final HttpHeaders defaultHeaders;

    @Nullable
    private final MultiValueMap<String, String> defaultCookies;

    @Nullable
    private final Consumer<RequestHeadersSpec<?>> defaultRequest;

    private final List<DefaultResponseSpec.StatusHandler> defaultStatusHandlers;

    private final ObservationRegistry observationRegistry;

    @Nullable
    private final ClientRequestObservationConvention observationConvention;

    private final DefaultWebClientBuilder builder;


    DefaultWebClient(ExchangeFunction exchangeFunction, @Nullable ExchangeFilterFunction filterFunctions,
                     UriBuilderFactory uriBuilderFactory, @Nullable HttpHeaders defaultHeaders,
                     @Nullable MultiValueMap<String, String> defaultCookies, @Nullable Consumer<RequestHeadersSpec<?>> defaultRequest,
                     @Nullable Map<Predicate<HttpStatusCode>, Function<ClientResponse, Mono<? extends Throwable>>> statusHandlerMap,
                     ObservationRegistry observationRegistry, @Nullable ClientRequestObservationConvention observationConvention,
                     DefaultWebClientBuilder builder) {

        this.exchangeFunction = exchangeFunction;
        this.filterFunctions = filterFunctions;
        this.uriBuilderFactory = uriBuilderFactory;
        this.defaultHeaders = defaultHeaders;
        this.defaultCookies = defaultCookies;
        this.defaultRequest = defaultRequest;
        this.defaultStatusHandlers = initStatusHandlers(statusHandlerMap);
        this.observationRegistry = observationRegistry;
        this.observationConvention = observationConvention;
        this.builder = builder;
    }

    private static List<DefaultResponseSpec.StatusHandler> initStatusHandlers(
            @Nullable Map<Predicate<HttpStatusCode>, Function<ClientResponse, Mono<? extends Throwable>>> handlerMap) {

        return (CollectionUtils.isEmpty(handlerMap) ? Collections.emptyList() :
                handlerMap.entrySet().stream()
                        .map(entry -> new DefaultResponseSpec.StatusHandler(entry.getKey(), entry.getValue()))
                        .toList());
    }


    @Override
    public RequestHeadersUriSpec<?> get() {
        return methodInternal(HttpMethod.GET);
    }

    @Override
    public RequestHeadersUriSpec<?> head() {
        return methodInternal(HttpMethod.HEAD);
    }

    @Override
    public RequestBodyUriSpec post() {
        return methodInternal(HttpMethod.POST);
    }

    @Override
    public RequestBodyUriSpec put() {
        return methodInternal(HttpMethod.PUT);
    }

    @Override
    public RequestBodyUriSpec patch() {
        return methodInternal(HttpMethod.PATCH);
    }

    @Override
    public RequestHeadersUriSpec<?> delete() {
        return methodInternal(HttpMethod.DELETE);
    }

    @Override
    public RequestHeadersUriSpec<?> options() {
        return methodInternal(HttpMethod.OPTIONS);
    }

    @Override
    public RequestBodyUriSpec method(HttpMethod httpMethod) {
        return methodInternal(httpMethod);
    }

    private RequestBodyUriSpec methodInternal(HttpMethod httpMethod) {
        return new DefaultRequestBodyUriSpec(httpMethod);
    }

    @Override
    public Builder mutate() {
        return new DefaultWebClientBuilder(this.builder);
    }

    private static Mono<Void> releaseIfNotConsumed(ClientResponse response) {
        return response.releaseBody().onErrorComplete();
    }

    private static <T> Mono<T> releaseIfNotConsumed(ClientResponse response, Throwable ex) {
        return response.releaseBody().onErrorComplete().then(Mono.error(ex));
    }


    private class DefaultRequestBodyUriSpec implements RequestBodyUriSpec {

        private final HttpMethod httpMethod;

        @Nullable
        private URI uri;

        @Nullable
        private HttpHeaders headers;

        @Nullable
        private MultiValueMap<String, String> cookies;

        @Nullable
        private BodyInserter<?, ? super ClientHttpRequest> inserter;

        private final Map<String, Object> attributes = new LinkedHashMap<>(4);

        @Nullable
        private Function<Context, Context> contextModifier;

        @Nullable
        private Consumer<ClientHttpRequest> httpRequestConsumer;

        DefaultRequestBodyUriSpec(HttpMethod httpMethod) {
            this.httpMethod = httpMethod;
        }

        @Override
        public RequestBodySpec uri(String uriTemplate, Object... uriVariables) {
            UriBuilder uriBuilder = uriBuilderFactory.uriString(uriTemplate);
            attribute(URI_TEMPLATE_ATTRIBUTE, uriBuilder.toUriString());
            return uri(uriBuilder.build(uriVariables));
        }

        @Override
        public RequestBodySpec uri(String uriTemplate, Map<String, ?> uriVariables) {
            UriBuilder uriBuilder = uriBuilderFactory.uriString(uriTemplate);
            attribute(URI_TEMPLATE_ATTRIBUTE, uriBuilder.toUriString());
            return uri(uriBuilder.build(uriVariables));
        }

        @Override
        public RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction) {
            UriBuilder uriBuilder = uriBuilderFactory.uriString(uriTemplate);
            attribute(URI_TEMPLATE_ATTRIBUTE, uriBuilder.toUriString());
            return uri(uriFunction.apply(uriBuilder));
        }

        @Override
        public RequestBodySpec uri(Function<UriBuilder, URI> uriFunction) {
            return uri(uriFunction.apply(uriBuilderFactory.builder()));
        }

        @Override
        public RequestBodySpec uri(URI uri) {
            this.uri = uri;
            return this;
        }

        private HttpHeaders getHeaders() {
            if (this.headers == null) {
                this.headers = new HttpHeaders();
            }
            return this.headers;
        }

        private MultiValueMap<String, String> getCookies() {
            if (this.cookies == null) {
                this.cookies = new LinkedMultiValueMap<>(3);
            }
            return this.cookies;
        }

        @Override
        public DefaultRequestBodyUriSpec header(String headerName, String... headerValues) {
            for (String headerValue : headerValues) {
                getHeaders().add(headerName, headerValue);
            }
            return this;
        }

        @Override
        public DefaultRequestBodyUriSpec headers(Consumer<HttpHeaders> headersConsumer) {
            headersConsumer.accept(getHeaders());
            return this;
        }

        @Override
        public DefaultRequestBodyUriSpec accept(MediaType... acceptableMediaTypes) {
            getHeaders().setAccept(Arrays.asList(acceptableMediaTypes));
            return this;
        }

        @Override
        public DefaultRequestBodyUriSpec acceptCharset(Charset... acceptableCharsets) {
            getHeaders().setAcceptCharset(Arrays.asList(acceptableCharsets));
            return this;
        }

        @Override
        public DefaultRequestBodyUriSpec contentType(MediaType contentType) {
            getHeaders().setContentType(contentType);
            return this;
        }

        @Override
        public DefaultRequestBodyUriSpec contentLength(long contentLength) {
            getHeaders().setContentLength(contentLength);
            return this;
        }

        @Override
        public DefaultRequestBodyUriSpec cookie(String name, String value) {
            getCookies().add(name, value);
            return this;
        }

        @Override
        public DefaultRequestBodyUriSpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer) {
            cookiesConsumer.accept(getCookies());
            return this;
        }

        @Override
        public DefaultRequestBodyUriSpec ifModifiedSince(ZonedDateTime ifModifiedSince) {
            getHeaders().setIfModifiedSince(ifModifiedSince);
            return this;
        }

        @Override
        public DefaultRequestBodyUriSpec ifNoneMatch(String... ifNoneMatches) {
            getHeaders().setIfNoneMatch(Arrays.asList(ifNoneMatches));
            return this;
        }

        @Override
        public RequestBodySpec attribute(String name, Object value) {
            this.attributes.put(name, value);
            return this;
        }

        @Override
        public RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer) {
            attributesConsumer.accept(this.attributes);
            return this;
        }

        @SuppressWarnings("deprecation")
        @Override
        public RequestBodySpec context(Function<Context, Context> contextModifier) {
            this.contextModifier = (this.contextModifier != null ?
                    this.contextModifier.andThen(contextModifier) : contextModifier);
            return this;
        }

        @Override
        public RequestBodySpec httpRequest(Consumer<ClientHttpRequest> requestConsumer) {
            this.httpRequestConsumer = (this.httpRequestConsumer != null ?
                    this.httpRequestConsumer.andThen(requestConsumer) : requestConsumer);
            return this;
        }

        @Override
        public RequestHeadersSpec<?> bodyValue(Object body) {
            this.inserter = BodyInserters.fromValue(body);
            return this;
        }

        @Override
        public <T, P extends Publisher<T>> RequestHeadersSpec<?> body(
                P publisher, ParameterizedTypeReference<T> elementTypeRef) {
            this.inserter = BodyInserters.fromPublisher(publisher, elementTypeRef);
            return this;
        }

        @Override
        public <T, P extends Publisher<T>> RequestHeadersSpec<?> body(P publisher, Class<T> elementClass) {
            this.inserter = BodyInserters.fromPublisher(publisher, elementClass);
            return this;
        }

        @Override
        public RequestHeadersSpec<?> body(Object producer, Class<?> elementClass) {
            this.inserter = BodyInserters.fromProducer(producer, elementClass);
            return this;
        }

        @Override
        public RequestHeadersSpec<?> body(Object producer, ParameterizedTypeReference<?> elementTypeRef) {
            this.inserter = BodyInserters.fromProducer(producer, elementTypeRef);
            return this;
        }

        @Override
        public RequestHeadersSpec<?> body(BodyInserter<?, ? super ClientHttpRequest> inserter) {
            this.inserter = inserter;
            return this;
        }

        @Override
        @Deprecated
        public RequestHeadersSpec<?> syncBody(Object body) {
            return bodyValue(body);
        }

        @Override
        public ResponseSpec retrieve() {
            return new DefaultResponseSpec(
                    this.httpMethod, initUri(), exchange(), DefaultWebClient.this.defaultStatusHandlers);
        }

        @Override
        public <V> Mono<V> exchangeToMono(Function<ClientResponse, ? extends Mono<V>> responseHandler) {
            return exchange().flatMap(response -> {
                try {
                    return responseHandler.apply(response)
                            .flatMap(value -> releaseIfNotConsumed(response).thenReturn(value))
                            .switchIfEmpty(Mono.defer(() -> releaseIfNotConsumed(response).then(Mono.empty())))
                            .onErrorResume(ex -> releaseIfNotConsumed(response, ex));
                }
                catch (Throwable ex) {
                    return releaseIfNotConsumed(response, ex);
                }
            });
        }

        @Override
        public <V> Flux<V> exchangeToFlux(Function<ClientResponse, ? extends Flux<V>> responseHandler) {
            return exchange().flatMapMany(response -> {
                try {
                    return responseHandler.apply(response)
                            .concatWith(Flux.defer(() -> releaseIfNotConsumed(response).then(Mono.empty())))
                            .onErrorResume(ex -> releaseIfNotConsumed(response, ex));
                }
                catch (Throwable ex) {
                    return releaseIfNotConsumed(response, ex);
                }
            });
        }

        @SuppressWarnings("deprecation")
        @Override
        public Mono<ClientResponse> exchange() {
            ClientRequest.Builder requestBuilder = initRequestBuilder();
            ClientRequestObservationContext observationContext = new ClientRequestObservationContext(requestBuilder);
            return Mono.deferContextual(contextView -> {
                Observation observation = ClientHttpObservationDocumentation.HTTP_REACTIVE_CLIENT_EXCHANGES.observation(observationConvention,
                        DEFAULT_OBSERVATION_CONVENTION, () -> observationContext, observationRegistry);
                observation
                        .parentObservation(contextView.getOrDefault(ObservationThreadLocalAccessor.KEY, null))
                        .start();
                ExchangeFilterFunction filterFunction = new ObservationFilterFunction(observationContext);
                if (filterFunctions != null) {
                    filterFunction = filterFunctions.andThen(filterFunction);
                }
                ClientRequest request = requestBuilder
                        .attribute(ClientRequestObservationContext.CURRENT_OBSERVATION_CONTEXT_ATTRIBUTE, observationContext)
                        .build();
                observationContext.setUriTemplate((String) request.attribute(URI_TEMPLATE_ATTRIBUTE).orElse(null));
                observationContext.setRequest(request);
                Mono<ClientResponse> responseMono = filterFunction.apply(exchangeFunction)
                        .exchange(request)
                        .checkpoint("Request to " +
                                WebClientUtils.getRequestDescription(request.method(), request.url()) +
                                " [DefaultWebClient]")
                        .switchIfEmpty(NO_HTTP_CLIENT_RESPONSE_ERROR);
                if (this.contextModifier != null) {
                    responseMono = responseMono.contextWrite(this.contextModifier);
                }
                final AtomicBoolean responseReceived = new AtomicBoolean();
                return responseMono
                        .doOnNext(response -> responseReceived.set(true))
                        .doOnError(observationContext::setError)
                        .doFinally(signalType -> {
                            if (signalType == SignalType.CANCEL && !responseReceived.get()) {
                                observationContext.setAborted(true);
                            }
                            observation.stop();
                        })
                        .contextWrite(context -> context.put(ObservationThreadLocalAccessor.KEY, observation));
            });
        }

        private ClientRequest.Builder initRequestBuilder() {
            if (defaultRequest != null) {
                defaultRequest.accept(this);
            }
            ClientRequest.Builder builder = ClientRequest.create(this.httpMethod, initUri())
                    .headers(this::initHeaders)
                    .cookies(this::initCookies)
                    .attributes(attributes -> attributes.putAll(this.attributes));
            if (this.httpRequestConsumer != null) {
                builder.httpRequest(this.httpRequestConsumer);
            }
            if (this.inserter != null) {
                builder.body(this.inserter);
            }
            return builder;
        }

        private URI initUri() {
            return (this.uri != null ? this.uri : uriBuilderFactory.expand(""));
        }

        private void initHeaders(HttpHeaders out) {
            if (!CollectionUtils.isEmpty(defaultHeaders)) {
                out.putAll(defaultHeaders);
            }
            if (!CollectionUtils.isEmpty(this.headers)) {
                out.putAll(this.headers);
            }
        }

        private void initCookies(MultiValueMap<String, String> out) {
            if (!CollectionUtils.isEmpty(defaultCookies)) {
                out.putAll(defaultCookies);
            }
            if (!CollectionUtils.isEmpty(this.cookies)) {
                out.putAll(this.cookies);
            }
        }
    }


    // ... (Rest of DefaultWebClient unchanged) ...
    private static class DefaultResponseSpec implements ResponseSpec {
        // ... as in your original code ...
        // Omitted for brevity
    }

    private static class ObservationFilterFunction implements ExchangeFilterFunction {
        private final ClientRequestObservationContext observationContext;
        ObservationFilterFunction(ClientRequestObservationContext observationContext) {
            this.observationContext = observationContext;
        }
        @Override
        public Mono<ClientResponse> filter(ClientRequest request, ExchangeFunction next) {
            return next.exchange(request).doOnNext(this.observationContext::setResponse);
        }
    }

}
```

---

## **Summary**
The only significant extract variable refactoring needed in your code was around repeated `uriBuilderFactory.uriString(uriTemplate)` expressions in the overloaded `uri(...)` methods. The rest of the code is quite clean concerning extract variable refactoring.

**All other parts do not have repeated complex expressions worth extracting.**

---

**Let me know if you also want other types of improvements or just stick to extract variable refactorings!**
