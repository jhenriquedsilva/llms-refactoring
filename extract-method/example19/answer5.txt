26-04-2025, 15:45

Absolutely! The `PulsarPropertiesMapper` code snippet contains typical "property mapping" logic, and the `customize*Builder` methods are quite repetitive—they all follow a common pattern:

- Get some `...Properties` object
- Get a `PropertyMapper`
- Apply a sequence of `map.from(...).to(...)`

**Opportunity**: Most notably, there is a direct opportunity to extract common mapping blocks into private helper methods wherever the logic is repeated (e.g., for `PropertyMapper map = ...` and `map.from(...).to(...)` chains per builder type).

Let’s walk through the refactoring, focusing on **extracting method** for the repeated mapping chains within `customizeProducerBuilder`, `customizeConsumerBuilder`, their subscriptions, and similar for admin/client/reader. Methods containing just a small handful of statements and mappings probably do not need further splitting, but blocks that are more than 3-4 lines may benefit.

Here’s the **refactored code** with extractions for repeated mapping logic:

```java
package org.springframework.boot.autoconfigure.pulsar;

import java.time.Duration;
import java.util.ArrayList;
import java.util.Map;
import java.util.TreeMap;
import java.util.concurrent.TimeUnit;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

import org.apache.pulsar.client.admin.PulsarAdminBuilder;
import org.apache.pulsar.client.api.ClientBuilder;
import org.apache.pulsar.client.api.ConsumerBuilder;
import org.apache.pulsar.client.api.ProducerBuilder;
import org.apache.pulsar.client.api.PulsarClientException.UnsupportedAuthenticationException;
import org.apache.pulsar.client.api.ReaderBuilder;
import org.apache.pulsar.common.util.ObjectMapperFactory;

import org.springframework.boot.context.properties.PropertyMapper;
import org.springframework.pulsar.listener.PulsarContainerProperties;
import org.springframework.pulsar.reader.PulsarReaderContainerProperties;
import org.springframework.util.StringUtils;

/**
 * Helper class used to map {@link PulsarProperties} to various builder customizers.
 *
 * @author Chris Bono
 * @author Phillip Webb
 */
final class PulsarPropertiesMapper {

    private final PulsarProperties properties;

    PulsarPropertiesMapper(PulsarProperties properties) {
        this.properties = properties;
    }

    void customizeClientBuilder(ClientBuilder clientBuilder, PulsarConnectionDetails connectionDetails) {
        PulsarProperties.Client properties = this.properties.getClient();
        PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
        map.from(connectionDetails::getBrokerUrl).to(clientBuilder::serviceUrl);
        map.from(properties::getConnectionTimeout).to(timeoutProperty(clientBuilder::connectionTimeout));
        map.from(properties::getOperationTimeout).to(timeoutProperty(clientBuilder::operationTimeout));
        map.from(properties::getLookupTimeout).to(timeoutProperty(clientBuilder::lookupTimeout));
        customizeAuthentication(clientBuilder::authentication, properties.getAuthentication());
    }

    void customizeAdminBuilder(PulsarAdminBuilder adminBuilder, PulsarConnectionDetails connectionDetails) {
        PulsarProperties.Admin properties = this.properties.getAdmin();
        PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
        map.from(connectionDetails::getAdminUrl).to(adminBuilder::serviceHttpUrl);
        map.from(properties::getConnectionTimeout).to(timeoutProperty(adminBuilder::connectionTimeout));
        map.from(properties::getReadTimeout).to(timeoutProperty(adminBuilder::readTimeout));
        map.from(properties::getRequestTimeout).to(timeoutProperty(adminBuilder::requestTimeout));
        customizeAuthentication(adminBuilder::authentication, properties.getAuthentication());
    }

    private void customizeAuthentication(AuthenticationConsumer authentication,
                                         PulsarProperties.Authentication properties) {
        if (StringUtils.hasText(properties.getPluginClassName())) {
            try {
                String authParamString = getAuthenticationParameterString(properties.getParams());
                authentication.accept(properties.getPluginClassName(), authParamString);
            }
            catch (UnsupportedAuthenticationException ex) {
                throw new IllegalStateException("Unable to configure Pulsar authentication", ex);
            }
        }
    }

    // EXTRACTED method for authentication param processing
    private String getAuthenticationParameterString(Map<String, String> params) {
        try {
            Map<String, String> sortedParams = new TreeMap<>(params);
            return ObjectMapperFactory.create().writeValueAsString(sortedParams);
        }
        catch (Exception ex) {
            throw new IllegalStateException("Could not convert auth parameters to encoded string", ex);
        }
    }

    <T> void customizeProducerBuilder(ProducerBuilder<T> producerBuilder) {
        PulsarProperties.Producer properties = this.properties.getProducer();
        PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
        mapProducerBuilder(map, properties, producerBuilder);
    }

    // EXTRACTED method for common Producer property mapping
    private <T> void mapProducerBuilder(PropertyMapper map, PulsarProperties.Producer properties, ProducerBuilder<T> producerBuilder) {
        map.from(properties::getName).to(producerBuilder::producerName);
        map.from(properties::getTopicName).to(producerBuilder::topic);
        map.from(properties::getSendTimeout).to(timeoutProperty(producerBuilder::sendTimeout));
        map.from(properties::getMessageRoutingMode).to(producerBuilder::messageRoutingMode);
        map.from(properties::getHashingScheme).to(producerBuilder::hashingScheme);
        map.from(properties::isBatchingEnabled).to(producerBuilder::enableBatching);
        map.from(properties::isChunkingEnabled).to(producerBuilder::enableChunking);
        map.from(properties::getCompressionType).to(producerBuilder::compressionType);
        map.from(properties::getAccessMode).to(producerBuilder::accessMode);
    }

    <T> void customizeConsumerBuilder(ConsumerBuilder<T> consumerBuilder) {
        PulsarProperties.Consumer properties = this.properties.getConsumer();
        PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
        mapConsumerBuilder(map, properties, consumerBuilder);
        customizeConsumerBuilderSubscription(consumerBuilder);
    }

    // EXTRACTED method for common Consumer property mapping
    private <T> void mapConsumerBuilder(PropertyMapper map, PulsarProperties.Consumer properties, ConsumerBuilder<T> consumerBuilder) {
        map.from(properties::getName).to(consumerBuilder::consumerName);
        map.from(properties::getTopics).as(ArrayList::new).to(consumerBuilder::topics);
        map.from(properties::getTopicsPattern).to(consumerBuilder::topicsPattern);
        map.from(properties::getPriorityLevel).to(consumerBuilder::priorityLevel);
        map.from(properties::isReadCompacted).to(consumerBuilder::readCompacted);
        map.from(properties::getDeadLetterPolicy).as(DeadLetterPolicyMapper::map).to(consumerBuilder::deadLetterPolicy);
        map.from(properties::isRetryEnable).to(consumerBuilder::enableRetry);
    }

    private void customizeConsumerBuilderSubscription(ConsumerBuilder<?> consumerBuilder) {
        PulsarProperties.Consumer.Subscription properties = this.properties.getConsumer().getSubscription();
        PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
        mapConsumerSubscription(map, properties, consumerBuilder);
    }

    // EXTRACTED method for subscription mapping
    private void mapConsumerSubscription(PropertyMapper map, PulsarProperties.Consumer.Subscription properties, ConsumerBuilder<?> consumerBuilder) {
        map.from(properties::getName).to(consumerBuilder::subscriptionName);
        map.from(properties::getInitialPosition).to(consumerBuilder::subscriptionInitialPosition);
        map.from(properties::getMode).to(consumerBuilder::subscriptionMode);
        map.from(properties::getTopicsMode).to(consumerBuilder::subscriptionTopicsMode);
        map.from(properties::getType).to(consumerBuilder::subscriptionType);
    }

    void customizeContainerProperties(PulsarContainerProperties containerProperties) {
        customizePulsarContainerConsumerSubscriptionProperties(containerProperties);
        customizePulsarContainerListenerProperties(containerProperties);
    }

    private void customizePulsarContainerConsumerSubscriptionProperties(PulsarContainerProperties containerProperties) {
        PulsarProperties.Consumer.Subscription properties = this.properties.getConsumer().getSubscription();
        PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
        mapContainerConsumerSubscription(map, properties, containerProperties);
    }

    // EXTRACTED: container subscription mapping
    private void mapContainerConsumerSubscription(PropertyMapper map, PulsarProperties.Consumer.Subscription properties, PulsarContainerProperties containerProperties) {
        map.from(properties::getType).to(containerProperties::setSubscriptionType);
    }

    private void customizePulsarContainerListenerProperties(PulsarContainerProperties containerProperties) {
        PulsarProperties.Listener properties = this.properties.getListener();
        PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
        mapContainerListener(map, properties, containerProperties);
    }

    // EXTRACTED: container listener mapping
    private void mapContainerListener(PropertyMapper map, PulsarProperties.Listener properties, PulsarContainerProperties containerProperties) {
        map.from(properties::getSchemaType).to(containerProperties::setSchemaType);
        map.from(properties::isObservationEnabled).to(containerProperties::setObservationEnabled);
    }

    <T> void customizeReaderBuilder(ReaderBuilder<T> readerBuilder) {
        PulsarProperties.Reader properties = this.properties.getReader();
        PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
        mapReaderBuilder(map, properties, readerBuilder);
    }

    // EXTRACTED: reader builder mapping
    private <T> void mapReaderBuilder(PropertyMapper map, PulsarProperties.Reader properties, ReaderBuilder<T> readerBuilder) {
        map.from(properties::getName).to(readerBuilder::readerName);
        map.from(properties::getTopics).to(readerBuilder::topics);
        map.from(properties::getSubscriptionName).to(readerBuilder::subscriptionName);
        map.from(properties::getSubscriptionRolePrefix).to(readerBuilder::subscriptionRolePrefix);
        map.from(properties::isReadCompacted).to(readerBuilder::readCompacted);
    }

    void customizeReaderContainerProperties(PulsarReaderContainerProperties readerContainerProperties) {
        PulsarProperties.Reader properties = this.properties.getReader();
        PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
        mapReaderContainerProperties(map, properties, readerContainerProperties);
    }

    // EXTRACTED: reader container property mapping
    private void mapReaderContainerProperties(PropertyMapper map, PulsarProperties.Reader properties, PulsarReaderContainerProperties readerContainerProperties) {
        map.from(properties::getTopics).to(readerContainerProperties::setTopics);
    }

    private Consumer<Duration> timeoutProperty(BiConsumer<Integer, TimeUnit> setter) {
        return (duration) -> setter.accept((int) duration.toMillis(), TimeUnit.MILLISECONDS);
    }

    private interface AuthenticationConsumer {

        void accept(String authPluginClassName, String authParamString) throws UnsupportedAuthenticationException;

    }

}
```

---

## **Summary of Changes**

**Extracted methods:**
- `getAuthenticationParameterString`
- `mapProducerBuilder`
- `mapConsumerBuilder`
- `mapConsumerSubscription`
- `mapContainerConsumerSubscription`
- `mapContainerListener`
- `mapReaderBuilder`
- `mapReaderContainerProperties`

This:
- **Reduces duplication**
- **Improves method readability** by focusing each method on a single responsibility
- **Improves maintainability**—future property additions require changes in one place.

---

**If you'd like more aggressive refactoring (e.g., dynamic property-to-method mappings), please specify.**

Levenshtein edit-distance: 2243
Does not compile
Tests do not pass