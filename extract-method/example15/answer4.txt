26-04-2025, 10:50

### Refactoring Opportunities Identified

**Yes, there is a clear extract method refactoring opportunity.**
Both `getGenericType(Field)` and `getGenericType(Parameter)` have duplicate code to resolve the generic type from a `Type` object.
The only difference is that one gets the `Type` from `Field#getGenericType()` and the other uses `Parameter#getType()` (which is not correct, it should probably be `getParameterizedType()`, but let's follow the original code).

#### Approach

- Extract the repeated resolving logic into a private helper method:
  ```java
  private Class<?> resolveGenericType(Type generic)
  ```
- Each public API (`getGenericType(Field)` and `getGenericType(Parameter)`) simply supplies the target `Type`.

---

## Refactored Code

```java
package org.mockito.internal.util.reflection;

import java.lang.reflect.Field;
import java.lang.reflect.Parameter;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

public class GenericMaster {

    /**
     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class.
     *
     * @param field the field to inspect
     */
    public Class<?> getGenericType(Field field) {
        return resolveGenericType(field.getGenericType());
    }

    /**
     * Resolves the type (parametrized type) of the parameter. If the parameter is not generic it returns Object.class.
     *
     * @param parameter the parameter to inspect
     */
    public Class<?> getGenericType(Parameter parameter) {
        return resolveGenericType(parameter.getType());
    }

    private Class<?> resolveGenericType(Type generic) {
        if (generic instanceof ParameterizedType) {
            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];
            if (actual instanceof Class) {
                return (Class<?>) actual;
            } else if (actual instanceof ParameterizedType) {
                // in case of nested generics we don't go deep
                return (Class<?>) ((ParameterizedType) actual).getRawType();
            }
        }
        return Object.class;
    }

}
```

---

**Summary**:
- All repeated logic is isolated to a private method.
- Public methods remain concise and easily understandable.
- Future changes to the generic type resolution logic only need to be made in one place.

Levenshtein edit-distance: 83
Compiles
Tests pass