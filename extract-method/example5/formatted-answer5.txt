package org.apache.flink.table.planner.runtime.stream.jsonplan;

import org.apache.flink.table.api.TableException;
import org.apache.flink.table.data.GenericRowData;
import org.apache.flink.table.data.StringData;
import org.apache.flink.table.planner.factories.TestValuesTableFactory;
import org.apache.flink.table.planner.utils.JsonPlanTestBase;
import org.apache.flink.table.planner.utils.JsonTestUtils;

import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;

import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;

class ConfigureOperatorLevelStateTtlJsonITCase extends JsonPlanTestBase {

    @Test
    void testDifferentStateTtlForDifferentOneInputOperator() throws Exception {
        String dataId =
                TestValuesTableFactory.registerRowData(
                        Arrays.asList(
                                GenericRowData.of(1, StringData.fromString("Tom"), 1, 199.9d),
                                GenericRowData.of(2, StringData.fromString("Jerry"), 2, 99.9d),
                                GenericRowData.of(1, StringData.fromString("Tom"), 1, 199.9d),
                                GenericRowData.of(3, StringData.fromString("Tom"), 1, 29.9d),
                                GenericRowData.of(4, StringData.fromString("Olivia"), 1, 100d),
                                GenericRowData.of(4, StringData.fromString("Olivia"), 1, 100d),
                                GenericRowData.of(2, StringData.fromString("Jerry"), 2, 99.9d),
                                GenericRowData.of(5, StringData.fromString("Michael"), 3, 599.9d),
                                GenericRowData.of(6, StringData.fromString("Olivia"), 3, 1000d)));

        createOrdersSourceTable(dataId);

        createTestNonInsertOnlyValuesSinkTable(
                "OrdersStats",
                "`buyer` STRING",
                "`ord_cnt` BIGINT",
                "`quantity_cnt` BIGINT",
                "`total_amount` DOUBLE");

        final String sql =
                "INSERT INTO OrdersStats \n"
                        + "SELECT buyer, COUNT(1) AS ord_cnt, SUM(quantity) AS quantity_cnt, SUM(amount) AS total_amount FROM (\n"
                        + "SELECT *, ROW_NUMBER() OVER(PARTITION BY order_id, buyer, quantity, amount ORDER BY proctime() ASC) AS rk FROM Orders) tmp\n"
                        + "WHERE rk = 1\n"
                        + "GROUP BY buyer";

        compileSqlAndExecutePlan(sql, getDeduplicateAndAggregateTtlJsonTransformer()).await();

        List<String> expected =
                Arrays.asList(
                        "+I[Tom, 2, 2, 229.8]",
                        "+I[Jerry, 1, 2, 99.9]",
                        "+I[Jerry, 1, 2, 99.9]",
                        "+I[Olivia, 2, 4, 1100.0]",
                        "+I[Michael, 1, 3, 599.9]");
        assertResult(expected, TestValuesTableFactory.getResultsAsStrings("OrdersStats"));
    }

    @Test
    void testDifferentStateTtlForSameTwoInputStreamOperator() throws Exception {
        innerTestRegularJoin(
                "INSERT INTO OrdersShipInfo \n"
                        + "SELECT a.order_id, a.line_order_id, b.ship_mode FROM Orders a JOIN LineOrders b ON a.line_order_id = b.line_order_id",
                getLeftRightJoinTtlJsonTransformer());
    }

    @Test
    void testDifferentStateTtlThroughSqlHintForSameTwoInputStreamOperator() throws Exception {
        innerTestRegularJoin(
                "INSERT INTO OrdersShipInfo \n"
                        + "SELECT /*+ STATE_TTL('a' = '3s', 'b' = '9s') */\n"
                        + " a.order_id, a.line_order_id, b.ship_mode "
                        + "FROM Orders a JOIN LineOrders b ON a.line_order_id = b.line_order_id",
                json -> json);
    }

    private void innerTestRegularJoin(String sql, Function<String, String> jsonPlanTransformer)
            throws Exception {
        String leftTableDataId =
                TestValuesTableFactory.registerRowData(
                        Arrays.asList(
                                GenericRowData.of(1, 1000001),
                                GenericRowData.of(1, 1000002),
                                GenericRowData.of(1, 1000003),
                                GenericRowData.of(1, 1000004),
                                GenericRowData.of(1, 1000005),
                                GenericRowData.of(2, 2000001)));
        createOrdersSourceTableForJoin(leftTableDataId);

        String rightTableDataId =
                TestValuesTableFactory.registerRowData(
                        Arrays.asList(
                                GenericRowData.of(2000001, StringData.fromString("TRUCK")),
                                GenericRowData.of(1000005, StringData.fromString("AIR")),
                                GenericRowData.of(1000001, StringData.fromString("SHIP")),
                                GenericRowData.of(1000002, StringData.fromString("TRUCK")),
                                GenericRowData.of(1000003, StringData.fromString("RAIL")),
                                GenericRowData.of(1000004, StringData.fromString("RAIL"))));
        createLineOrdersSourceTableForJoin(rightTableDataId);

        createTestValuesSinkTable(
                "OrdersShipInfo", "`order_id` INT", "`line_order_id` INT", "`ship_mode` STRING");
        compileSqlAndExecutePlan(sql, jsonPlanTransformer).await();

        List<String> expected =
                Arrays.asList(
                        "+I[1, 1000002, TRUCK]", "+I[1, 1000004, RAIL]", "+I[1, 1000005, AIR]");
        assertResult(expected, TestValuesTableFactory.getResultsAsStrings("OrdersShipInfo"));
    }

    private void createOrdersSourceTable(String dataId) {
        createTestSourceTable(
                "Orders",
                new String[]{
                        "`order_id` INT", "`buyer` STRING", "`quantity` INT", "`amount` DOUBLE"
                },
                null,
                getProperties(dataId, 1, "2s"));
    }

    private void createOrdersSourceTableForJoin(String dataId) {
        createTestSourceTable(
                "Orders",
                new String[]{"`order_id` INT", "`line_order_id` INT"},
                null,
                getProperties(dataId, 1, "2s"));
    }

    private void createLineOrdersSourceTableForJoin(String dataId) {
        createTestSourceTable(
                "LineOrders",
                new String[]{"`line_order_id` INT", "`ship_mode` STRING"},
                null,
                getProperties(dataId, 2, "4s"));
    }

    private Function<String, String> getDeduplicateAndAggregateTtlJsonTransformer() {
        return (Function<String, String>) json -> {
            try {
                JsonNode target = JsonTestUtils.readFromString(json);
                JsonTestUtils.setExecNodeStateMetadata(
                        target, "stream-exec-deduplicate", 0, 6000L);
                JsonTestUtils.setExecNodeStateMetadata(
                        target, "stream-exec-group-aggregate", 0, 9000L);
                return JsonTestUtils.writeToString(target);
            } catch (IOException e) {
                throw new TableException("Cannot modify compiled json plan.", e);
            }
        };
    }

    private Function<String, String> getLeftRightJoinTtlJsonTransformer() {
        return json -> {
            try {
                JsonNode target = JsonTestUtils.readFromString(json);
                JsonTestUtils.setExecNodeStateMetadata(
                        target, "stream-exec-join", 0, 3000L);
                JsonTestUtils.setExecNodeStateMetadata(
                        target, "stream-exec-join", 1, 9000L);
                return JsonTestUtils.writeToString(target);
            } catch (IOException e) {
                throw new TableException("Cannot modify compiled json plan.", e);
            }
        };
    }

    private static Map<String, String> getProperties(
            String dataId, int sleepAfterElements, String sleepTime) {
        return new HashMap<String, String>() {
            {
                put("connector", "values");
                put("bounded", "false");
                put("register-internal-data", "true");
                put("source.sleep-after-elements", String.valueOf(sleepAfterElements));
                put("source.sleep-time", sleepTime);
                put("data-id", dataId);
            }
        };
    }
}