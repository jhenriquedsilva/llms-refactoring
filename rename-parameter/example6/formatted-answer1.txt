package org.apache.hadoop.yarn.client.api.impl;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.io.DataOutputBuffer;
import org.apache.hadoop.security.Credentials;
import org.apache.hadoop.security.UserGroupInformation;
import org.apache.hadoop.service.Service.STATE;
import org.apache.hadoop.test.GenericTestUtils;
import org.apache.hadoop.util.Shell;
import org.apache.hadoop.yarn.api.protocolrecords.AllocateResponse;
import org.apache.hadoop.yarn.api.protocolrecords.SubmitApplicationRequest;
import org.apache.hadoop.yarn.api.records.ApplicationId;
import org.apache.hadoop.yarn.api.records.ApplicationSubmissionContext;
import org.apache.hadoop.yarn.api.records.Container;
import org.apache.hadoop.yarn.api.records.ContainerId;
import org.apache.hadoop.yarn.api.records.ContainerLaunchContext;
import org.apache.hadoop.yarn.api.records.ContainerState;
import org.apache.hadoop.yarn.api.records.ContainerStatus;
import org.apache.hadoop.yarn.api.records.FinalApplicationStatus;
import org.apache.hadoop.yarn.api.records.NMToken;
import org.apache.hadoop.yarn.api.records.NodeReport;
import org.apache.hadoop.yarn.api.records.NodeState;
import org.apache.hadoop.yarn.api.records.Priority;
import org.apache.hadoop.yarn.api.records.Resource;
import org.apache.hadoop.yarn.client.api.AMRMClient;
import org.apache.hadoop.yarn.client.api.AMRMClient.ContainerRequest;
import org.apache.hadoop.yarn.client.api.NMClient;
import org.apache.hadoop.yarn.client.api.NMTokenCache;
import org.apache.hadoop.yarn.client.api.YarnClient;
import org.apache.hadoop.yarn.conf.YarnConfiguration;
import org.apache.hadoop.yarn.exceptions.YarnException;
import org.apache.hadoop.yarn.server.MiniYARNCluster;
import org.apache.hadoop.yarn.server.nodemanager.ContainerStateTransitionListener;
import org.apache.hadoop.yarn.server.nodemanager.Context;
import org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerEvent;
import org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerImpl;
import org.apache.hadoop.yarn.server.resourcemanager.rmapp.attempt.RMAppAttempt;
import org.apache.hadoop.yarn.server.resourcemanager.rmapp.attempt.RMAppAttemptState;
import org.apache.hadoop.yarn.util.Records;

import org.junit.Test;
import org.junit.function.ThrowingRunnable;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeoutException;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertThrows;
import static org.junit.Assert.assertTrue;

public class TestNMClient {
    private static final String IS_NOT_HANDLED_BY_THIS_NODEMANAGER = "is not handled by this NodeManager";
    private static final String UNKNOWN_CONTAINER = "Unknown container";
    private static final int NUMBER_OF_CONTAINERS = 5;
    private Configuration conf;
    private MiniYARNCluster yarnCluster;
    private YarnClientImpl yarnClient;
    private AMRMClientImpl<ContainerRequest> rmClient;
    private NMClientImpl nmClient;
    private List<NodeReport> nodeReports;
    private NMTokenCache nmTokenCache;
    private RMAppAttempt appAttempt;

    public static class DebugSumContainerStateListener implements ContainerStateTransitionListener {
        public static final Map<ContainerId, Integer> RUNNING_TRANSITIONS = new ConcurrentHashMap<>();

        public void init(Context context) {
        }

        public void preTransition(ContainerImpl containerImpl, org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState beforeState, ContainerEvent eventToBeProcessed) {
        }

        public void postTransition(ContainerImpl containerImpl, org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState beforeState, org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState afterState, ContainerEvent processedEvent) {
            if (beforeState != afterState && afterState == org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerState.RUNNING) {
                RUNNING_TRANSITIONS.compute(containerImpl.getContainerId(), (containerId, counter) -> counter == null ? 1 : ++counter);
            }
        }
    }

    public void setup() throws YarnException, IOException, InterruptedException, TimeoutException {
        conf = new YarnConfiguration();
        conf.set(YarnConfiguration.NM_CONTAINER_STATE_TRANSITION_LISTENERS, DebugSumContainerStateListener.class.getName());
        startYarnCluster();
        startYarnClient();
        UserGroupInformation.setLoginUser(UserGroupInformation.createRemoteUser(UserGroupInformation.getCurrentUser().getUserName()));
        UserGroupInformation.getCurrentUser().addToken(appAttempt.getAMRMToken());
        nmTokenCache = new NMTokenCache();
        startRMClient();
        startNMClient();
    }

    private void startYarnCluster() {
        yarnCluster = new MiniYARNCluster(TestNMClient.class.getName(), 3, 1, 1);
        yarnCluster.init(conf);
        yarnCluster.start();
        assertEquals(STATE.STARTED, yarnCluster.getServiceState());
    }

    private void startYarnClient() throws IOException, YarnException, InterruptedException, TimeoutException {
        yarnClient = (YarnClientImpl) YarnClient.createYarnClient();
        yarnClient.init(conf);
        yarnClient.start();
        assertEquals(STATE.STARTED, yarnClient.getServiceState());
        nodeReports = yarnClient.getNodeReports(NodeState.RUNNING);
        ApplicationSubmissionContext appContext = yarnClient.createApplication().getApplicationSubmissionContext();
        ApplicationId appId = appContext.getApplicationId();
        appContext.setApplicationName("Test");
        Priority pri = Priority.newInstance(0);
        appContext.setPriority(pri);
        appContext.setQueue("default");
        ContainerLaunchContext amContainer = Records.newRecord(ContainerLaunchContext.class);
        appContext.setAMContainerSpec(amContainer);
        appContext.setUnmanagedAM(true);
        SubmitApplicationRequest appRequest = Records.newRecord(SubmitApplicationRequest.class);
        appRequest.setApplicationSubmissionContext(appContext);
        yarnClient.submitApplication(appContext);
        GenericTestUtils.waitFor(() -> yarnCluster.getResourceManager().getRMContext().getRMApps().get(appId).getCurrentAppAttempt().getAppAttemptState() == RMAppAttemptState.LAUNCHED, 100, 30_000, "Failed to start app");
        appAttempt = yarnCluster.getResourceManager().getRMContext().getRMApps().get(appId).getCurrentAppAttempt();
    }

    private void startRMClient() {
        rmClient = (AMRMClientImpl<ContainerRequest>) AMRMClient.createAMRMClient();
        rmClient.setNMTokenCache(nmTokenCache);
        rmClient.init(conf);
        rmClient.start();
        assertEquals(STATE.STARTED, rmClient.getServiceState());
    }

    private void startNMClient() {
        nmClient = (NMClientImpl) NMClient.createNMClient();
        nmClient.setNMTokenCache(rmClient.getNMTokenCache());
        nmClient.init(conf);
        nmClient.start();
        assertEquals(STATE.STARTED, nmClient.getServiceState());
    }

    public void tearDown() throws InterruptedException {
        rmClient.stop();
        yarnClient.stop();
        yarnCluster.stop();
    }

    @Test(timeout = 180_000)
    public void testNMClientNoCleanupOnStop() throws YarnException, IOException, InterruptedException, TimeoutException {
        runTest(() -> {
            stopNmClient();
            assertFalse(nmClient.startedContainers.isEmpty());
            nmClient.cleanupRunningContainers();
            assertEquals(0, nmClient.startedContainers.size());
        });
    }

    @Test(timeout = 200_000)
    public void testNMClient() throws YarnException, IOException, InterruptedException, TimeoutException {
        runTest(() -> {
            assertFalse(nmClient.startedContainers.isEmpty());
            nmClient.cleanupRunningContainersOnStop(true);
            assertTrue(nmClient.getCleanupRunningContainers().get());
            nmClient.stop();
        });
    }

    public void runTest(Runnable testAction) throws IOException, InterruptedException, YarnException, TimeoutException {
        setup();
        rmClient.registerApplicationMaster("Host", 10_000, "");
        testContainerManagement(nmClient, allocateContainers(rmClient));
        rmClient.unregisterApplicationMaster(FinalApplicationStatus.SUCCEEDED, null, null);
        testAction.run();
        tearDown();
    }

    private void stopNmClient() {
        assertNotNull("Null nmClient", nmClient);
        assertEquals(1, nmClient.startedContainers.size());
        assertTrue(nmClient.getCleanupRunningContainers().get());
        nmClient.cleanupRunningContainersOnStop(false);
        assertFalse(nmClient.getCleanupRunningContainers().get());
        nmClient.stop();
    }

    private Set<Container> allocateContainers(AMRMClientImpl<ContainerRequest> rmClientImpl) throws YarnException, IOException {
        for (int containerIndex = 0; containerIndex < NUMBER_OF_CONTAINERS; ++containerIndex) {
            rmClientImpl.addContainerRequest(new ContainerRequest(Resource.newInstance(1024, 0), new String[]{nodeReports.get(0).getNodeId().getHost()}, new String[]{nodeReports.get(0).getRackName()}, Priority.newInstance(0)));
        }
        Set<Container> allocatedContainers = new TreeSet<>();
        while (allocatedContainers.size() < NUMBER_OF_CONTAINERS) {
            AllocateResponse allocResponse = rmClientImpl.allocate(0.1f);
            allocatedContainers.addAll(allocResponse.getAllocatedContainers());
            for (NMToken token : allocResponse.getNMTokens()) {
                rmClientImpl.getNMTokenCache().setToken(token.getNodeId().toString(), token.getToken());
            }
            if (allocatedContainers.size() < NUMBER_OF_CONTAINERS) {
                sleep(100);
            }
        }
        return allocatedContainers;
    }

    private void testContainerManagement(NMClientImpl nmClientImpl, Set<Container> containerSet) throws YarnException, IOException {
        int containerCount = containerSet.size();
        int containerIndex = 0;
        for (Container container : containerSet) {
            assertYarnException(() -> nmClientImpl.getContainerStatus(container.getId(), container.getNodeId()), IS_NOT_HANDLED_BY_THIS_NODEMANAGER);
            assertYarnException(() -> nmClientImpl.updateContainerResource(container), IS_NOT_HANDLED_BY_THIS_NODEMANAGER);
            assertYarnException(() -> nmClientImpl.restartContainer(container.getId()), UNKNOWN_CONTAINER);
            assertYarnException(() -> nmClientImpl.rollbackLastReInitialization(container.getId()), UNKNOWN_CONTAINER);
            assertYarnException(() -> nmClientImpl.commitLastReInitialization(container.getId()), UNKNOWN_CONTAINER);
            assertYarnException(() -> nmClientImpl.stopContainer(container.getId(), container.getNodeId()), IS_NOT_HANDLED_BY_THIS_NODEMANAGER);
            Credentials credentials = new Credentials();
            DataOutputBuffer dataOutputBuffer = new DataOutputBuffer();
            credentials.writeTokenStorageToStream(dataOutputBuffer);
            ByteBuffer securityTokens = ByteBuffer.wrap(dataOutputBuffer.getData(), 0, dataOutputBuffer.getLength());
            ContainerLaunchContext containerLaunchContext = Records.newRecord(ContainerLaunchContext.class);
            containerLaunchContext.setCommands(Shell.WINDOWS ? Arrays.asList("ping", "-n", "10000000", "127.0.0.1", ">nul") : Arrays.asList("sleep", "1000000"));
            containerLaunchContext.setTokens(securityTokens);
            nmClientImpl.startContainer(container, containerLaunchContext);
            List<Integer> exitStatuses = Arrays.asList(-1000, -105);
            if (++containerIndex < containerCount) {
                testContainer(nmClientImpl, containerIndex, container, containerLaunchContext, exitStatuses);
            }
        }
    }

    private void testContainer(NMClientImpl nmClientImpl, int containerIndex, Container container, ContainerLaunchContext containerLaunchContext, List<Integer> exitStatuses) throws YarnException, IOException {
        testGetContainerStatus(container, containerIndex, ContainerState.RUNNING, "", exitStatuses);
        waitForContainerRunningTransitionCount(container, 1);
        testIncreaseContainerResource(container);
        testRestartContainer(container);
        testGetContainerStatus(container, containerIndex, ContainerState.RUNNING, "will be Restarted", exitStatuses);
        waitForContainerRunningTransitionCount(container, 2);
        if (containerIndex % 2 == 0) {
            testReInitializeContainer(container, containerLaunchContext, false);
            testGetContainerStatus(container, containerIndex, ContainerState.RUNNING, "will be Re-initialized", exitStatuses);
            waitForContainerRunningTransitionCount(container, 3);
            testContainerRollback(container, true);
            testGetContainerStatus(container, containerIndex, ContainerState.RUNNING, "will be Rolled-back", exitStatuses);
            waitForContainerRunningTransitionCount(container, 4);
            testContainerCommit(container, false);
            testReInitializeContainer(container, containerLaunchContext, false);
            testGetContainerStatus(container, containerIndex, ContainerState.RUNNING, "will be Re-initialized", exitStatuses);
            waitForContainerRunningTransitionCount(container, 5);
            testContainerCommit(container, true);
        } else {
            testReInitializeContainer(container, containerLaunchContext, true);
            testGetContainerStatus(container, containerIndex, ContainerState.RUNNING, "will be Re-initialized", exitStatuses);
            waitForContainerRunningTransitionCount(container, 3);
            testContainerRollback(container, false);
            testContainerCommit(container, false);
        }
        nmClientImpl.stopContainer(container.getId(), container.getNodeId());
        testGetContainerStatus(container, containerIndex, ContainerState.COMPLETE, "killed by the ApplicationMaster", exitStatuses);
    }

    private void waitForContainerRunningTransitionCount(Container container, long transitions) {
        while (DebugSumContainerStateListener.RUNNING_TRANSITIONS.getOrDefault(container.getId(), 0) != transitions) {
            sleep(500);
        }
    }

    private void testGetContainerStatus(Container container, int containerIndex, ContainerState expectedState, String diagnostics, List<Integer> exitStatuses) throws YarnException, IOException {
        while (true) {
            sleep(250);
            ContainerStatus status = nmClient.getContainerStatus(container.getId(), container.getNodeId());
            if (status.getState() == expectedState) {
                assertEquals(container.getId(), status.getContainerId());
                assertTrue(containerIndex + ": " + status.getDiagnostics(), status.getDiagnostics().contains(diagnostics));
                assertTrue("Exit Statuses are supposed to be in: " + exitStatuses + ", but the actual exit status code is: " + status.getExitStatus(), exitStatuses.contains(status.getExitStatus()));
                break;
            }
        }
    }

    @SuppressWarnings("deprecation")
    private void testIncreaseContainerResource(Container container) {
        assertYarnException(() -> nmClient.increaseContainerResource(container), container.getId() + " has update version ");
    }

    private void testRestartContainer(Container container) throws IOException, YarnException {
        nmClient.restartContainer(container.getId());
    }

    private void testContainerRollback(Container container, boolean notRollbackable) throws IOException, YarnException {
        if (notRollbackable) {
            nmClient.rollbackLastReInitialization(container.getId());
        } else {
            assertYarnException(() -> nmClient.rollbackLastReInitialization(container.getId()), "Nothing to rollback to");
        }
    }

    private void testContainerCommit(Container container, boolean enabled) throws IOException, YarnException {
        if (enabled) {
            nmClient.commitLastReInitialization(container.getId());
        } else {
            assertYarnException(() -> nmClient.commitLastReInitialization(container.getId()), "Nothing to Commit");
        }
    }

    private void testReInitializeContainer(Container container, ContainerLaunchContext containerLaunchContext, boolean autoCommit) throws IOException, YarnException {
        nmClient.reInitializeContainer(container.getId(), containerLaunchContext, autoCommit);
    }

    private void assertYarnException(ThrowingRunnable runnable, String text) {
        YarnException e = assertThrows(YarnException.class, runnable);
        assertTrue(String.format("The thrown exception is not expected cause it has text [%s]" + ", what not contains text [%s]", e.getMessage(), text), e.getMessage().contains(text));
    }

    private void sleep(int sleepTimeMs) {
        try {
            Thread.sleep(sleepTimeMs);
        } catch (InterruptedException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }
}