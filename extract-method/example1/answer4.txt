28-05-2025, 19:49
Yes, there are clear opportunities for **extract method refactoring** in the presented code. The code block that constructs a log message—depending on whether `message` is set and whether `errorCount >= errorLimit`—appears with near-identical logic in both the `logMessage(int lineNumber)` and inside the `findMatch()` method (for the `MSG_REQUIRED_REGEXP` case).

This can be extracted into a common private method, for example, `private String getFormattedLogMessage()`. This increases maintainability and readability, and avoids code duplication.

Here is the revised and refactored class:

```java
package com.puppycrawl.tools.checkstyle.checks.regexp;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.puppycrawl.tools.checkstyle.FileStatefulCheck;
import com.puppycrawl.tools.checkstyle.api.AbstractCheck;
import com.puppycrawl.tools.checkstyle.api.DetailAST;
import com.puppycrawl.tools.checkstyle.api.FileContents;
import com.puppycrawl.tools.checkstyle.api.FileText;
import com.puppycrawl.tools.checkstyle.api.LineColumn;
import com.puppycrawl.tools.checkstyle.utils.CommonUtil;

/**
 * [class-level javadoc omitted for brevity, unchanged]
 */
@FileStatefulCheck
public class RegexpCheck extends AbstractCheck {

    public static final String MSG_ILLEGAL_REGEXP = "illegal.regexp";
    public static final String MSG_REQUIRED_REGEXP = "required.regexp";
    public static final String MSG_DUPLICATE_REGEXP = "duplicate.regexp";
    private static final int DEFAULT_DUPLICATE_LIMIT = -1;
    private static final int DEFAULT_ERROR_LIMIT = 100;
    private static final String ERROR_LIMIT_EXCEEDED_MESSAGE =
            "The error limit has been exceeded, "
                    + "the check is aborting, there may be more unreported errors.";

    private String message;
    private boolean ignoreComments;
    private boolean illegalPattern;
    private int errorLimit = DEFAULT_ERROR_LIMIT;
    private int duplicateLimit;
    private boolean checkForDuplicates;
    private int matchCount;
    private int errorCount;
    private Pattern format = Pattern.compile("^$", Pattern.MULTILINE);
    private Matcher matcher;

    public void setMessage(String message) {
        this.message = message;
    }

    public void setIgnoreComments(boolean ignoreComments) {
        this.ignoreComments = ignoreComments;
    }

    public void setIllegalPattern(boolean illegalPattern) {
        this.illegalPattern = illegalPattern;
    }

    public void setErrorLimit(int errorLimit) {
        this.errorLimit = errorLimit;
    }

    public void setDuplicateLimit(int duplicateLimit) {
        this.duplicateLimit = duplicateLimit;
        checkForDuplicates = duplicateLimit > DEFAULT_DUPLICATE_LIMIT;
    }

    public final void setFormat(Pattern pattern) {
        format = CommonUtil.createPattern(pattern.pattern(), Pattern.MULTILINE);
    }

    @Override
    public int[] getDefaultTokens() {
        return getRequiredTokens();
    }

    @Override
    public int[] getAcceptableTokens() {
        return getRequiredTokens();
    }

    @Override
    public int[] getRequiredTokens() {
        return CommonUtil.EMPTY_INT_ARRAY;
    }

    @SuppressWarnings("deprecation")
    @Override
    public void beginTree(DetailAST rootAST) {
        matcher = format.matcher(getFileContents().getText().getFullText());
        matchCount = 0;
        errorCount = 0;
        findMatch();
    }

    @SuppressWarnings("deprecation")
    private void findMatch() {
        final boolean foundMatch = matcher.find();
        if (foundMatch) {
            final FileText text = getFileContents().getText();
            final LineColumn start = text.lineColumn(matcher.start());
            final int startLine = start.getLine();

            final boolean ignore = isIgnore(startLine, text, start);

            if (!ignore) {
                matchCount++;
                if (illegalPattern || checkForDuplicates
                        && matchCount - 1 > duplicateLimit) {
                    errorCount++;
                    logMessage(startLine);
                }
            }
            if (canContinueValidation(ignore)) {
                findMatch();
            }
        }
        else if (!illegalPattern && matchCount == 0) {
            String msg = getFormattedLogMessage();
            log(1, MSG_REQUIRED_REGEXP, msg);
        }
    }

    private boolean canContinueValidation(boolean ignore) {
        return errorCount <= errorLimit - 1
                && (ignore || illegalPattern || checkForDuplicates);
    }

    @SuppressWarnings("deprecation")
    private boolean isIgnore(int startLine, FileText text, LineColumn start) {
        final LineColumn end;
        if (matcher.end() == 0) {
            end = text.lineColumn(0);
        }
        else {
            end = text.lineColumn(matcher.end() - 1);
        }
        boolean ignore = false;
        if (ignoreComments) {
            final FileContents theFileContents = getFileContents();
            final int startColumn = start.getColumn();
            final int endLine = end.getLine();
            final int endColumn = end.getColumn();
            ignore = theFileContents.hasIntersectionWithComment(startLine,
                    startColumn, endLine, endColumn);
        }
        return ignore;
    }

    /**
     * Displays the right message.
     *
     * @param lineNumber the line number the message relates to.
     */
    private void logMessage(int lineNumber) {
        String msg = getFormattedLogMessage();

        if (illegalPattern) {
            log(lineNumber, MSG_ILLEGAL_REGEXP, msg);
        }
        else {
            log(lineNumber, MSG_DUPLICATE_REGEXP, msg);
        }
    }

    /**
     * Returns the formatted log message based on state.
     *
     * @return the formatted log message.
     */
    private String getFormattedLogMessage() {
        String msg;
        if (message == null || message.isEmpty()) {
            msg = format.pattern();
        }
        else {
            msg = message;
        }

        if (errorCount >= errorLimit) {
            msg = ERROR_LIMIT_EXCEEDED_MESSAGE + msg;
        }
        return msg;
    }

}
```

**Summary of the refactoring:**  
- Moved log message formatting to `private String getFormattedLogMessage()`
- Both `findMatch()` and `logMessage(int lineNumber)` now call this extracted method.

This removes duplicated message formatting logic and improves clarity. No other significant extract-method refactorings are needed; the rest of the logic is reasonably cohesive and clear.

Levenshtein edit-distance: 7018
Compiles
Tests pass