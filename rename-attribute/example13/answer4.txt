02-05-2025, 10:41

**Analysis for Rename Attribute Refactoring:**

A "rename attribute" refactoring is about changing field (attribute) names to better express their purpose, which improves code readability and maintainability. Let's closely analyze your provided code for fields/attributes (including static/final fields, class member fields, and inner-class fields).

### Fields/Attributes Present

1. **TempDirectory (outer class):**
    - `static final Namespace NAMESPACE`
    - `private static final String KEY`
    - `static final String FILE_OPERATIONS_KEY`
    - `private final JupiterConfiguration configuration;`
2. **CloseablePath (inner class):**
    - `private static final Logger logger`
    - `private final Path dir;`
    - `private final TempDirFactory factory;`
    - `private final CleanupMode cleanupMode;`
    - `private final ExtensionContext executionContext;`
3. **FieldContext (inner private static class):**
    - `private final Field field;`

### Assessment

Let's see if these fields are low-quality or ambiguous:

- `NAMESPACE` - standard, clear for JUnit extension storage.
- `KEY` - not very descriptive (used for temp dir key in store).
- `FILE_OPERATIONS_KEY` - clear, since it’s for a custom file operation.
- `configuration` - clear; clearly a configuration object.
- Inside `CloseablePath`:
    - `logger` - clear and conventional.
    - `dir` - could be more explicit, e.g. `directory`.
    - `factory`, `cleanupMode`, `executionContext` - clear, common in JUnit/community.
- Inside `FieldContext`:
    - `field` - clear usage as a Java reflection `Field`.

**Potential Opportunities:**

- **KEY** is overly generic for a JUnit extension context. A more descriptive name like `TEMP_DIR_KEY` makes its purpose clearer.
- **dir** is serviceable, but `directory` is more readable and consistent.

Let’s rename:
- `KEY` -> `TEMP_DIR_KEY`
- `dir` (in `CloseablePath`) -> `directory`

### Refactored Code

Here’s your class with those two attribute names improved:

```java
package org.junit.jupiter.engine.extension;

// (imports unchanged)

/**
 * {@code TempDirectory} is a JUnit Jupiter extension that creates and cleans
 * up temporary directories if field in a test class or a parameter in a
 * lifecycle method or test method is annotated with {@code @TempDir}.
 *
 * <p>Consult the Javadoc for {@link TempDir} for details on the contract.
 *
 * @since 5.4
 * @see TempDir
 * @see Files#createTempDirectory
 */
class TempDirectory implements BeforeAllCallback, BeforeEachCallback, ParameterResolver {

    static final Namespace NAMESPACE = Namespace.create(TempDirectory.class);
    private static final String TEMP_DIR_KEY = "temp.dir"; // Renamed from KEY

    // for testing purposes
    static final String FILE_OPERATIONS_KEY = "file.operations";

    private final JupiterConfiguration configuration;

    public TempDirectory(JupiterConfiguration configuration) {
        this.configuration = configuration;
    }

    // ... (methods unchanged) ...

    private Object getPathOrFile(AnnotatedElementContext elementContext, Class<?> type, TempDirFactory factory,
                                 CleanupMode cleanupMode, Scope scope, ExtensionContext extensionContext) {
        Namespace namespace = scope == Scope.PER_DECLARATION //
                ? NAMESPACE.append(elementContext) //
                : NAMESPACE;
        Path directory = extensionContext.getStore(namespace) // Renamed variable here
                .getOrComputeIfAbsent(TEMP_DIR_KEY, __ -> createTempDir(factory, cleanupMode, elementContext, extensionContext),
                        CloseablePath.class) //
                .get();

        return (type == Path.class) ? directory : directory.toFile();
    }

    static CloseablePath createTempDir(TempDirFactory factory, CleanupMode cleanupMode,
                                       AnnotatedElementContext elementContext, ExtensionContext extensionContext) {
        try {
            return new CloseablePath(factory, cleanupMode, elementContext, extensionContext);
        }
        catch (Exception ex) {
            throw new ExtensionConfigurationException("Failed to create default temp directory", ex);
        }
    }

    static class CloseablePath implements CloseableResource {

        private static final Logger logger = LoggerFactory.getLogger(CloseablePath.class);

        private final Path directory; // Renamed from dir
        private final TempDirFactory factory;
        private final CleanupMode cleanupMode;
        private final ExtensionContext executionContext;

        CloseablePath(TempDirFactory factory, CleanupMode cleanupMode, AnnotatedElementContext elementContext,
                      ExtensionContext extensionContext) throws Exception {
            this.directory = factory.createTempDirectory(elementContext, extensionContext); // Renamed here
            this.factory = factory;
            this.cleanupMode = cleanupMode;
            this.executionContext = extensionContext;
        }

        Path get() {
            return directory;
        }

        @Override
        public void close() throws IOException {
            try {
                if (cleanupMode == NEVER
                        || (cleanupMode == ON_SUCCESS && executionContext.getExecutionException().isPresent())) {
                    logger.info(() -> "Skipping cleanup of temp dir " + directory + " due to cleanup mode configuration.");
                    return;
                }

                FileOperations fileOperations = executionContext.getStore(NAMESPACE) //
                        .getOrDefault(FILE_OPERATIONS_KEY, FileOperations.class, FileOperations.DEFAULT);

                SortedMap<Path, IOException> failures = deleteAllFilesAndDirectories(fileOperations);
                if (!failures.isEmpty()) {
                    throw createIOExceptionWithAttachedFailures(failures);
                }
            }
            finally {
                factory.close();
            }
        }

        private SortedMap<Path, IOException> deleteAllFilesAndDirectories(FileOperations fileOperations)
                throws IOException {
            if (Files.notExists(directory)) {
                return Collections.emptySortedMap();
            }

            SortedMap<Path, IOException> failures = new TreeMap<>();
            Set<Path> retriedPaths = new HashSet<>();
            tryToResetPermissions(directory);
            Files.walkFileTree(directory, new SimpleFileVisitor<Path>() {

                @Override
                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
                    if (!dir.equals(CloseablePath.this.directory)) {
                        tryToResetPermissions(dir);
                    }
                    return CONTINUE;
                }

                @Override
                public FileVisitResult visitFileFailed(Path file, IOException exc) {
                    // IOException includes `AccessDeniedException` thrown by non-readable or non-executable flags
                    resetPermissionsAndTryToDeleteAgain(file, exc);
                    return CONTINUE;
                }

                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attributes) {
                    return deleteAndContinue(file);
                }

                @Override
                public FileVisitResult postVisitDirectory(Path dir, IOException exc) {
                    return deleteAndContinue(dir);
                }

                private FileVisitResult deleteAndContinue(Path path) {
                    try {
                        fileOperations.delete(path);
                    }
                    catch (NoSuchFileException ignore) {
                        // ignore
                    }
                    catch (DirectoryNotEmptyException exception) {
                        failures.put(path, exception);
                    }
                    catch (IOException exception) {
                        // IOException includes `AccessDeniedException` thrown by non-readable or non-executable flags
                        resetPermissionsAndTryToDeleteAgain(path, exception);
                    }
                    return CONTINUE;
                }

                private void resetPermissionsAndTryToDeleteAgain(Path path, IOException exception) {
                    boolean notYetRetried = retriedPaths.add(path);
                    if (notYetRetried) {
                        try {
                            tryToResetPermissions(path);
                            if (Files.isDirectory(path)) {
                                Files.walkFileTree(path, this);
                            }
                            else {
                                fileOperations.delete(path);
                            }
                        }
                        catch (Exception suppressed) {
                            exception.addSuppressed(suppressed);
                            failures.put(path, exception);
                        }
                    }
                    else {
                        failures.put(path, exception);
                    }
                }
            });
            return failures;
        }

        @SuppressWarnings("ResultOfMethodCallIgnored")
        private static void tryToResetPermissions(Path path) {
            File file;
            try {
                file = path.toFile();
            }
            catch (UnsupportedOperationException ignore) {
                // Might happen when the `TempDirFactory` uses a custom `FileSystem`
                return;
            }
            file.setReadable(true);
            file.setWritable(true);
            if (Files.isDirectory(path)) {
                file.setExecutable(true);
            }
            DosFileAttributeView dos = Files.getFileAttributeView(path, DosFileAttributeView.class);
            if (dos != null) {
                try {
                    dos.setReadOnly(false);
                }
                catch (IOException ignore) {
                    // nothing we can do
                }
            }
        }

        private IOException createIOExceptionWithAttachedFailures(SortedMap<Path, IOException> failures) {
            Path emptyPath = Paths.get("");
            String joinedPaths = failures.keySet().stream() //
                    .map(this::tryToDeleteOnExit) //
                    .map(this::relativizeSafely) //
                    .map(path -> emptyPath.equals(path) ? "<root>" : path.toString()) //
                    .collect(joining(", "));
            IOException exception = new IOException("Failed to delete temp directory " + directory.toAbsolutePath()
                    + ". The following paths could not be deleted (see suppressed exceptions for details): "
                    + joinedPaths);
            failures.values().forEach(exception::addSuppressed);
            return exception;
        }

        private Path tryToDeleteOnExit(Path path) {
            try {
                path.toFile().deleteOnExit();
            }
            catch (UnsupportedOperationException ignore) {
            }
            return path;
        }

        private Path relativizeSafely(Path path) {
            try {
                return directory.relativize(path);
            }
            catch (IllegalArgumentException e) {
                return path;
            }
        }
    }

    enum Scope {

        PER_CONTEXT,

        PER_DECLARATION

    }

    interface FileOperations {

        FileOperations DEFAULT = Files::delete;

        void delete(Path path) throws IOException;

    }

    private static class FieldContext implements AnnotatedElementContext {

        private final Field field;

        private FieldContext(Field field) {
            this.field = Preconditions.notNull(field, "field must not be null");
        }

        @Override
        public AnnotatedElement getAnnotatedElement() {
            return this.field;
        }

        @Override
        public String toString() {
            // @formatter:off
            return new ToStringBuilder(this)
                    .append("field", this.field)
                    .toString();
            // @formatter:on
        }

    }

}
```

---

**Summary:**
- `KEY` renamed to `TEMP_DIR_KEY`
- All usages of `KEY` updated accordingly.
- In `CloseablePath`, `dir` renamed to `directory`, with all references updated.

*No further rename refactoring needed; other attribute names are descriptive and standard.*
