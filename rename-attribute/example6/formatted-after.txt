package org.apache.hadoop.ipc;

import java.util.Arrays;
import java.util.UUID;
import java.util.concurrent.locks.ReentrantLock;

import org.apache.hadoop.classification.InterfaceAudience;
import org.apache.hadoop.ipc.metrics.RetryCacheMetrics;
import org.apache.hadoop.util.LightWeightCache;
import org.apache.hadoop.util.LightWeightGSet;
import org.apache.hadoop.util.LightWeightGSet.LinkedElement;
import org.apache.hadoop.classification.VisibleForTesting;
import org.apache.hadoop.util.Preconditions;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@InterfaceAudience.Private
public class RetryCache {
    public static final Logger LOG = LoggerFactory.getLogger(RetryCache.class);
    private final RetryCacheMetrics retryCacheMetrics;
    private static final int MIN_CAPACITY = 16;

    public static class CacheEntry implements LightWeightCache.Entry {
        private static final byte INPROGRESS = 0;
        private static final byte SUCCESS = 1;
        private static final byte FAILED = 2;
        private byte state = INPROGRESS;
        private final long clientIdMsb;
        private final long clientIdLsb;
        private final int callId;
        private final long expirationTime;
        private LightWeightGSet.LinkedElement next;

        CacheEntry(byte[] clientId, int callId, long expirationTime) {
            Preconditions.checkArgument(clientId.length == ClientId.BYTE_LENGTH, "Invalid clientId - length is " + clientId.length + " expected length " + ClientId.BYTE_LENGTH);
            clientIdMsb = ClientId.getMsb(clientId);
            clientIdLsb = ClientId.getLsb(clientId);
            this.callId = callId;
            this.expirationTime = expirationTime;
        }

        CacheEntry(byte[] clientId, int callId, long expirationTime, boolean success) {
            this(clientId, callId, expirationTime);
            this.state = success ? SUCCESS : FAILED;
        }

        private static int hashCode(long value) {
            return (int) (value ^ (value >>> 32));
        }

        @Override
        public int hashCode() {
            return (hashCode(clientIdMsb) * 31 + hashCode(clientIdLsb)) * 31 + callId;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (!(obj instanceof CacheEntry)) {
                return false;
            }
            CacheEntry other = (CacheEntry) obj;
            return callId == other.callId && clientIdMsb == other.clientIdMsb && clientIdLsb == other.clientIdLsb;
        }

        @Override
        public void setNext(LinkedElement next) {
            this.next = next;
        }

        @Override
        public LinkedElement getNext() {
            return next;
        }

        synchronized void completed(boolean success) {
            state = success ? SUCCESS : FAILED;
            this.notifyAll();
        }

        public synchronized boolean isSuccess() {
            return state == SUCCESS;
        }

        @Override
        public void setExpirationTime(long timeNano) {
        }

        @Override
        public long getExpirationTime() {
            return expirationTime;
        }

        @Override
        public String toString() {
            return String.format("%s:%s:%s", new UUID(this.clientIdMsb, this.clientIdLsb), this.callId, this.state);
        }
    }

    public static class CacheEntryWithPayload extends CacheEntry {
        private Object payload;

        CacheEntryWithPayload(byte[] clientId, int callId, Object payload, long expirationTime) {
            super(clientId, callId, expirationTime);
            this.payload = payload;
        }

        CacheEntryWithPayload(byte[] clientId, int callId, Object payload, long expirationTime, boolean success) {
            super(clientId, callId, expirationTime, success);
            this.payload = payload;
        }

        @Override
        public boolean equals(Object obj) {
            return super.equals(obj);
        }

        @Override
        public int hashCode() {
            return super.hashCode();
        }

        public Object getPayload() {
            return payload;
        }
    }

    private final LightWeightGSet<CacheEntry, CacheEntry> set;
    private final long expirationTime;
    private final String cacheName;
    private final ReentrantLock lock = new ReentrantLock();

    public RetryCache(String cacheName, double percentage, long expirationTime) {
        int capacity = LightWeightGSet.computeCapacity(percentage, cacheName);
        capacity = Math.max(capacity, MIN_CAPACITY);
        this.set = new LightWeightCache<CacheEntry, CacheEntry>(capacity, capacity, expirationTime, 0);
        this.expirationTime = expirationTime;
        this.cacheName = cacheName;
        this.retryCacheMetrics = RetryCacheMetrics.create(this);
    }

    private static boolean skipRetryCache(byte[] clientId, int callId) {
        return !Server.isRpcInvocation() || callId < 0 || Arrays.equals(clientId, RpcConstants.DUMMY_CLIENT_ID);
    }

    public void lock() {
        this.lock.lock();
    }

    public void unlock() {
        this.lock.unlock();
    }

    private void incrCacheClearedCounter() {
        retryCacheMetrics.incrCacheCleared();
    }

    @VisibleForTesting
    public LightWeightGSet<CacheEntry, CacheEntry> getCacheSet() {
        return set;
    }

    @VisibleForTesting
    public RetryCacheMetrics getMetricsForTests() {
        return retryCacheMetrics;
    }

    public String getCacheName() {
        return cacheName;
    }

    private CacheEntry waitForCompletion(CacheEntry newEntry) {
        CacheEntry mapEntry = null;
        lock.lock();
        try {
            mapEntry = set.get(newEntry);
            if (mapEntry == null) {
                if (LOG.isTraceEnabled()) {
                    LOG.trace("Adding Rpc request clientId " + newEntry.clientIdMsb + newEntry.clientIdLsb + " callId " + newEntry.callId + " to retryCache");
                }
                set.put(newEntry);
                retryCacheMetrics.incrCacheUpdated();
                return newEntry;
            } else {
                retryCacheMetrics.incrCacheHit();
            }
        } finally {
            lock.unlock();
        }
        Preconditions.checkNotNull(mapEntry, "Entry from the cache should not be null");
        synchronized (mapEntry) {
            while (mapEntry.state == CacheEntry.INPROGRESS) {
                try {
                    mapEntry.wait();
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                }
            }
            if (mapEntry.state != CacheEntry.SUCCESS) {
                mapEntry.state = CacheEntry.INPROGRESS;
            }
        }
        return mapEntry;
    }

    public void addCacheEntry(byte[] clientId, int callId) {
        CacheEntry newEntry = new CacheEntry(clientId, callId, System.nanoTime() + expirationTime, true);
        lock.lock();
        try {
            set.put(newEntry);
        } finally {
            lock.unlock();
        }
        retryCacheMetrics.incrCacheUpdated();
    }

    public void addCacheEntryWithPayload(byte[] clientId, int callId, Object payload) {
        CacheEntry newEntry = new CacheEntryWithPayload(clientId, callId, payload, System.nanoTime() + expirationTime, true);
        lock.lock();
        try {
            set.put(newEntry);
        } finally {
            lock.unlock();
        }
        retryCacheMetrics.incrCacheUpdated();
    }

    private static CacheEntry newEntry(long expirationTime, byte[] clientId, int callId) {
        return new CacheEntry(clientId, callId, System.nanoTime() + expirationTime);
    }

    private static CacheEntryWithPayload newEntry(Object payload, long expirationTime, byte[] clientId, int callId) {
        return new CacheEntryWithPayload(clientId, callId, payload, System.nanoTime() + expirationTime);
    }

    public static CacheEntry waitForCompletion(RetryCache cache, byte[] clientId, int callId) {
        if (skipRetryCache(clientId, callId)) {
            return null;
        }
        return cache != null ? cache.waitForCompletion(newEntry(cache.expirationTime, clientId, callId)) : null;
    }

    public static CacheEntryWithPayload waitForCompletion(RetryCache cache, Object payload, byte[] clientId, int callId) {
        if (skipRetryCache(clientId, callId)) {
            return null;
        }
        return (CacheEntryWithPayload) (cache != null ? cache.waitForCompletion(newEntry(payload, cache.expirationTime, clientId, callId)) : null);
    }

    public static void setState(CacheEntry e, boolean success) {
        if (e == null) {
            return;
        }
        e.completed(success);
    }

    public static void setState(CacheEntryWithPayload e, boolean success, Object payload) {
        if (e == null) {
            return;
        }
        e.payload = payload;
        e.completed(success);
    }

    public static void clear(RetryCache cache) {
        if (cache != null) {
            cache.set.clear();
            cache.incrCacheClearedCounter();
        }
    }
}