26-04-2025, 10:50

This code has clear **duplication** in the logic inside the `getGenericType(Field)` and `getGenericType(Parameter)` methods. Both methods do (almost) exactly the same thing:
1. Obtain a `Type` from the input,
2. Check if it is a `ParameterizedType`,
3. Extract the actual type argument,
4. Check if it is a class or a nested parameterized type.

The only **difference** is how the `Type` is obtained:
- From a `Field`: `field.getGenericType()`
- From a `Parameter`: `parameter.getType()`

To remove duplication, you can **extract** the common generic type resolution logic into a private helper method that takes a `Type` argument.

---

## Refactored Code

```java
package org.mockito.internal.util.reflection;

import java.lang.reflect.Field;
import java.lang.reflect.Parameter;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

public class GenericMaster {

    /**
     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class.
     *
     * @param field the field to inspect
     */
    public Class<?> getGenericType(Field field) {
        return resolveGenericType(field.getGenericType());
    }

    /**
     * Resolves the type (parametrized type) of the parameter. If the parameter is not generic it returns Object.class.
     *
     * @param parameter the parameter to inspect
     */
    public Class<?> getGenericType(Parameter parameter) {
        return resolveGenericType(parameter.getType());
    }

    /**
     * Resolves the generic class from a Type. If the type is not generic it returns Object.class.
     *
     * @param type the type to resolve
     * @return the resolved generic class or Object.class if not generic
     */
    private Class<?> resolveGenericType(Type type) {
        if (type instanceof ParameterizedType) {
            Type actual = ((ParameterizedType) type).getActualTypeArguments()[0];
            if (actual instanceof Class) {
                return (Class<?>) actual;
            } else if (actual instanceof ParameterizedType) {
                // in case of nested generics we don't go deep
                return (Class<?>) ((ParameterizedType) actual).getRawType();
            }
        }
        return Object.class;
    }
}
```

---

**Summary of changes:**
- Extracted the shared logic into the `private Class<?> resolveGenericType(Type type)` method.
- Updated the two public methods to delegate to this helper, removing duplication.
- Improved code readability and maintainability.



FINISHED REFACTORING 0



There is a clear opportunity for **extract method refactoring** here! Both `getGenericType(Field field)` and `getGenericType(Parameter parameter)` share highly similar logicâ€”isolated only by how they get the `Type`. We can extract a common private method that takes a `Type` as input and returns the generic `Class<?>`, and then delegate both public methods to it.

Here is the refactored class:

```java
package org.mockito.internal.util.reflection;

import java.lang.reflect.Field;
import java.lang.reflect.Parameter;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

public class GenericMaster {

    /**
     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class.
     *
     * @param field the field to inspect
     */
    public Class<?> getGenericType(Field field) {
        return extractGenericType(field.getGenericType());
    }

    /**
     * Resolves the type (parametrized type) of the parameter. If the parameter is not generic it returns Object.class.
     *
     * @param parameter the parameter to inspect
     */
    public Class<?> getGenericType(Parameter parameter) {
        return extractGenericType(parameter.getType());
    }

    /**
     * Extracts the parameterized type from a Type. If the type is not generic returns Object.class.
     */
    private Class<?> extractGenericType(Type generic) {
        if (generic instanceof ParameterizedType) {
            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];
            if (actual instanceof Class) {
                return (Class<?>) actual;
            } else if (actual instanceof ParameterizedType) {
                // in case of nested generics we don't go deep
                return (Class<?>) ((ParameterizedType) actual).getRawType();
            }
        }
        return Object.class;
    }

}
```

### **Summary of Refactoring**:

- Extracted the duplicate logic to a private method `extractGenericType(Type generic)`.
- Both public methods now delegate to this helper, reducing code repetition and improving maintainability.
