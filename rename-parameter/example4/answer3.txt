01-05-2025, 10:53

### Review & Refactoring Analysis

#### Main focus: Parameter Renaming
The primary question is: *Are there parameters that would benefit from renaming to enhance clarity/readability, especially for method signatures and constructor parameters?*

#### ANALYSIS

**Key places with possible confusion:**

Constructor:
```java
public DateFormat(
        Source source,
        @Param(optional = true, name = "format", type = { "keyword" }, description = "A valid date pattern") Expression first,
        @Param(name = "date", type = { "date" }, description = "Date expression") Expression date,
        Configuration configuration
)
```

Note that:
- The second param is called `first` but represents `format`, while the third is called `date`.
- Later, in the implementation, they are (re-)assigned to `field` and `format`.
    ```java
    this.field = date != null ? date : first;
    this.format = date != null ? first : null;
    ```

Elsewhere, names like `val`, `formatter`, and so on appear, but they match context.

The main refactor suggestion is to rename `first` parameter to `formatOrDate`, as it serves as either the optional `format` or the main `date` expression if only one argument is passed (see its use in `List.of(first, date)` and the assignment logic).

**Also, within**:
```java
@Override
protected NodeInfo<? extends Expression> info() {
    Expression first = format != null ? format : field;
    Expression second = format != null ? field : null;
    return NodeInfo.create(this, DateFormat::new, first, second, configuration());
}
```
`first` and `second` could become `formatArg` and `dateArg` or `primaryArg`, `secondaryArg` for clarity.

#### Suggestion summary:

- Replace ambiguous `first` parameter name with `formatOrDate`.
- In `info()`, use `primaryArg`/`secondaryArg` instead of `first`/`second`.
- Update usage correspondingly throughout the class.

---

## Refactored Code

```java
package org.elasticsearch.xpack.esql.expression.function.scalar.date;

import org.apache.lucene.util.BytesRef;
import org.elasticsearch.common.time.DateFormatter;
import org.elasticsearch.compute.ann.Evaluator;
import org.elasticsearch.compute.ann.Fixed;
import org.elasticsearch.compute.operator.EvalOperator.ExpressionEvaluator;
import org.elasticsearch.xpack.esql.evaluator.mapper.EvaluatorMapper;
import org.elasticsearch.xpack.esql.expression.function.FunctionInfo;
import org.elasticsearch.xpack.esql.expression.function.Param;
import org.elasticsearch.xpack.esql.session.EsqlConfiguration;
import org.elasticsearch.xpack.ql.expression.Expression;
import org.elasticsearch.xpack.ql.expression.function.OptionalArgument;
import org.elasticsearch.xpack.ql.expression.function.scalar.ConfigurationFunction;
import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;
import org.elasticsearch.xpack.ql.session.Configuration;
import org.elasticsearch.xpack.ql.tree.NodeInfo;
import org.elasticsearch.xpack.ql.tree.Source;
import org.elasticsearch.xpack.ql.type.DataType;
import org.elasticsearch.xpack.ql.type.DataTypes;

import java.util.List;
import java.util.Locale;
import java.util.function.Function;

import static org.elasticsearch.xpack.ql.expression.TypeResolutions.ParamOrdinal.FIRST;
import static org.elasticsearch.xpack.ql.expression.TypeResolutions.ParamOrdinal.SECOND;
import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isDate;
import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;
import static org.elasticsearch.xpack.ql.util.DateUtils.UTC_DATE_TIME_FORMATTER;

public class DateFormat extends ConfigurationFunction implements OptionalArgument, EvaluatorMapper {

    private final Expression field;
    private final Expression format;

    @FunctionInfo(returnType = "keyword", description = "Returns a string representation of a date, in the provided format.")
    public DateFormat(
            Source source,
            @Param(optional = true, name = "format", type = { "keyword" }, description = "A valid date pattern") Expression formatOrDate,
            @Param(name = "date", type = { "date" }, description = "Date expression") Expression date,
            Configuration configuration
    ) {
        super(source, date != null ? List.of(formatOrDate, date) : List.of(formatOrDate), configuration);
        this.field = date != null ? date : formatOrDate;
        this.format = date != null ? formatOrDate : null;
    }

    @Override
    public DataType dataType() {
        return DataTypes.KEYWORD;
    }

    @Override
    protected TypeResolution resolveType() {
        if (childrenResolved() == false) {
            return new TypeResolution("Unresolved children");
        }

        TypeResolution resolution = isDate(field, sourceText(), format == null ? FIRST : SECOND);
        if (resolution.unresolved()) {
            return resolution;
        }
        if (format != null) {
            resolution = isStringAndExact(format, sourceText(), FIRST);
            if (resolution.unresolved()) {
                return resolution;
            }
        }

        return TypeResolution.TYPE_RESOLVED;
    }

    @Override
    public boolean foldable() {
        return field.foldable() && (format == null || format.foldable());
    }

    @Override
    public Object fold() {
        return EvaluatorMapper.super.fold();
    }

    @Evaluator(extraName = "Constant")
    static BytesRef process(long val, @Fixed DateFormatter formatter) {
        return new BytesRef(formatter.formatMillis(val));
    }

    @Evaluator
    static BytesRef process(long val, BytesRef formatter, @Fixed Locale locale) {
        return process(val, toFormatter(formatter, locale));
    }

    @Override
    public ExpressionEvaluator.Factory toEvaluator(Function<Expression, ExpressionEvaluator.Factory> toEvaluator) {
        var fieldEvaluator = toEvaluator.apply(field);
        if (format == null) {
            return dvrCtx -> new DateFormatConstantEvaluator(source(), fieldEvaluator.get(dvrCtx), UTC_DATE_TIME_FORMATTER, dvrCtx);
        }
        if (format.dataType() != DataTypes.KEYWORD) {
            throw new IllegalArgumentException("unsupported data type for format [" + format.dataType() + "]");
        }
        if (format.foldable()) {
            DateFormatter formatter = toFormatter(format.fold(), ((EsqlConfiguration) configuration()).locale());
            return dvrCtx -> new DateFormatConstantEvaluator(source(), fieldEvaluator.get(dvrCtx), formatter, dvrCtx);
        }
        var formatEvaluator = toEvaluator.apply(format);
        return dvrCtx -> new DateFormatEvaluator(
                source(),
                fieldEvaluator.get(dvrCtx),
                formatEvaluator.get(dvrCtx),
                ((EsqlConfiguration) configuration()).locale(),
                dvrCtx
        );
    }

    private static DateFormatter toFormatter(Object format, Locale locale) {
        DateFormatter result = format == null ? UTC_DATE_TIME_FORMATTER : DateFormatter.forPattern(((BytesRef) format).utf8ToString());
        return result.withLocale(locale);
    }

    @Override
    public Expression replaceChildren(List<Expression> newChildren) {
        return new DateFormat(source(), newChildren.get(0), newChildren.size() > 1 ? newChildren.get(1) : null, configuration());
    }

    @Override
    protected NodeInfo<? extends Expression> info() {
        Expression primaryArg = format != null ? format : field;
        Expression secondaryArg = format != null ? field : null;
        return NodeInfo.create(this, DateFormat::new, primaryArg, secondaryArg, configuration());
    }

    @Override
    public ScriptTemplate asScript() {
        throw new UnsupportedOperationException("functions do not support scripting");
    }
}
```

---

### Summary

**Rationale:**
The renamed parameter (`formatOrDate`) more clearly represents what is expected: either a format string or a date, depending on how the function is called. Similarly, using more descriptive local variable names in the `info()` method clarifies intent for maintainers and users of the API.

If you have further questions about this refactoring or need improvements in another aspect (like method extraction or inline documentation), please indicate!
