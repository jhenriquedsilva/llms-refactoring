23-04-2025, 19:56

There **are clear opportunities for extract method refactoring** in the provided code. In particular:

- The constructions of row data for test tables (like the lists passed to `TestValuesTableFactory.registerRowData(...)`) are somewhat complex and repeated.
- The transformation logic for the JSON plan manipulation (inside the lambda) is duplicated.
- Table creation logic with schema is repeated.
- Common setup code for test sources and sinks is spread.

We can extract helper methods to:
- Prepare test data for `Orders` and `LineOrders`.
- Encapsulate the JSON transformation with error handling.
- Encapsulate creation of source/sink tables.

Here is the **refactored code** with extracted methods and improved readability:

```java
package org.apache.flink.table.planner.runtime.stream.jsonplan;

import org.apache.flink.table.api.TableException;
import org.apache.flink.table.data.GenericRowData;
import org.apache.flink.table.data.StringData;
import org.apache.flink.table.planner.factories.TestValuesTableFactory;
import org.apache.flink.table.planner.utils.JsonPlanTestBase;
import org.apache.flink.table.planner.utils.JsonTestUtils;

import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;

import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;

class ConfigureOperatorLevelStateTtlJsonITCase extends JsonPlanTestBase {

    @Test
    void testDifferentStateTtlForDifferentOneInputOperator() throws Exception {
        String dataId = prepareOrdersTestData();
        createOrdersSourceTable(dataId);

        createTestNonInsertOnlyValuesSinkTable(
                "OrdersStats",
                "`buyer` STRING",
                "`ord_cnt` BIGINT",
                "`quantity_cnt` BIGINT",
                "`total_amount` DOUBLE");

        String sql =
            "INSERT INTO OrdersStats \n" +
            "SELECT buyer, COUNT(1) AS ord_cnt, SUM(quantity) AS quantity_cnt, SUM(amount) AS total_amount FROM (\n" +
            "SELECT *, ROW_NUMBER() OVER(PARTITION BY order_id, buyer, quantity, amount ORDER BY proctime() ASC) AS rk FROM Orders) tmp\n" +
            "WHERE rk = 1\n" +
            "GROUP BY buyer";

        compileSqlAndExecutePlan(sql,
                createJsonPlanTransformer(
                        new String[][] {
                                {"stream-exec-deduplicate", "0", "6000"},
                                {"stream-exec-group-aggregate", "0", "9000"}
                        })
        ).await();

        List<String> expected =
                Arrays.asList(
                        "+I[Tom, 2, 2, 229.8]",
                        "+I[Jerry, 1, 2, 99.9]",
                        "+I[Jerry, 1, 2, 99.9]",
                        "+I[Olivia, 2, 4, 1100.0]",
                        "+I[Michael, 1, 3, 599.9]");
        assertResult(expected, TestValuesTableFactory.getResultsAsStrings("OrdersStats"));
    }

    @Test
    void testDifferentStateTtlForSameTwoInputStreamOperator() throws Exception {
        innerTestRegularJoin(
                "INSERT INTO OrdersShipInfo \n"
                        + "SELECT a.order_id, a.line_order_id, b.ship_mode FROM Orders a JOIN LineOrders b ON a.line_order_id = b.line_order_id",
                createJsonPlanTransformer(
                        new String[][] {
                                {"stream-exec-join", "0", "3000"},
                                {"stream-exec-join", "1", "9000"}
                        }
                )
        );
    }

    @Test
    void testDifferentStateTtlThroughSqlHintForSameTwoInputStreamOperator() throws Exception {
        innerTestRegularJoin(
                "INSERT INTO OrdersShipInfo \n"
                        + "SELECT /*+ STATE_TTL('a' = '3s', 'b' = '9s') */\n"
                        + " a.order_id, a.line_order_id, b.ship_mode "
                        + "FROM Orders a JOIN LineOrders b ON a.line_order_id = b.line_order_id",
                json -> json);
    }

    private void innerTestRegularJoin(String sql, Function<String, String> jsonPlanTransformer)
            throws Exception {
        String leftTableDataId = prepareSimpleOrdersTestData();
        createOrdersJoinSourceTable(leftTableDataId);

        String rightTableDataId = prepareLineOrdersTestData();
        createLineOrdersSourceTable(rightTableDataId);

        createTestValuesSinkTable(
                "OrdersShipInfo", "`order_id` INT", "`line_order_id` INT", "`ship_mode` STRING");

        compileSqlAndExecutePlan(sql, jsonPlanTransformer).await();

        List<String> expected =
                Arrays.asList(
                        "+I[1, 1000002, TRUCK]", "+I[1, 1000004, RAIL]", "+I[1, 1000005, AIR]");
        assertResult(expected, TestValuesTableFactory.getResultsAsStrings("OrdersShipInfo"));
    }

    // Extracted methods

    private static Map<String, String> getProperties(
            String dataId, int sleepAfterElements, String sleepTime) {
        return new HashMap<String, String>() {
            {
                put("connector", "values");
                put("bounded", "false");
                put("register-internal-data", "true");
                put("source.sleep-after-elements", String.valueOf(sleepAfterElements));
                put("source.sleep-time", sleepTime);
                put("data-id", dataId);
            }
        };
    }

    // === Extracted Data Builders and Table Schema Creators ===

    private String prepareOrdersTestData() {
        return TestValuesTableFactory.registerRowData(
                Arrays.asList(
                        GenericRowData.of(1, StringData.fromString("Tom"), 1, 199.9d),
                        GenericRowData.of(2, StringData.fromString("Jerry"), 2, 99.9d),
                        GenericRowData.of(1, StringData.fromString("Tom"), 1, 199.9d),
                        GenericRowData.of(3, StringData.fromString("Tom"), 1, 29.9d),
                        GenericRowData.of(4, StringData.fromString("Olivia"), 1, 100d),
                        GenericRowData.of(4, StringData.fromString("Olivia"), 1, 100d),
                        GenericRowData.of(2, StringData.fromString("Jerry"), 2, 99.9d),
                        GenericRowData.of(5, StringData.fromString("Michael"), 3, 599.9d),
                        GenericRowData.of(6, StringData.fromString("Olivia"), 3, 1000d)
                )
        );
    }

    private void createOrdersSourceTable(String dataId) {
        createTestSourceTable(
                "Orders",
                new String[] {
                        "`order_id` INT", "`buyer` STRING", "`quantity` INT", "`amount` DOUBLE"
                },
                null,
                getProperties(dataId, 1, "2s"));
    }

    private String prepareSimpleOrdersTestData() {
        return TestValuesTableFactory.registerRowData(
                Arrays.asList(
                        GenericRowData.of(1, 1000001),
                        GenericRowData.of(1, 1000002),
                        GenericRowData.of(1, 1000003),
                        GenericRowData.of(1, 1000004),
                        GenericRowData.of(1, 1000005),
                        GenericRowData.of(2, 2000001)
                )
        );
    }

    private void createOrdersJoinSourceTable(String dataId) {
        createTestSourceTable(
                "Orders",
                new String[] {"`order_id` INT", "`line_order_id` INT"},
                null,
                getProperties(dataId, 1, "2s"));
    }

    private String prepareLineOrdersTestData() {
        return TestValuesTableFactory.registerRowData(
                Arrays.asList(
                        GenericRowData.of(2000001, StringData.fromString("TRUCK")),
                        GenericRowData.of(1000005, StringData.fromString("AIR")),
                        GenericRowData.of(1000001, StringData.fromString("SHIP")),
                        GenericRowData.of(1000002, StringData.fromString("TRUCK")),
                        GenericRowData.of(1000003, StringData.fromString("RAIL")),
                        GenericRowData.of(1000004, StringData.fromString("RAIL"))
                )
        );
    }

    private void createLineOrdersSourceTable(String dataId) {
        createTestSourceTable(
                "LineOrders",
                new String[] {"`line_order_id` INT", "`ship_mode` STRING"},
                null,
                getProperties(dataId, 2, "4s"));
    }

    // === Extracted JSON Plan Transformer Builder ===

    /**
     * Returns a Function to apply the given state metadata modifications to a JSON plan.
     * Each metadataConfig entry is of the form {execNodeType, inputIndex, ttlMs}.
     */
    private static Function<String, String> createJsonPlanTransformer(String[][] metadataConfig) {
        return json -> {
            try {
                JsonNode target = JsonTestUtils.readFromString(json);
                for (String[] entry : metadataConfig) {
                    String execNodeType = entry[0];
                    int inputIndex = Integer.parseInt(entry[1]);
                    long ttl = Long.parseLong(entry[2]);
                    JsonTestUtils.setExecNodeStateMetadata(target, execNodeType, inputIndex, ttl);
                }
                return JsonTestUtils.writeToString(target);
            } catch (IOException e) {
                throw new TableException("Cannot modify compiled json plan.", e);
            }
        };
    }
}
```

**Summary of Changes:**
- Extracted builders for test data and table creation.
- Extracted JSON plan transformer logic into a reusable method.
- Improved test code readability and maintainability.

This refactoring significantly improves clarity and allows for easier future extension/maintenance.