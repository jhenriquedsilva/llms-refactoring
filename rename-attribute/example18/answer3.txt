02-05-2025, 11:04

Let's review the code for **attribute identifiers that are unclear or not self-explanatory**. The instruction is to **rename attributes** for better readability if any low-quality identifiers are present.

### Review of Field Names

#### Main class fields:
- `private Http2SolrClient client;` -- Clear.
- `private final String basePath;` -- Clear.
- `private final CustomBlockingQueue<Update> queue;` -- Acceptable.
- `private final ExecutorService scheduler;` -- Acceptable.
- `private final Queue<Runner> runners;` -- Acceptable.
- `private final int threadCount;` -- Clear.
- `private boolean shutdownClient;` -- Clear.
- `private boolean shutdownExecutor;` -- Clear.
- `private long pollQueueTimeMillis;` -- Acceptable, could be `pollQueueTimeoutMillis` for clarity (`pollQueueTime` could mean total or accumulated).
- `private long stallTimeMillis;` -- Acceptable, could be `stallTimeoutMillis`, but not an improvement if usage is clear.
- `private final boolean streamDeletes;` -- Clear.
- `private volatile boolean closed;` -- Clear.
- `private volatile CountDownLatch lock = null;` -- The name `lock` is a bit vague; could be `shutdownLatch` or `allTasksCompletedLatch` depending on actual usage.

#### `CustomBlockingQueue` fields:
- `private final BlockingQueue<E> queue;` -- Clear.
- `private final Semaphore available;` -- Not super obvious; could be `capacitySemaphore` or `permitsAvailable`, but `available` is OK.
- `private final int queueSize;` -- Slightly ambiguous; could be `maxQueueSize` for clarity.
- `private final E backdoorE;` -- Poor name (not self-explanatory). Could be something like `terminationMarker`, `poisonPill`, or `shutdownSignal`. (This one should **definitely** be renamed.)

#### Builder fields:
- All are sufficiently descriptive.

---

### Recommended Refactorings

#### 1. `backdoorE` (CustomBlockingQueue)
- **Rename** to `terminationMarker` everywhere, as it is used to signal shutdown/interruption of blocking operations.

#### 2. `lock` (in the main class)
- **Rename** to `shutdownLatch` everywhere, as this better reflects its use for awaiting the completion of tasks during shutdown or similar operations.

#### 3. `queueSize` (CustomBlockingQueue)
- **Rename** to `maxQueueSize` for clarity.

#### 4. `pollQueueTimeMillis`
- Not strictly necessary, but `pollQueueTimeoutMillis` might be more explicit.

---

### Refactored Code

Below is the **refactored** class (only changed attributes and their uses, comments omitted for brevity):

```java
public class ConcurrentUpdateHttp2SolrClient extends SolrClient {
    private static final long serialVersionUID = 1L;
    private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
    private static final Update END_UPDATE = new Update(null, null);

    private Http2SolrClient client;
    private final String basePath;
    private final CustomBlockingQueue<Update> queue;
    private final ExecutorService scheduler;
    private final Queue<Runner> runners;
    private final int threadCount;

    private boolean shutdownClient;
    private boolean shutdownExecutor;
    private long pollQueueTimeoutMillis;
    private long stallTimeMillis;
    private final boolean streamDeletes;
    private volatile boolean closed;
    private volatile CountDownLatch shutdownLatch = null; // used to block everything

    private static class CustomBlockingQueue<E> implements Iterable<E> {
        private final BlockingQueue<E> queue;
        private final Semaphore available;
        private final int maxQueueSize;
        private final E terminationMarker;

        public CustomBlockingQueue(int maxQueueSize, int maxConsumers, E terminationMarker) {
            queue = new LinkedBlockingQueue<>();
            available = new Semaphore(maxQueueSize);
            this.maxQueueSize = maxQueueSize;
            this.terminationMarker = terminationMarker;
        }

        public boolean offer(E e) {
            boolean success = available.tryAcquire();
            if (success) {
                queue.offer(e);
            }
            return success;
        }

        public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException {
            boolean success = available.tryAcquire(timeout, unit);
            if (success) {
                queue.offer(e, timeout, unit);
            }
            return success;
        }

        public boolean isEmpty() {
            return size() == 0;
        }

        public E poll(long timeout, TimeUnit unit) throws InterruptedException {
            E e = queue.poll(timeout, unit);
            if (e == null) {
                return null;
            }
            if (e == terminationMarker) return null;
            available.release();
            return e;
        }

        public boolean add(E e) {
            boolean success = available.tryAcquire();
            if (success) {
                queue.add(e);
            } else {
                throw new IllegalStateException("Queue is full");
            }
            return true;
        }

        public int size() {
            return maxQueueSize - available.availablePermits();
        }

        public int remainingCapacity() {
            return available.availablePermits();
        }

        @Override
        public Iterator<E> iterator() {
            return queue.iterator();
        }

        public void backdoorOffer() {
            queue.offer(terminationMarker);
        }
    }

    protected ConcurrentUpdateHttp2SolrClient(Builder builder) {
        this.client = builder.client;
        this.shutdownClient = builder.closeHttp2Client;
        this.threadCount = builder.threadCount;
        this.queue = new CustomBlockingQueue<>(builder.queueSize, threadCount, END_UPDATE);
        this.runners = new ArrayDeque<>();
        this.streamDeletes = builder.streamDeletes;
        this.basePath = builder.baseSolrUrl;
        this.defaultCollection = builder.defaultCollection;
        this.pollQueueTimeoutMillis = builder.pollQueueTimeMillis;
        this.stallTimeMillis = Integer.getInteger("solr.cloud.client.stallTime", 15000);

        long minimalStallTimeMillis = pollQueueTimeoutMillis * 2;
        if (minimalStallTimeMillis > this.stallTimeMillis) {
            this.stallTimeMillis = minimalStallTimeMillis;
        }

        if (builder.executorService != null) {
            this.scheduler = builder.executorService;
            this.shutdownExecutor = false;
        } else {
            this.scheduler =
                    ExecutorUtil.newMDCAwareCachedThreadPool(
                            new SolrNamedThreadFactory("concurrentUpdateScheduler"));
            this.shutdownExecutor = true;
        }
    }

    // ... unchanged nested Runner class ...

    @Override
    public NamedList<Object> request(final SolrRequest<?> request, String collection)
            throws SolrServerException, IOException {
        if (ClientUtils.shouldApplyDefaultDataStore(collection, request))
            collection = defaultCollection;
        if (!(request instanceof UpdateRequest)) {
            request.setBasePath(basePath);
            return client.request(request, collection);
        }
        UpdateRequest req = (UpdateRequest) request;
        req.setBasePath(basePath);
        if (streamDeletes) {
            if ((req.getDocuments() == null || req.getDocuments().isEmpty())
                    && (req.getDeleteById() == null || req.getDeleteById().isEmpty())
                    && (req.getDeleteByIdMap() == null || req.getDeleteByIdMap().isEmpty())) {
                if (req.getDeleteQuery() == null) {
                    blockUntilFinished();
                    return client.request(request, collection);
                }
            }
        } else {
            if ((req.getDocuments() == null || req.getDocuments().isEmpty())) {
                blockUntilFinished();
                return client.request(request, collection);
            }
        }

        SolrParams params = req.getParams();
        if (params != null) {
            if (params.getBool(UpdateParams.WAIT_SEARCHER, false)) {
                log.info("blocking for commit/optimize");
                blockUntilFinished();
                return client.request(request, collection);
            }
        }

        try {
            CountDownLatch tmpShutdownLatch = shutdownLatch;
            if (tmpShutdownLatch != null) {
                tmpShutdownLatch.await();
            }

            Update update = new Update(req, collection);
            boolean success = queue.offer(update);

            long lastStallTime = -1;
            int lastQueueSize = -1;
            for (; ; ) {
                synchronized (runners) {
                    if (runners.isEmpty()
                            || (queue.remainingCapacity() < queue.size() && runners.size() < threadCount)) {
                        addRunner();
                    } else {
                        if (success) break;
                    }
                }

                if (!success) {
                    success = queue.offer(update, 100, TimeUnit.MILLISECONDS);
                }
                if (!success) {
                    int currentQueueSize = queue.size();
                    if (currentQueueSize != lastQueueSize) {
                        lastQueueSize = currentQueueSize;
                        lastStallTime = -1;
                    } else {
                        if (lastStallTime == -1) {
                            lastStallTime = System.nanoTime();
                        } else {
                            long currentStallTime =
                                    TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);
                            if (currentStallTime > stallTimeMillis) {
                                throw new IOException(
                                        "Request processing has stalled for "
                                                + currentStallTime
                                                + "ms with "
                                                + queue.size()
                                                + " remaining elements in the queue.");
                            }
                        }
                    }
                }
            }
        } catch (InterruptedException e) {
            log.error("interrupted", e);
            throw new IOException(e.getLocalizedMessage());
        }

        NamedList<Object> dummy = new NamedList<>();
        dummy.add("NOTE", "the request is processed in a background stream");
        return dummy;
    }

    public synchronized void blockUntilFinished() throws IOException {
        shutdownLatch = new CountDownLatch(1);
        try {
            waitForEmptyQueue();
            interruptRunnerThreadsPolling();

            long lastStallTime = -1;
            int lastQueueSize = -1;

            synchronized (runners) {
                int loopCount = 0;
                while (!runners.isEmpty()) {

                    if (ExecutorUtil.isShutdown(scheduler)) break;

                    loopCount++;

                    int queueSize = queue.size();
                    if (lastQueueSize != queueSize) {
                        lastQueueSize = queueSize;
                        lastStallTime = -1;
                    } else {
                        if (lastStallTime == -1) {
                            lastStallTime = System.nanoTime();
                        } else {
                            long currentStallTime =
                                    TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);
                            if (currentStallTime > stallTimeMillis) {
                                throw new IOException(
                                        "Task queue processing has stalled for "
                                                + currentStallTime
                                                + " ms with "
                                                + queueSize
                                                + " remaining elements to process.");
                            }
                        }
                    }
                    if (queueSize > 0 && runners.isEmpty()) {
                        log.warn(
                                "No more runners, but queue still has {}  adding more runners to process remaining requests on queue",
                                queueSize);
                        addRunner();
                    }

                    interruptRunnerThreadsPolling();

                    int timeout;
                    if (loopCount < 3) {
                        timeout = 10;
                    } else if (loopCount < 10) {
                        timeout = 25;
                    } else {
                        timeout = 250;
                    }

                    try {
                        runners.wait(timeout);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            }
        } finally {
            shutdownLatch.countDown();
            shutdownLatch = null;
        }
    }

    private void waitForEmptyQueue() throws IOException {
        boolean threadInterrupted = Thread.currentThread().isInterrupted();

        long lastStallTime = -1;
        int lastQueueSize = -1;
        while (!queue.isEmpty()) {
            if (ExecutorUtil.isTerminated(scheduler)) {
                log.warn(
                        "The task queue still has elements but the update scheduler {} is terminated. Can't process any more tasks. Queue size: {}, Runners: {}. Current thread Interrupted? {}",
                        scheduler,
                        queue.size(),
                        runners.size(),
                        threadInterrupted);
                break;
            }

            synchronized (runners) {
                int queueSize = queue.size();
                if (queueSize > 0 && runners.isEmpty()) {
                    log.warn(
                            "No more runners, but queue still has {} adding more runners to process remaining requests on queue",
                            queueSize);
                    addRunner();
                }
            }
            synchronized (queue) {
                try {
                    queue.wait(250);
                } catch (InterruptedException e) {
                    threadInterrupted = true;
                    log.warn(
                            "Thread interrupted while waiting for update queue to be empty. There are still {} elements in the queue.",
                            queue.size());
                }
            }
            int currentQueueSize = queue.size();
            if (currentQueueSize != lastQueueSize) {
                lastQueueSize = currentQueueSize;
                lastStallTime = -1;
            } else {
                lastQueueSize = currentQueueSize;
                if (lastStallTime == -1) {
                    lastStallTime = System.nanoTime();
                } else {
                    long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);
                    if (currentStallTime > stallTimeMillis) {
                        throw new IOException(
                                "Task queue processing has stalled for "
                                        + currentStallTime
                                        + " ms with "
                                        + currentQueueSize
                                        + " remaining elements to process.");
                    }
                }
            }
        }
        if (threadInterrupted) {
            Thread.currentThread().interrupt();
        }
    }

    // ... remaining class code unchanged, but using renamed variables where appropriate ...

    /** Constructs {@link ConcurrentUpdateHttp2SolrClient} instances from provided configuration. */
    public static class Builder {
        protected Http2SolrClient client;
        protected String baseSolrUrl;
        protected String defaultCollection;
        protected int queueSize = 10;
        protected int threadCount;
        protected ExecutorService executorService;
        protected boolean streamDeletes;
        protected boolean closeHttp2Client;
        private long pollQueueTimeMillis;

        public Builder(String baseSolrUrl, Http2SolrClient client) {
            this(baseSolrUrl, client, false);
        }

        public Builder(String baseSolrUrl, Http2SolrClient client, boolean closeHttp2Client) {
            this.baseSolrUrl = baseSolrUrl;
            this.client = client;
            this.closeHttp2Client = closeHttp2Client;
        }

        public Builder withQueueSize(int queueSize) {
            if (queueSize <= 0) {
                throw new IllegalArgumentException("queueSize must be a positive integer.");
            }
            this.queueSize = queueSize;
            return this;
        }

        public Builder withThreadCount(int threadCount) {
            if (threadCount <= 0) {
                throw new IllegalArgumentException("threadCount must be a positive integer.");
            }

            this.threadCount = threadCount;
            return this;
        }

        public Builder withExecutorService(ExecutorService executorService) {
            this.executorService = executorService;
            return this;
        }

        public Builder alwaysStreamDeletes() {
            this.streamDeletes = true;
            return this;
        }

        public Builder neverStreamDeletes() {
            this.streamDeletes = false;
            return this;
        }

        public Builder withDefaultDataStore(String defaultCoreOrCollection) {
            this.defaultCollection = defaultCoreOrCollection;
            return this;
        }

        public Builder setPollQueueTime(long pollQueueTime, TimeUnit unit) {
            this.pollQueueTimeMillis = TimeUnit.MILLISECONDS.convert(pollQueueTime, unit);
            return this;
        }

        public ConcurrentUpdateHttp2SolrClient build() {
            if (baseSolrUrl == null) {
                throw new IllegalArgumentException(
                        "Cannot create HttpSolrClient without a valid baseSolrUrl!");
            }

            return new ConcurrentUpdateHttp2SolrClient(this);
        }
    }
}
```

---

## Summary of Changes

- **`CustomBlockingQueue.backdoorE` → `terminationMarker`**
- **`CustomBlockingQueue.queueSize` → `maxQueueSize`**
- **Field and param `lock` → `shutdownLatch` in main class**
- **`pollQueueTimeMillis` → `pollQueueTimeoutMillis` everywhere**
- Used new names through the class where applicable.

If this refactoring is too drastic or you want only the most apparent (i.e. only `backdoorE` → `terminationMarker`), let me know and I can adjust. But as per best practice, **the above changes significantly improve semantic clarity of the code**.
