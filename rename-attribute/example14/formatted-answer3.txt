package org.apache.lucene.analysis.path;

import java.io.IOException;

import org.apache.lucene.analysis.Tokenizer;
import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
import org.apache.lucene.util.AttributeFactory;
import org.apache.lucene.util.IgnoreRandomChains;

@IgnoreRandomChains(reason = "broken offsets")
public class PathHierarchyTokenizer extends Tokenizer {

    public PathHierarchyTokenizer() {
        this(DEFAULT_BUFFER_SIZE, DEFAULT_DELIMITER, DEFAULT_DELIMITER, DEFAULT_SKIP);
    }

    public PathHierarchyTokenizer(int skip) {
        this(DEFAULT_BUFFER_SIZE, DEFAULT_DELIMITER, DEFAULT_DELIMITER, skip);
    }

    public PathHierarchyTokenizer(int bufferSize, char delimiter) {
        this(bufferSize, delimiter, delimiter, DEFAULT_SKIP);
    }

    public PathHierarchyTokenizer(char delimiter, char replacement) {
        this(DEFAULT_BUFFER_SIZE, delimiter, replacement, DEFAULT_SKIP);
    }

    public PathHierarchyTokenizer(char delimiter, char replacement, int skip) {
        this(DEFAULT_BUFFER_SIZE, delimiter, replacement, skip);
    }

    public PathHierarchyTokenizer(AttributeFactory factory, char delimiter, char replacement, int skip) {
        this(factory, DEFAULT_BUFFER_SIZE, delimiter, replacement, skip);
    }

    public PathHierarchyTokenizer(int bufferSize, char delimiter, char replacement, int skip) {
        this(DEFAULT_TOKEN_ATTRIBUTE_FACTORY, bufferSize, delimiter, replacement, skip);
    }

    public PathHierarchyTokenizer(AttributeFactory factory, int bufferSize, char delimiter, char replacement, int skip) {
        super(factory);
        if (bufferSize < 0) {
            throw new IllegalArgumentException("bufferSize cannot be negative");
        }
        if (skip < 0) {
            throw new IllegalArgumentException("skip cannot be negative");
        }
        charTermAttribute.resizeBuffer(bufferSize);
        this.delimiter = delimiter;
        this.replacement = replacement;
        this.skip = skip;
        currentTokenBuilder = new StringBuilder(bufferSize);
    }

    private static final int DEFAULT_BUFFER_SIZE = 1024;
    public static final char DEFAULT_DELIMITER = '/';
    public static final int DEFAULT_SKIP = 0;
    private final char delimiter;
    private final char replacement;
    private final int skip;
    private final CharTermAttribute charTermAttribute = addAttribute(CharTermAttribute.class);
    private final OffsetAttribute offsetAttribute = addAttribute(OffsetAttribute.class);
    private final PositionIncrementAttribute positionIncrementAttribute = addAttribute(PositionIncrementAttribute.class);
    private int startPosition = 0;
    private int segmentsSkipped = 0;
    private boolean pendingEndDelimiter = false;
    private StringBuilder currentTokenBuilder;
    private int charsRead = 0;

    @Override
    public final boolean incrementToken() throws IOException {
        clearAttributes();
        charTermAttribute.append(currentTokenBuilder);
        positionIncrementAttribute.setPositionIncrement(1);
        int length = 0;
        boolean added = false;
        if (pendingEndDelimiter) {
            charTermAttribute.append(replacement);
            length++;
            pendingEndDelimiter = false;
            added = true;
        }
        while (true) {
            int c = input.read();
            if (c >= 0) {
                charsRead++;
            } else {
                if (segmentsSkipped > skip) {
                    length += currentTokenBuilder.length();
                    charTermAttribute.setLength(length);
                    offsetAttribute.setOffset(correctOffset(startPosition), correctOffset(startPosition + length));
                    if (added) {
                        currentTokenBuilder.setLength(0);
                        currentTokenBuilder.append(charTermAttribute.buffer(), 0, length);
                    }
                    return added;
                } else {
                    return false;
                }
            }
            if (!added) {
                added = true;
                segmentsSkipped++;
                if (segmentsSkipped > skip) {
                    charTermAttribute.append(c == delimiter ? replacement : (char) c);
                    length++;
                } else {
                    startPosition++;
                }
            } else {
                if (c == delimiter) {
                    if (segmentsSkipped > skip) {
                        pendingEndDelimiter = true;
                        break;
                    }
                    segmentsSkipped++;
                    if (segmentsSkipped > skip) {
                        charTermAttribute.append(replacement);
                        length++;
                    } else {
                        startPosition++;
                    }
                } else {
                    if (segmentsSkipped > skip) {
                        charTermAttribute.append((char) c);
                        length++;
                    } else {
                        startPosition++;
                    }
                }
            }
        }
        length += currentTokenBuilder.length();
        charTermAttribute.setLength(length);
        offsetAttribute.setOffset(correctOffset(startPosition), correctOffset(startPosition + length));
        currentTokenBuilder.setLength(0);
        currentTokenBuilder.append(charTermAttribute.buffer(), 0, length);
        return true;
    }

    @Override
    public final void end() throws IOException {
        super.end();
        int finalOffset = correctOffset(charsRead);
        offsetAttribute.setOffset(finalOffset, finalOffset);
    }

    @Override
    public void reset() throws IOException {
        super.reset();
        currentTokenBuilder.setLength(0);
        charsRead = 0;
        pendingEndDelimiter = false;
        segmentsSkipped = 0;
        startPosition = 0;
    }
}