package com.puppycrawl.tools.checkstyle;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.puppycrawl.tools.checkstyle.api.AuditEvent;
import com.puppycrawl.tools.checkstyle.api.AuditListener;
import com.puppycrawl.tools.checkstyle.api.BeforeExecutionFileFilter;
import com.puppycrawl.tools.checkstyle.api.BeforeExecutionFileFilterSet;
import com.puppycrawl.tools.checkstyle.api.CheckstyleException;
import com.puppycrawl.tools.checkstyle.api.Configuration;
import com.puppycrawl.tools.checkstyle.api.Context;
import com.puppycrawl.tools.checkstyle.api.ExternalResourceHolder;
import com.puppycrawl.tools.checkstyle.api.FileSetCheck;
import com.puppycrawl.tools.checkstyle.api.FileText;
import com.puppycrawl.tools.checkstyle.api.Filter;
import com.puppycrawl.tools.checkstyle.api.FilterSet;
import com.puppycrawl.tools.checkstyle.api.MessageDispatcher;
import com.puppycrawl.tools.checkstyle.api.RootModule;
import com.puppycrawl.tools.checkstyle.api.SeverityLevel;
import com.puppycrawl.tools.checkstyle.api.SeverityLevelCounter;
import com.puppycrawl.tools.checkstyle.api.Violation;
import com.puppycrawl.tools.checkstyle.utils.CommonUtil;

public class Checker extends AbstractAutomaticBean implements MessageDispatcher, RootModule {

    public static final String EXCEPTION_MSG = "general.exception";

    private static final String EXTENSION_SEPARATOR = ".";

    private final Log log;

    private final SeverityLevelCounter counter = new SeverityLevelCounter(SeverityLevel.ERROR);

    private final List<AuditListener> listeners = new ArrayList<>();

    private final List<FileSetCheck> fileSetChecks = new ArrayList<>();

    private final BeforeExecutionFileFilterSet beforeExecutionFileFilters = new BeforeExecutionFileFilterSet();

    private final FilterSet filters = new FilterSet();

    private String basedir;

    @XdocsPropertyType(PropertyType.LOCALE_COUNTRY)
    private String localeCountry = Locale.getDefault().getCountry();

    @XdocsPropertyType(PropertyType.LOCALE_LANGUAGE)
    private String localeLanguage = Locale.getDefault().getLanguage();

    private ModuleFactory moduleFactory;

    private ClassLoader moduleClassLoader;

    private Context childContext;

    private String[] fileExtensions;

    private SeverityLevel severity = SeverityLevel.ERROR;

    private String charset = StandardCharsets.UTF_8.name();

    @XdocsPropertyType(PropertyType.FILE)
    private PropertyCacheFile cacheFile;

    private boolean haltOnException = true;

    private int tabWidth = CommonUtil.DEFAULT_TAB_WIDTH;

    public Checker() {
        addListener(counter);
        log = LogFactory.getLog(Checker.class);
    }

    public void setCacheFile(String fileName) throws IOException {
        final Configuration configuration = getConfiguration();
        cacheFile = new PropertyCacheFile(configuration, fileName);
        cacheFile.load();
    }

    public void removeBeforeExecutionFileFilter(BeforeExecutionFileFilter filter) {
        beforeExecutionFileFilters.removeBeforeExecutionFileFilter(filter);
    }

    public void removeFilter(Filter filter) {
        filters.removeFilter(filter);
    }

    @Override
    public void destroy() {
        listeners.clear();
        fileSetChecks.clear();
        beforeExecutionFileFilters.clear();
        filters.clear();
        if (cacheFile != null) {
            try {
                cacheFile.persist();
            } catch (IOException ex) {
                throw new IllegalStateException("Unable to persist cache file.", ex);
            }
        }
    }

    public void removeListener(AuditListener listener) {
        listeners.remove(listener);
    }

    public void setBasedir(String basedir) {
        this.basedir = basedir;
    }

    @Override
    public int process(List<File> files) throws CheckstyleException {
        if (cacheFile != null) {
            cacheFile.putExternalResources(getExternalResourceLocations());
        }
        fireAuditStarted();
        for (final FileSetCheck fsc : fileSetChecks) {
            fsc.beginProcessing(charset);
        }
        final List<File> targetFiles = files.stream().filter(file -> CommonUtil.matchesFileExtension(file, fileExtensions)).collect(Collectors.toList());
        processFiles(targetFiles);
        fileSetChecks.forEach(FileSetCheck::finishProcessing);
        fileSetChecks.forEach(FileSetCheck::destroy);
        final int errorCount = counter.getCount();
        fireAuditFinished();
        return errorCount;
    }

    private Set<String> getExternalResourceLocations() {
        return Stream.concat(fileSetChecks.stream(), filters.getFilters().stream()).filter(ExternalResourceHolder.class::isInstance).flatMap(resource -> {
            return ((ExternalResourceHolder) resource).getExternalResourceLocations().stream();
        }).collect(Collectors.toSet());
    }

    private void fireAuditStarted() {
        final AuditEvent event = new AuditEvent(this);
        for (final AuditListener listener : listeners) {
            listener.auditStarted(event);
        }
    }

    private void fireAuditFinished() {
        final AuditEvent event = new AuditEvent(this);
        for (final AuditListener listener : listeners) {
            listener.auditFinished(event);
        }
    }

    private void processFiles(List<File> files) throws CheckstyleException {
        for (final File file : files) {
            String fileName = null;
            try {
                fileName = file.getAbsolutePath();
                final long timestamp = file.lastModified();
                if (cacheFile != null && cacheFile.isInCache(fileName, timestamp) || !acceptFileStarted(fileName)) {
                    continue;
                }
                if (cacheFile != null) {
                    cacheFile.put(fileName, timestamp);
                }
                fireFileStarted(fileName);
                final SortedSet<Violation> fileMessages = processFile(file);
                fireErrors(fileName, fileMessages);
                fireFileFinished(fileName);
            } catch (Exception ex) {
                if (fileName != null && cacheFile != null) {
                    cacheFile.remove(fileName);
                }
                throw new CheckstyleException("Exception was thrown while processing " + file.getPath(), ex);
            } catch (Error error) {
                if (fileName != null && cacheFile != null) {
                    cacheFile.remove(fileName);
                }
                throw new Error("Error was thrown while processing " + file.getPath(), error);
            }
        }
    }

    private SortedSet<Violation> processFile(File file) throws CheckstyleException {
        final SortedSet<Violation> fileMessages = new TreeSet<>();
        try {
            final FileText theText = new FileText(file.getAbsoluteFile(), charset);
            for (final FileSetCheck fsc : fileSetChecks) {
                fileMessages.addAll(fsc.process(file, theText));
            }
        } catch (final IOException ioe) {
            log.debug("IOException occurred.", ioe);
            fileMessages.add(new Violation(1, Definitions.CHECKSTYLE_BUNDLE, EXCEPTION_MSG, new String[]{ioe.getMessage()}, null, getClass(), null));
        } catch (Exception ex) {
            if (haltOnException) {
                throw ex;
            }
            log.debug("Exception occurred.", ex);
            final StringWriter sw = new StringWriter();
            final PrintWriter pw = new PrintWriter(sw, true);
            ex.printStackTrace(pw);
            fileMessages.add(new Violation(1, Definitions.CHECKSTYLE_BUNDLE, EXCEPTION_MSG, new String[]{sw.getBuffer().toString()}, null, getClass(), null));
        }
        return fileMessages;
    }

    private boolean acceptFileStarted(String fileName) {
        final String stripped = CommonUtil.relativizeAndNormalizePath(basedir, fileName);
        return beforeExecutionFileFilters.accept(stripped);
    }

    @Override
    public void fireFileStarted(String fileName) {
        final String stripped = CommonUtil.relativizeAndNormalizePath(basedir, fileName);
        final AuditEvent event = new AuditEvent(this, stripped);
        for (final AuditListener listener : listeners) {
            listener.fileStarted(event);
        }
    }

    @Override
    public void fireErrors(String fileName, SortedSet<Violation> errors) {
        final String stripped = CommonUtil.relativizeAndNormalizePath(basedir, fileName);
        boolean hasNonFilteredViolations = false;
        for (final Violation element : errors) {
            final AuditEvent event = new AuditEvent(this, stripped, element);
            if (filters.accept(event)) {
                hasNonFilteredViolations = true;
                for (final AuditListener listener : listeners) {
                    listener.addError(event);
                }
            }
        }
        if (hasNonFilteredViolations && cacheFile != null) {
            cacheFile.remove(fileName);
        }
    }

    @Override
    public void fireFileFinished(String fileName) {
        final String stripped = CommonUtil.relativizeAndNormalizePath(basedir, fileName);
        final AuditEvent event = new AuditEvent(this, stripped);
        for (final AuditListener listener : listeners) {
            listener.fileFinished(event);
        }
    }

    @Override
    protected void finishLocalSetup() throws CheckstyleException {
        final Locale locale = new Locale(localeLanguage, localeCountry);
        LocalizedMessage.setLocale(locale);
        if (moduleFactory == null) {
            if (moduleClassLoader == null) {
                throw new CheckstyleException("if no custom moduleFactory is set, " + "moduleClassLoader must be specified");
            }
            final Set<String> packageNames = PackageNamesLoader.getPackageNames(moduleClassLoader);
            moduleFactory = new PackageObjectFactory(packageNames, moduleClassLoader);
        }
        final DefaultContext context = new DefaultContext();
        context.add("charset", charset);
        context.add("moduleFactory", moduleFactory);
        context.add("severity", severity.getName());
        context.add("basedir", basedir);
        context.add("tabWidth", String.valueOf(tabWidth));
        childContext = context;
    }

    @Override
    protected void setupChild(Configuration childConf) throws CheckstyleException {
        final String name = childConf.getName();
        final Object child;
        try {
            child = moduleFactory.createModule(name);
            if (child instanceof AbstractAutomaticBean) {
                final AbstractAutomaticBean bean = (AbstractAutomaticBean) child;
                bean.contextualize(childContext);
                bean.configure(childConf);
            }
        } catch (final CheckstyleException ex) {
            throw new CheckstyleException("cannot initialize module " + name + " - " + ex.getMessage(), ex);
        }
        if (child instanceof FileSetCheck) {
            final FileSetCheck fsc = (FileSetCheck) child;
            fsc.init();
            addFileSetCheck(fsc);
        } else if (child instanceof BeforeExecutionFileFilter) {
            final BeforeExecutionFileFilter filter = (BeforeExecutionFileFilter) child;
            addBeforeExecutionFileFilter(filter);
        } else if (child instanceof Filter) {
            final Filter filter = (Filter) child;
            addFilter(filter);
        } else if (child instanceof AuditListener) {
            final AuditListener listener = (AuditListener) child;
            addListener(listener);
        } else {
            throw new CheckstyleException(name + " is not allowed as a child in Checker");
        }
    }

    public void addFileSetCheck(FileSetCheck fileSetCheck) {
        fileSetCheck.setMessageDispatcher(this);
        fileSetChecks.add(fileSetCheck);
    }

    public void addBeforeExecutionFileFilter(BeforeExecutionFileFilter filter) {
        beforeExecutionFileFilters.addBeforeExecutionFileFilter(filter);
    }

    public void addFilter(Filter filter) {
        filters.addFilter(filter);
    }

    @Override
    public final void addListener(AuditListener listener) {
        listeners.add(listener);
    }

    public final void setFileExtensions(String... extensions) {
        if (extensions != null) {
            fileExtensions = new String[extensions.length];
            for (int i = 0; i < extensions.length; i++) {
                final String extension = extensions[i];
                if (extension.startsWith(EXTENSION_SEPARATOR)) {
                    fileExtensions[i] = extension;
                } else {
                    fileExtensions[i] = EXTENSION_SEPARATOR + extension;
                }
            }
        }
    }

    public void setModuleFactory(ModuleFactory moduleFactory) {
        this.moduleFactory = moduleFactory;
    }

    public void setLocaleCountry(String localeCountry) {
        this.localeCountry = localeCountry;
    }

    public void setLocaleLanguage(String localeLanguage) {
        this.localeLanguage = localeLanguage;
    }

    public final void setSeverity(String severity) {
        this.severity = SeverityLevel.getInstance(severity);
    }

    @Override
    public final void setModuleClassLoader(ClassLoader moduleClassLoader) {
        this.moduleClassLoader = moduleClassLoader;
    }

    public void setCharset(String charset) throws UnsupportedEncodingException {
        if (!Charset.isSupported(charset)) {
            final String message = "unsupported charset: '" + charset + "'";
            throw new UnsupportedEncodingException(message);
        }
        this.charset = charset;
    }

    public void setHaltOnException(boolean haltOnException) {
        this.haltOnException = haltOnException;
    }

    public final void setTabWidth(int tabWidth) {
        this.tabWidth = tabWidth;
    }

    public void clearCache() {
        if (cacheFile != null) {
            cacheFile.reset();
        }
    }

    private String getStrippedFileName(String fileName) {
        return CommonUtil.relativizeAndNormalizePath(basedir, fileName);
    }

    private boolean acceptFileStarted(String fileName) {
        final String stripped = getStrippedFileName(fileName);
        return beforeExecutionFileFilters.accept(stripped);
    }

    @Override
    public void fireFileStarted(String fileName) {
        final String stripped = getStrippedFileName(fileName);
        final AuditEvent event = new AuditEvent(this, stripped);
        for (final AuditListener listener : listeners) {
            listener.fileStarted(event);
        }
    }

    @Override
    public void fireErrors(String fileName, SortedSet<Violation> errors) {
        final String stripped = getStrippedFileName(fileName);
        boolean hasNonFilteredViolations = false;
        for (final Violation element : errors) {
            final AuditEvent event = new AuditEvent(this, stripped, element);
            if (filters.accept(event)) {
                hasNonFilteredViolations = true;
                for (final AuditListener listener : listeners) {
                    listener.addError(event);
                }
            }
        }
        if (hasNonFilteredViolations && cacheFile != null) {
            cacheFile.remove(fileName);
        }
    }

    @Override
    public void fireFileFinished(String fileName) {
        final String stripped = getStrippedFileName(fileName);
        final AuditEvent event = new AuditEvent(this, stripped);
        for (final AuditListener listener : listeners) {
            listener.fileFinished(event);
        }
    }
}