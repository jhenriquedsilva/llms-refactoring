01-05-2025, 09:52

Yes, there **are several opportunities for Extract Variable Refactoring** in this code to improve readability and reduce repetition:

**Key Opportunities:**
1. `inputStream.readAllBytes()` is called **twice**, which is both repetitive and inefficient (it may exhaust the stream accidentally).
2. The error message string `"The file path provided for upload, '" + singleFilePath + "', is not valid."` and `"The file type provided for upload, '" + singleFilePath + "', is forbidden for use in configSets."` both use `"singleFilePath"` for error messages; while not deeply repetitive, storing it in a variable for error messages increases clarity.
3. Expressions like `req.getPathTemplateValues().getOrDefault(FILEPATH_PLACEHOLDER, "")` are a little clunky â€” assigning to a variable early improves readability (already done here).

**Refactored Version:**
Below is the class with variables extracted for **the result of `inputStream.readAllBytes()`** and some minor other improvements to simplify code logic and improve reusability/readability.

```java
package org.apache.solr.handler.configsets;

import static org.apache.solr.client.solrj.SolrRequest.METHOD.PUT;
import static org.apache.solr.security.PermissionNameProvider.Name.CONFIG_EDIT_PERM;

import java.io.InputStream;
import org.apache.solr.api.EndPoint;
import org.apache.solr.common.SolrException;
import org.apache.solr.common.cloud.ZkMaintenanceUtils;
import org.apache.solr.common.params.ConfigSetParams;
import org.apache.solr.core.CoreContainer;
import org.apache.solr.request.SolrQueryRequest;
import org.apache.solr.response.SolrQueryResponse;
import org.apache.solr.util.FileTypeMagicUtil;

/**
 * V2 API for adding or updating a single file within a configset.
 *
 * <p>This API (PUT /v2/cluster/configs/configsetName/someFilePath) is analogous to the v1
 * /admin/configs?action=UPLOAD&amp;filePath=someFilePath command.
 */
public class UploadConfigSetFileAPI extends ConfigSetAPIBase {

    public static final String CONFIGSET_NAME_PLACEHOLDER =
            UploadConfigSetAPI.CONFIGSET_NAME_PLACEHOLDER;
    public static final String FILEPATH_PLACEHOLDER = "*";

    private static final String API_PATH =
            "/cluster/configs/{" + CONFIGSET_NAME_PLACEHOLDER + "}/" + FILEPATH_PLACEHOLDER;

    public UploadConfigSetFileAPI(CoreContainer coreContainer) {
        super(coreContainer);
    }

    @EndPoint(method = PUT, path = API_PATH, permission = CONFIG_EDIT_PERM)
    public void updateConfigSetFile(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {
        ensureConfigSetUploadEnabled();

        final String configSetName = req.getPathTemplateValues().get("name");
        boolean overwritesExisting = configSetService.checkConfigExists(configSetName);
        boolean requestIsTrusted =
                isTrusted(req.getUserPrincipal(), coreContainer.getAuthenticationPlugin());

        // Get upload parameters

        String singleFilePath = req.getPathTemplateValues().getOrDefault(FILEPATH_PLACEHOLDER, "");
        boolean allowOverwrite = req.getParams().getBool(ConfigSetParams.OVERWRITE, true);
        boolean cleanup = req.getParams().getBool(ConfigSetParams.CLEANUP, false);
        final InputStream inputStream = ensureNonEmptyInputStream(req);

        String fixedSingleFilePath = singleFilePath;
        if (!fixedSingleFilePath.isEmpty() && fixedSingleFilePath.charAt(0) == '/') {
            fixedSingleFilePath = fixedSingleFilePath.substring(1);
        }

        // Extract reading inputStream to a variable to avoid repeating and consuming the stream twice
        final byte[] fileBytes = inputStream.readAllBytes();

        // Error messages and repeated expressions stored in final variables for clarity
        final String invalidPathErrorMsg = "The file path provided for upload, '" + singleFilePath + "', is not valid.";
        final String forbiddenFileTypeErrorMsg = "The file type provided for upload, '" + singleFilePath + "', is forbidden for use in configSets.";
        final String cleanupNotAllowedMsg = "ConfigSet uploads do not allow cleanup=true when file path is used.";

        if (fixedSingleFilePath.isEmpty()) {
            throw new SolrException(
                    SolrException.ErrorCode.BAD_REQUEST,
                    invalidPathErrorMsg);
        } else if (ZkMaintenanceUtils.isFileForbiddenInConfigSets(fixedSingleFilePath)
                || FileTypeMagicUtil.isFileForbiddenInConfigset(fileBytes)) {
            throw new SolrException(
                    SolrException.ErrorCode.BAD_REQUEST,
                    forbiddenFileTypeErrorMsg);
        } else if (cleanup) {
            // Cleanup is not allowed while using singleFilePath upload
            throw new SolrException(
                    SolrException.ErrorCode.BAD_REQUEST,
                    cleanupNotAllowedMsg
            );
        } else {
            // Create a node for the configuration in config
            // For creating the baseNode, the cleanup parameter is only allowed to be true when
            // singleFilePath is not passed.
            createBaseNode(configSetService, overwritesExisting, requestIsTrusted, configSetName);
            configSetService.uploadFileToConfig(configSetName, fixedSingleFilePath, fileBytes, allowOverwrite);
        }
    }
}
```

**Summary of Extracted Variables:**
- `fileBytes` is extracted so that the stream is only read once and reused.
- Error messages as variables for reusability and clarity.
- Check for '/' in `fixedSingleFilePath` only if string is not empty.

**Benefits:**
- Prevents accidentally consuming the stream twice (which would cause a bug).
- Increases clarity of error messages and logic.
- Makes the code easier to maintain and extend.

**If you need even more granular refactoring (e.g., extracting repeated key names, etc.), just ask!**

Levenshtein edit-distance: 788
Compiles