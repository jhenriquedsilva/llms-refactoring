29-04-2025, 21:46

**Analysis of Extract Variable Refactoring Opportunities**

Extract variable refactoring focuses on improving code readability by introducing well-named variables to simplify complex or nested expressions, especially as method arguments or when the same computation is repeated.

In your code, there are several long or nested expressions, especially as method parameters, that could benefit from extract variable refactoring:

1. **Repeated and Nested Expressions**:
   - Example:
     ```java
     final Object result = source.getLoadQueryInfluencers().fromInternalFetchProfile(
       CascadingFetchProfile.REFRESH,
       () -> doRefresh( event, source, object, entry, persister, lazyInitializer, id, persistenceContext )
     );
     ```
   - Example:
     ```java
     final String role = ((CollectionType) type).getRole();
     final CollectionPersister collectionPersister = metamodel.getCollectionDescriptor( role );
     final CollectionDataAccess cache = collectionPersister.getCacheAccessStrategy();
     final Object ck = cache.generateCacheKey(
       id,
       collectionPersister,
       factory,
       source.getTenantIdentifier()
     );
     // â€¦ etc
     ```

2. **Long parameters with inline calls:**
   - Example:
     ```java
     persister.getIdentifier( object, event.getSession() ),
     infoString( persister, id, source.getFactory() )
     ```

**Recommended Extract Variable Applications:**

1. **Extract `fromInternalFetchProfile` result into a variable for readability.**
2. **Extract `generateCacheKey` calls into variables before use as parameters.**
3. **Extract parameters when calling logging methods for clearer intent.**
4. **Extract inner complex or repeated expressions (e.g., `source.getFactory()`) into local variables when reused.**

---

**Refactored Code**

Below is your refactored `DefaultRefreshEventListener` with relevant extract variable refactorings applied for readability.

```java
package org.hibernate.event.internal;

import org.hibernate.HibernateException;
import org.hibernate.LockMode;
import org.hibernate.LockOptions;
import org.hibernate.NonUniqueObjectException;
import org.hibernate.TransientObjectException;
import org.hibernate.UnresolvableObjectException;
import org.hibernate.cache.spi.access.CollectionDataAccess;
import org.hibernate.cache.spi.access.EntityDataAccess;
import org.hibernate.cache.spi.access.SoftLock;
import org.hibernate.engine.internal.Cascade;
import org.hibernate.engine.internal.CascadePoint;
import org.hibernate.engine.spi.ActionQueue;
import org.hibernate.engine.spi.CascadingActions;
import org.hibernate.engine.spi.EntityEntry;
import org.hibernate.engine.spi.EntityKey;
import org.hibernate.engine.spi.PersistenceContext;
import org.hibernate.engine.spi.SessionFactoryImplementor;
import org.hibernate.event.spi.EventSource;
import org.hibernate.event.spi.RefreshContext;
import org.hibernate.event.spi.RefreshEvent;
import org.hibernate.event.spi.RefreshEventListener;
import org.hibernate.internal.CoreLogging;
import org.hibernate.internal.CoreMessageLogger;
import org.hibernate.loader.ast.spi.CascadingFetchProfile;
import org.hibernate.metamodel.spi.MappingMetamodelImplementor;
import org.hibernate.persister.collection.CollectionPersister;
import org.hibernate.persister.entity.EntityPersister;
import org.hibernate.proxy.HibernateProxy;
import org.hibernate.proxy.LazyInitializer;
import org.hibernate.type.CollectionType;
import org.hibernate.type.CompositeType;
import org.hibernate.type.Type;

import static org.hibernate.pretty.MessageHelper.infoString;

/**
 * Defines the default refresh event listener used by hibernate for refreshing entities
 * in response to generated refresh events.
 *
 * @author Steve Ebersole
 */
public class DefaultRefreshEventListener implements RefreshEventListener {
    private static final CoreMessageLogger LOG = CoreLogging.messageLogger( DefaultRefreshEventListener.class );

    public void onRefresh(RefreshEvent event) throws HibernateException {
        onRefresh( event, RefreshContext.create() );
    }

    /**
     * Handle the given refresh event.
     *
     * @param event The refresh event to be handled.
     */
    public void onRefresh(RefreshEvent event, RefreshContext refreshedAlready) {
        final EventSource source = event.getSession();
        final PersistenceContext persistenceContext = source.getPersistenceContextInternal();
        final Object object = event.getObject();
        if ( persistenceContext.reassociateIfUninitializedProxy( object ) ) {

            final LazyInitializer lazyInitializer = HibernateProxy.extractLazyInitializer( object );
            final String entityName = lazyInitializer.getEntityName();
            final EntityPersister persister = source.getEntityPersister( entityName, object );
            final Object identifier = persister.getIdentifier( object, event.getSession() );
            refresh(
                    event,
                    null,
                    source,
                    persister,
                    lazyInitializer,
                    null,
                    identifier,
                    persistenceContext
            );

            if ( isTransient( event, source, object )  ) {
                source.setReadOnly( object, source.isDefaultReadOnly() );
            }
        }
        else {
            final Object entity = persistenceContext.unproxyAndReassociate( object );
            if ( refreshedAlready.add( entity) ) {
                refresh( event, refreshedAlready, entity );
            }
            else {
                LOG.trace( "Already refreshed" );
            }
        }
    }

    private static boolean isTransient(RefreshEvent event, EventSource source, Object object) {
        final String entityName = event.getEntityName();
        return entityName != null ? !source.contains( entityName, object) : !source.contains(object);
    }

    private static void refresh(RefreshEvent event, RefreshContext refreshedAlready, Object object) {
        final EventSource source = event.getSession();
        final PersistenceContext persistenceContext = source.getPersistenceContextInternal();
        final EntityEntry entry = persistenceContext.getEntry( object );

        final EntityPersister persister;
        final Object id;
        if ( entry == null ) {
            //refresh() does not pass an entityName
            final String entityName = event.getEntityName();
            persister = source.getEntityPersister( entityName, object );
            id = persister.getIdentifier( object, event.getSession() );
            if ( id == null ) {
                throw new TransientObjectException( "transient instance passed to refresh");
            }
            if ( LOG.isTraceEnabled() ) {
                final String info = infoString( persister, id, source.getFactory() );
                LOG.tracev(
                        "Refreshing transient {0}",
                        info
                );
            }
            final EntityKey key = source.generateEntityKey( id, persister );
            if ( persistenceContext.getEntry( key ) != null ) {
                throw new NonUniqueObjectException( id, persister.getEntityName() );
            }
        }
        else {
            if ( LOG.isTraceEnabled() ) {
                final String info = infoString( entry.getPersister(), entry.getId(), source.getFactory() );
                LOG.tracev(
                        "Refreshing ",
                        info
                );
            }
            if ( !entry.isExistsInDatabase() ) {
                throw new UnresolvableObjectException(
                        entry.getId(),
                        "this instance does not yet exist as a row in the database"
                );
            }
            persister = entry.getPersister();
            id = entry.getId();
        }

        // cascade the refresh prior to refreshing this entity
        Cascade.cascade(
                CascadingActions.REFRESH,
                CascadePoint.BEFORE_REFRESH,
                source,
                persister,
                object,
                refreshedAlready
        );

        if ( entry != null ) {
            final EntityKey key = source.generateEntityKey( id, persister );
            persistenceContext.removeEntity( key );
            if ( persister.hasCollections() ) {
                new EvictVisitor( source, object ).process( object, persister );
            }
        }

        evictEntity( object, persister, id, source );
        evictCachedCollections( persister, id, source );

        refresh( event, object, source, persister, null, entry, id, persistenceContext );
    }

    private static void refresh(
            RefreshEvent event,
            Object object,
            EventSource source,
            EntityPersister persister,
            LazyInitializer lazyInitializer,
            EntityEntry entry,
            Object id,
            PersistenceContext persistenceContext) {

        // EXTRACTED: lambda for doRefresh for readability
        RunnableWithResult<Object> doRefreshLambda = () ->
                doRefresh( event, source, object, entry, persister, lazyInitializer, id, persistenceContext );

        final Object result = source.getLoadQueryInfluencers().fromInternalFetchProfile(
                CascadingFetchProfile.REFRESH,
                doRefreshLambda
        );
        UnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );
    }

    private static void evictEntity(Object object, EntityPersister persister, Object id, EventSource source) {
        if ( persister.canWriteToCache() ) {
            Object previousVersion = null;
            if ( persister.isVersionPropertyGenerated() ) {
                // we need to grab the version value from the entity, otherwise
                // we have issues with generated-version entities that may have
                // multiple actions queued during the same flush
                previousVersion = persister.getVersion( object );
            }
            final EntityDataAccess cache = persister.getCacheAccessStrategy();
            final String tenantIdentifier = source.getTenantIdentifier();
            final Object cacheKey = cache.generateCacheKey(
                    id,
                    persister,
                    source.getFactory(),
                    tenantIdentifier
            );
            final SoftLock lock = cache.lockItem( source, cacheKey, previousVersion );
            cache.remove( source, cacheKey );
            source.getActionQueue().registerProcess( (success, session) -> cache.unlockItem( session, cacheKey, lock ) );
        }
    }

    private static Object doRefresh(
            RefreshEvent event,
            EventSource source,
            Object object,
            EntityEntry entry,
            EntityPersister persister,
            LazyInitializer lazyInitializer,
            Object id,
            PersistenceContext persistenceContext) {
        // Handle the requested lock-mode (if one) in relation to the entry's (if one) current lock-mode
        LockOptions lockOptionsToUse = event.getLockOptions();
        final LockMode requestedLockMode = lockOptionsToUse.getLockMode();
        final LockMode postRefreshLockMode;
        if ( entry != null ) {
            final LockMode currentLockMode = entry.getLockMode();
            if ( currentLockMode.greaterThan( requestedLockMode ) ) {
                // the requested lock-mode is less restrictive than the current one
                //		- pass along the current lock-mode (after accounting for WRITE)
                lockOptionsToUse = event.getLockOptions().makeCopy();
                if ( currentLockMode == LockMode.WRITE
                        || currentLockMode == LockMode.PESSIMISTIC_WRITE
                        || currentLockMode == LockMode.PESSIMISTIC_READ ) {
                    // our transaction should already hold the exclusive lock on
                    // the underlying row - so READ should be sufficient.
                    //
                    // in fact, this really holds true for any current lock-mode that indicates we
                    // hold an exclusive lock on the underlying row - but we *need* to handle
                    // WRITE specially because the Loader/Locker mechanism does not allow for WRITE
                    // locks
                    lockOptionsToUse.setLockMode( LockMode.READ );
                    // and prepare to reset the entry lock-mode to the previous lock mode after
                    // the refresh completes
                    postRefreshLockMode = currentLockMode;
                }
                else {
                    lockOptionsToUse.setLockMode( currentLockMode );
                    postRefreshLockMode = null;
                }
            }
            else {
                postRefreshLockMode = null;
            }
        }
        else {
            postRefreshLockMode = null;
        }

        final Object result = persister.load( id, object, lockOptionsToUse, source );
        if ( result != null ) {
            // apply `postRefreshLockMode`, if needed
            if ( postRefreshLockMode != null ) {
                // if we get here, there was a previous entry, and we need to re-set its lock-mode
                //		- however, the refresh operation actually creates a new entry, so get it
                persistenceContext.getEntry( result ).setLockMode( postRefreshLockMode );
            }

            source.setReadOnly( result, isReadOnly( entry, persister, lazyInitializer, source ) );
        }
        return result;
    }

    private static boolean isReadOnly(
            EntityEntry entry,
            EntityPersister persister,
            LazyInitializer lazyInitializer,
            EventSource source) {
        // Keep the same read-only/modifiable setting for the entity that it had before refreshing;
        // If it was transient, then set it to the default for the source.
        if ( !persister.isMutable() ) {
            return true;
        }
        else if ( entry != null ) {
            return entry.isReadOnly();
        }
        else if ( lazyInitializer != null ) {
            return lazyInitializer.isReadOnly();
        }
        else {
            return source.isDefaultReadOnly();
        }
    }

    private static void evictCachedCollections(EntityPersister persister, Object id, EventSource source) {
        final Type[] propertyTypes = persister.getPropertyTypes();
        evictCachedCollections( propertyTypes, id, source );
    }

    private static void evictCachedCollections(Type[] types, Object id, EventSource source)
            throws HibernateException {
        final ActionQueue actionQueue = source.getActionQueue();
        final SessionFactoryImplementor factory = source.getFactory();
        final MappingMetamodelImplementor metamodel = factory.getRuntimeMetamodels().getMappingMetamodel();
        final String tenantIdentifier = source.getTenantIdentifier();
        for ( Type type : types ) {
            if ( type.isCollectionType() ) {
                final CollectionType collectionType = (CollectionType) type;
                final String role = collectionType.getRole();
                final CollectionPersister collectionPersister = metamodel.getCollectionDescriptor( role );
                if ( collectionPersister.hasCache() ) {
                    final CollectionDataAccess cache = collectionPersister.getCacheAccessStrategy();
                    final Object cacheKey = cache.generateCacheKey(
                            id,
                            collectionPersister,
                            factory,
                            tenantIdentifier
                    );
                    final SoftLock lock = cache.lockItem( source, cacheKey, null );
                    cache.remove( source, cacheKey );
                    actionQueue.registerProcess( (success, session) -> cache.unlockItem( session, cacheKey, lock ) );
                }
            }
            else if ( type.isComponentType() ) {
                final CompositeType compositeType = (CompositeType) type;
                evictCachedCollections( compositeType.getSubtypes(), id, source );
            }
        }
    }

    /**
     * Functional interface for extracting lambda as variable for readability.
     */
    @FunctionalInterface
    private interface RunnableWithResult<T> extends java.util.function.Supplier<T> {
        @Override T get();
    }
}
```

**Summary of changes (Extract Variable Refactoring):**

- Introduced variables for expressions repeated or deeply nested, such as `source.getTenantIdentifier()`, `persister.getIdentifier(...)`, `infoString(...)`, `cache.generateCacheKey(...)`, etc.
- Extracted lambdas or method arguments with complex content as local variables before use.
- Provided a small functional interface at the end for clarity in lambda extraction inside `refresh`.

**Conclusion:**
This improves readability and maintainability of the code per extract variable refactoring best practices.

Levenshtein edit-distance: 1308
Compiles