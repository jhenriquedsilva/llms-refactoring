28-05-2025, 19:39

**Analysis:**

Reviewing the provided code, we see the following repeating patterns:

- **Creation of `ClosedInputStream` in a try-with-resources block**, performing one or multiple assertions that the result of various `read` methods is `EOF`.
- **Similar assertion statements**: `assertEquals(EOF, cis.read(...), ...)` or `assertEquals(EOF, cis.read(...))`.

While the assertions themselves differ (they use different overloads of `read`), the setup and assertion logic is repetitive. An **Extract Method Refactoring** can be done to avoid code duplication in test setup and assertion, thus improving maintainability and readability.

**Refactoring Approach:**

1. **Extract a Helper Method**
   Introduce one or more private helper methods, such as:
   - `private void assertReadReturnsEOF(ClosedInputStream cis)`
   - `private void assertReadArrayReturnsEOF(ClosedInputStream cis, int arraySize)`
   - Or a more general method: `private void assertRead(ClosedInputStream cis, int expected, Supplier<Integer> readOperation)`
   For simplicity, we can start by extracting the repeated test logic for read methods.

2. **Apply in Each Test**
   Replace repeated try-with-resources blocks and assertions with calls to these helpers.

**Refactored Class:**

```java
package org.apache.commons.io.input;

import static org.apache.commons.io.IOUtils.EOF;
import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;
import java.util.function.IntSupplier;

/**
 * Tests {@link ClosedInputStream}.
 */
public class ClosedInputStreamTest {

    @Test
    public void testRead() throws Exception {
        try (ClosedInputStream cis = new ClosedInputStream()) {
            assertReadReturnsEOF(cis, "read()");
        }
    }

    @Test
    public void testReadArray() throws Exception {
        try (ClosedInputStream cis = new ClosedInputStream()) {
            assertReadArrayReturnsEOF(cis, new byte[4096]);
            assertReadArrayReturnsEOF(cis, new byte[1]);
            assertReadArrayReturnsEOF(cis, new byte[0]);
        }
    }

    @Test
    public void testReadArrayIndex() throws Exception {
        try (ClosedInputStream cis = new ClosedInputStream()) {
            assertReadArrayIndexReturnsEOF(cis, new byte[4096], 0, 1);
            assertReadArrayIndexReturnsEOF(cis, new byte[1], 0, 1);
            assertReadArrayIndexReturnsEOF(cis, new byte[0], 0, 0);
        }
    }

    @Test
    public void testSingleton() throws Exception {
        try (@SuppressWarnings("deprecation")
             ClosedInputStream cis = ClosedInputStream.CLOSED_INPUT_STREAM) {
            assertReadReturnsEOF(cis, "read()");
        }
        try (ClosedInputStream cis = ClosedInputStream.INSTANCE) {
            assertReadReturnsEOF(cis, "read()");
        }
    }

    private void assertReadReturnsEOF(ClosedInputStream cis, String message) throws Exception {
        assertEquals(EOF, cis.read(), message);
    }

    private void assertReadArrayReturnsEOF(ClosedInputStream cis, byte[] arr) throws Exception {
        assertEquals(EOF, cis.read(arr));
    }

    private void assertReadArrayIndexReturnsEOF(ClosedInputStream cis, byte[] arr, int off, int len) throws Exception {
        assertEquals(EOF, cis.read(arr, off, len));
    }
}
```

**Summary of Refactoring:**

- **Extracted assertion logic** into private helper methods to avoid duplication.
- **Improved maintainability and readability** by reducing repeated code in test methods.

**Optional:** For more advanced refactoring, you could use `IntSupplier` or `Executable` to generalize the assertion methods further. However, the above version keeps things explicit and clear for a test class.

---

If you need a more advanced refactoring or have a specific style requirement, feel free to specify!

Levenshtein edit-distance: 845
Compiles
Tests pass