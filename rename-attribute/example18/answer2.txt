02-05-2025, 11:06

Certainly! After reviewing the class, below are **potential Rename Attribute refactoring opportunities**, focused on improving code readability by using more descriptive names. Here are the main candidates:

### Candidates for Rename Attribute Refactoring

#### 1. **`CustomBlockingQueue<E>#available`**
- **Current Name:** `available`
- **Recommended Name:** `availablePermits`
- **Reason:** It's a `Semaphore` limiting queue size, so explicitly naming it this way communicates its semantics well.

#### 2. **`CustomBlockingQueue<E>#backdoorE`**
- **Current Name:** `backdoorE`
- **Recommended Name:** `specialSentinelElement`
- **Reason:** The `backdoorE` serves as a special signaling value. Using `specialSentinelElement` is more self-explanatory.

#### 3. **`CustomBlockingQueue<E>#queue`**
- **Current Name:** `queue`
- **Recommended Name:** `internalQueue`
- **Reason:** To distinguish it from enclosing classes' `queue` attributes.

#### 4. **`CustomBlockingQueue<E>#queueSize`**
- **Current Name:** `queueSize`
- **Recommended Name:** `capacity`
- **Reason:** It's the fixed capacity, `capacity` is a Java convention in collections.

#### 5. **`ConcurrentUpdateHttp2SolrClient#lock`**
- **Current Name:** `lock`
- **Recommended Name:** `blockUntilFinishedLatch`
- **Reason:** `lock` is vague; `blockUntilFinishedLatch` is explicit about its use.

#### 6. **`ConcurrentUpdateHttp2SolrClient#queue`**
- **Current Name:** `queue`
- **Recommended Name:** `updateQueue`
- **Reason:** To clarify that it's a queue of update requests (not, for example, connections or threads).

#### 7. **`ConcurrentUpdateHttp2SolrClient#scheduler`**
- **Current Name:** `scheduler`
- **Recommended Name:** `updateExecutor`
- **Reason:** Since it's actually an executor for update commands, not a timer/cron-style scheduler.

#### 8. **`ConcurrentUpdateHttp2SolrClient#runners`**
- **Current Name:** `runners`
- **Recommended Name:** `updateRunners`
- **Reason:** Clarifies that these are not generic runners, but specifically for updates.


----

Based on this, here is your **refactored class** with improved attribute names (***attribute declarations, constructors, method bodies, local variables, and all references updated accordingly***):

---

```java
package org.apache.solr.client.solrj.impl;

import java.io.IOException;
import java.io.InputStream;
import java.lang.invoke.MethodHandles;
import java.util.ArrayDeque;
import java.util.Iterator;
import java.util.Queue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import org.apache.solr.client.solrj.SolrClient;
import org.apache.solr.client.solrj.SolrRequest;
import org.apache.solr.client.solrj.SolrServerException;
import org.apache.solr.client.solrj.impl.ConcurrentUpdateSolrClient.Update;
import org.apache.solr.client.solrj.request.UpdateRequest;
import org.apache.solr.client.solrj.util.ClientUtils;
import org.apache.solr.common.SolrException;
import org.apache.solr.common.params.SolrParams;
import org.apache.solr.common.params.UpdateParams;
import org.apache.solr.common.util.ExecutorUtil;
import org.apache.solr.common.util.NamedList;
import org.apache.solr.common.util.SolrNamedThreadFactory;
import org.eclipse.jetty.client.api.Response;
import org.eclipse.jetty.client.util.InputStreamResponseListener;
import org.eclipse.jetty.http.HttpStatus;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

/**
 * @lucene.experimental
 */
public class ConcurrentUpdateHttp2SolrClient extends SolrClient {
    private static final long serialVersionUID = 1L;
    private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
    private static final Update END_UPDATE = new Update(null, null);

    private Http2SolrClient client;
    private final String basePath;
    private final CustomBlockingQueue<Update> updateQueue;
    private final ExecutorService updateExecutor;
    private final Queue<Runner> updateRunners;
    private final int threadCount;

    private boolean shutdownClient;
    private boolean shutdownExecutor;
    private long pollQueueTimeMillis;
    private long stallTimeMillis;
    private final boolean streamDeletes;
    private volatile boolean closed;
    private volatile CountDownLatch blockUntilFinishedLatch = null; // used to block everything

    private static class CustomBlockingQueue<E> implements Iterable<E> {
        private final BlockingQueue<E> internalQueue;
        private final Semaphore availablePermits;
        private final int capacity;
        private final E specialSentinelElement;

        public CustomBlockingQueue(int capacity, int maxConsumers, E specialSentinelElement) {
            internalQueue = new LinkedBlockingQueue<>();
            availablePermits = new Semaphore(capacity);
            this.capacity = capacity;
            this.specialSentinelElement = specialSentinelElement;
        }

        public boolean offer(E e) {
            boolean success = availablePermits.tryAcquire();
            if (success) {
                internalQueue.offer(e);
            }
            return success;
        }

        public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException {
            boolean success = availablePermits.tryAcquire(timeout, unit);
            if (success) {
                internalQueue.offer(e, timeout, unit);
            }
            return success;
        }

        public boolean isEmpty() {
            return size() == 0;
        }

        public E poll(long timeout, TimeUnit unit) throws InterruptedException {
            E e = internalQueue.poll(timeout, unit);
            if (e == null) {
                return null;
            }
            if (e == specialSentinelElement) return null;
            availablePermits.release();
            return e;
        }

        public boolean add(E e) {
            boolean success = availablePermits.tryAcquire();
            if (success) {
                internalQueue.add(e);
            } else {
                throw new IllegalStateException("Queue is full");
            }
            return true;
        }

        public int size() {
            return capacity - availablePermits.availablePermits();
        }

        public int remainingCapacity() {
            return availablePermits.availablePermits();
        }

        @Override
        public Iterator<E> iterator() {
            return internalQueue.iterator();
        }

        public void backdoorOffer() {
            internalQueue.offer(specialSentinelElement);
        }
    }

    protected ConcurrentUpdateHttp2SolrClient(Builder builder) {
        this.client = builder.client;
        this.shutdownClient = builder.closeHttp2Client;
        this.threadCount = builder.threadCount;
        this.updateQueue = new CustomBlockingQueue<>(builder.queueSize, threadCount, END_UPDATE);
        this.updateRunners = new ArrayDeque<>();
        this.streamDeletes = builder.streamDeletes;
        this.basePath = builder.baseSolrUrl;
        this.defaultCollection = builder.defaultCollection;
        this.pollQueueTimeMillis = builder.pollQueueTimeMillis;
        this.stallTimeMillis = Integer.getInteger("solr.cloud.client.stallTime", 15000);

        // make sure the stall time is larger than the polling time
        // to give a chance for the queue to change
        long minimalStallTimeMillis = pollQueueTimeMillis * 2;
        if (minimalStallTimeMillis > this.stallTimeMillis) {
            this.stallTimeMillis = minimalStallTimeMillis;
        }

        if (builder.executorService != null) {
            this.updateExecutor = builder.executorService;
            this.shutdownExecutor = false;
        } else {
            this.updateExecutor =
                    ExecutorUtil.newMDCAwareCachedThreadPool(
                            new SolrNamedThreadFactory("concurrentUpdateScheduler"));
            this.shutdownExecutor = true;
        }
    }

    /** Opens a connection and sends everything... */
    class Runner implements Runnable {

        @Override
        public void run() {
            log.debug("starting runner: {}", this);
            // This loop is so we can continue if an element was added to the queue after the last runner
            // exited.
            for (; ; ) {
                try {

                    sendUpdateStream();

                } catch (Throwable e) {
                    if (e instanceof OutOfMemoryError) {
                        throw (OutOfMemoryError) e;
                    }
                    handleError(e);
                } finally {
                    synchronized (updateRunners) {
                        // check to see if anything else was added to the queue
                        if (updateRunners.size() == 1 && !updateQueue.isEmpty() && !ExecutorUtil.isShutdown(updateExecutor)) {
                            // If there is something else to process, keep last runner alive by staying in the
                            // loop.
                        } else {
                            updateRunners.remove(this);
                            if (updateRunners.isEmpty()) {
                                // notify anyone waiting in blockUntilFinished
                                updateRunners.notifyAll();
                            }
                            break;
                        }
                    }
                }
            }

            log.debug("finished: {}", this);
        }

        //
        // Pull from the queue multiple times and streams over a single connection.
        // Exits on exception, interruption, or an empty queue to pull from.
        //
        @SuppressWarnings({"unchecked"})
        void sendUpdateStream() throws Exception {

            try {
                while (!updateQueue.isEmpty()) {
                    InputStream rspBody = null;
                    try {
                        Update update;
                        notifyQueueAndRunnersIfEmptyQueue();
                        update = updateQueue.poll(pollQueueTimeMillis, TimeUnit.MILLISECONDS);

                        if (update == null) {
                            break;
                        }

                        InputStreamResponseListener responseListener = null;
                        try (Http2SolrClient.OutStream out =
                                     client.initOutStream(basePath, update.getRequest(), update.getCollection())) {
                            Update upd = update;
                            while (upd != null) {
                                UpdateRequest req = upd.getRequest();
                                if (!out.belongToThisStream(req, upd.getCollection())) {
                                    // Request has different params or destination core/collection, return to queue
                                    updateQueue.add(upd);
                                    break;
                                }
                                client.send(out, upd.getRequest(), upd.getCollection());
                                out.flush();

                                notifyQueueAndRunnersIfEmptyQueue();
                                upd = updateQueue.poll(pollQueueTimeMillis, TimeUnit.MILLISECONDS);
                            }
                            responseListener = out.getResponseListener();
                        }

                        Response response =
                                responseListener.get(client.getIdleTimeout(), TimeUnit.MILLISECONDS);
                        rspBody = responseListener.getInputStream();

                        int statusCode = response.getStatus();
                        if (statusCode != HttpStatus.OK_200) {
                            StringBuilder msg = new StringBuilder();
                            msg.append(response.getReason());
                            msg.append("\n\n\n");
                            msg.append("request: ").append(basePath);

                            SolrException solrExc;
                            NamedList<String> metadata = null;
                            // parse out the metadata from the SolrException
                            try {
                                String encoding = "UTF-8"; // default
                                NamedList<Object> resp = client.getParser().processResponse(rspBody, encoding);
                                NamedList<Object> error = (NamedList<Object>) resp.get("error");
                                if (error != null) {
                                    metadata = (NamedList<String>) error.get("metadata");
                                    String remoteMsg = (String) error.get("msg");
                                    if (remoteMsg != null) {
                                        msg.append("\nRemote error message: ");
                                        msg.append(remoteMsg);
                                    }
                                }
                            } catch (Exception exc) {
                                // don't want to fail to report error if parsing the response fails
                                log.warn("Failed to parse error response from {} due to: ", basePath, exc);
                            } finally {
                                solrExc =
                                        new BaseHttpSolrClient.RemoteSolrException(
                                                basePath, statusCode, msg.toString(), null);
                                if (metadata != null) {
                                    solrExc.setMetadata(metadata);
                                }
                            }

                            handleError(solrExc);
                        } else {
                            onSuccess(response, rspBody);
                        }

                    } finally {
                        try {
                            consumeFully(rspBody);
                        } catch (Exception e) {
                            log.error("Error consuming and closing http response stream.", e);
                        }
                        notifyQueueAndRunnersIfEmptyQueue();
                    }
                }
            } catch (InterruptedException e) {
                log.error("Interrupted on polling from queue", e);
            }
        }
    }

    private void consumeFully(InputStream is) {
        if (is != null) {
            try (is) {
                // make sure the stream is full read
                is.skip(is.available());
                while (is.read() != -1) {}
            } catch (UnsupportedOperationException e) {
                // nothing to do then
            } catch (IOException e) {
                // quiet
            }
        }
    }

    private void notifyQueueAndRunnersIfEmptyQueue() {
        if (updateQueue.size() == 0) {
            synchronized (updateQueue) {
                // queue may be empty
                updateQueue.notifyAll();
            }
            synchronized (updateRunners) {
                // we notify runners too - if there is a high queue poll time and this is the update
                // that emptied the queue, we make an attempt to avoid the 250ms timeout in
                // blockUntilFinished
                updateRunners.notifyAll();
            }
        }
    }

    // *must* be called with updateRunners monitor held, e.g. synchronized(updateRunners){ addRunner() }
    private void addRunner() {
        MDC.put(
                "ConcurrentUpdateHttp2SolrClient.url",
                String.valueOf(client.getBaseURL())); // MDC can't have null value
        try {
            Runner r = new Runner();
            updateRunners.add(r);
            try {
                // this can throw an exception if the scheduler has been shutdown, but that should
                // be fine.
                updateExecutor.execute(r);
            } catch (RuntimeException e) {
                updateRunners.remove(r);
                throw e;
            }
        } finally {
            MDC.remove("ConcurrentUpdateHttp2SolrClient.url");
        }
    }

    @Override
    public NamedList<Object> request(final SolrRequest<?> request, String collection)
            throws SolrServerException, IOException {
        if (ClientUtils.shouldApplyDefaultDataStore(collection, request))
            collection = defaultCollection;
        if (!(request instanceof UpdateRequest)) {
            request.setBasePath(basePath);
            return client.request(request, collection);
        }
        UpdateRequest req = (UpdateRequest) request;
        req.setBasePath(basePath);
        // this happens for commit...
        if (streamDeletes) {
            if ((req.getDocuments() == null || req.getDocuments().isEmpty())
                    && (req.getDeleteById() == null || req.getDeleteById().isEmpty())
                    && (req.getDeleteByIdMap() == null || req.getDeleteByIdMap().isEmpty())) {
                if (req.getDeleteQuery() == null) {
                    blockUntilFinished();
                    return client.request(request, collection);
                }
            }
        } else {
            if ((req.getDocuments() == null || req.getDocuments().isEmpty())) {
                blockUntilFinished();
                return client.request(request, collection);
            }
        }

        SolrParams params = req.getParams();
        if (params != null) {
            // check if it is waiting for the searcher
            if (params.getBool(UpdateParams.WAIT_SEARCHER, false)) {
                log.info("blocking for commit/optimize");
                blockUntilFinished(); // empty the queue
                return client.request(request, collection);
            }
        }

        try {
            CountDownLatch tmpLatch = blockUntilFinishedLatch;
            if (tmpLatch != null) {
                tmpLatch.await();
            }

            Update update = new Update(req, collection);
            boolean success = updateQueue.offer(update);

            long lastStallTime = -1;
            int lastQueueSize = -1;
            for (; ; ) {
                synchronized (updateRunners) {
                    // see if queue is half full and we can add more runners
                    // special case: if only using a threadCount of 1 and the queue
                    // is filling up, allow 1 add'l runner to help process the queue
                    if (updateRunners.isEmpty()
                            || (updateQueue.remainingCapacity() < updateQueue.size() && updateRunners.size() < threadCount)) {
                        // We need more runners, so start a new one.
                        addRunner();
                    } else {
                        // break out of the retry loop if we added the element to the queue
                        // successfully, *and*
                        // while we are still holding the updateRunners lock to prevent race
                        // conditions.
                        if (success) break;
                    }
                }

                // Retry to add to the queue w/o the updateRunners lock held (else we risk
                // temporary deadlock)
                // This retry could also fail because
                // 1) existing runners were not able to take off any new elements in the
                // queue
                // 2) the queue was filled back up since our last try
                // If we succeed, the queue may have been completely emptied, and all
                // runners stopped.
                // In all cases, we should loop back to the top to see if we need to
                // start more runners.
                //
                if (!success) {
                    success = updateQueue.offer(update, 100, TimeUnit.MILLISECONDS);
                }
                if (!success) {
                    // stall prevention
                    int currentQueueSize = updateQueue.size();
                    if (currentQueueSize != lastQueueSize) {
                        // there's still some progress in processing the queue - not stalled
                        lastQueueSize = currentQueueSize;
                        lastStallTime = -1;
                    } else {
                        if (lastStallTime == -1) {
                            // mark a stall but keep trying
                            lastStallTime = System.nanoTime();
                        } else {
                            long currentStallTime =
                                    TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);
                            if (currentStallTime > stallTimeMillis) {
                                throw new IOException(
                                        "Request processing has stalled for "
                                                + currentStallTime
                                                + "ms with "
                                                + updateQueue.size()
                                                + " remaining elements in the queue.");
                            }
                        }
                    }
                }
            }
        } catch (InterruptedException e) {
            log.error("interrupted", e);
            throw new IOException(e.getLocalizedMessage());
        }

        // RETURN A DUMMY result
        NamedList<Object> dummy = new NamedList<>();
        dummy.add("NOTE", "the request is processed in a background stream");
        return dummy;
    }

    public synchronized void blockUntilFinished() throws IOException {
        blockUntilFinishedLatch = new CountDownLatch(1);
        try {

            waitForEmptyQueue();
            interruptRunnerThreadsPolling();

            long lastStallTime = -1;
            int lastQueueSize = -1;

            synchronized (updateRunners) {

                // NOTE: if the executor is shut down, updateRunners may never become empty (a scheduled task may
                // never be run, which means it would never remove itself from the updateRunners list. This is why
                // we don't wait forever and periodically check if the updateExecutor is shutting down.
                int loopCount = 0;
                while (!updateRunners.isEmpty()) {

                    if (ExecutorUtil.isShutdown(updateExecutor)) break;

                    loopCount++;

                    // Need to check if the queue is empty before really considering this is finished
                    // (SOLR-4260)
                    int queueSize = updateQueue.size();
                    // stall prevention
                    if (lastQueueSize != queueSize) {
                        // init, or no stall
                        lastQueueSize = queueSize;
                        lastStallTime = -1;
                    } else {
                        if (lastStallTime == -1) {
                            lastStallTime = System.nanoTime();
                        } else {
                            long currentStallTime =
                                    TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);
                            if (currentStallTime > stallTimeMillis) {
                                throw new IOException(
                                        "Task queue processing has stalled for "
                                                + currentStallTime
                                                + " ms with "
                                                + queueSize
                                                + " remaining elements to process.");
                                //                Thread.currentThread().interrupt();
                                //                break;
                            }
                        }
                    }
                    if (queueSize > 0 && updateRunners.isEmpty()) {
                        // TODO: can this still happen?
                        log.warn(
                                "No more runners, but queue still has {}  adding more runners to process remaining requests on queue",
                                queueSize);
                        addRunner();
                    }

                    interruptRunnerThreadsPolling();

                    // try to avoid the worst case wait timeout
                    // without bad spin
                    int timeout;
                    if (loopCount < 3) {
                        timeout = 10;
                    } else if (loopCount < 10) {
                        timeout = 25;
                    } else {
                        timeout = 250;
                    }

                    try {
                        updateRunners.wait(timeout);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            }
        } finally {
            blockUntilFinishedLatch.countDown();
            blockUntilFinishedLatch = null;
        }
    }

    private void waitForEmptyQueue() throws IOException {
        boolean threadInterrupted = Thread.currentThread().isInterrupted();

        long lastStallTime = -1;
        int lastQueueSize = -1;
        while (!updateQueue.isEmpty()) {
            if (ExecutorUtil.isTerminated(updateExecutor)) {
                log.warn(
                        "The task queue still has elements but the update scheduler {} is terminated. Can't process any more tasks. Queue size: {}, Runners: {}. Current thread Interrupted? {}",
                        updateExecutor,
                        updateQueue.size(),
                        updateRunners.size(),
                        threadInterrupted);
                break;
            }

            synchronized (updateRunners) {
                int queueSize = updateQueue.size();
                if (queueSize > 0 && updateRunners.isEmpty()) {
                    log.warn(
                            "No more runners, but queue still has {} adding more runners to process remaining requests on queue",
                            queueSize);
                    addRunner();
                }
            }
            synchronized (updateQueue) {
                try {
                    updateQueue.wait(250);
                } catch (InterruptedException e) {
                    // If we set the thread as interrupted again, the next time the wait it's called i t's
                    // going to return immediately
                    threadInterrupted = true;
                    log.warn(
                            "Thread interrupted while waiting for update queue to be empty. There are still {} elements in the queue.",
                            updateQueue.size());
                }
            }
            int currentQueueSize = updateQueue.size();
            // stall prevention
            if (currentQueueSize != lastQueueSize) {
                lastQueueSize = currentQueueSize;
                lastStallTime = -1;
            } else {
                lastQueueSize = currentQueueSize;
                if (lastStallTime == -1) {
                    lastStallTime = System.nanoTime();
                } else {
                    long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);
                    if (currentStallTime > stallTimeMillis) {
                        throw new IOException(
                                "Task queue processing has stalled for "
                                        + currentStallTime
                                        + " ms with "
                                        + currentQueueSize
                                        + " remaining elements to process.");
                        //            threadInterrupted = true;
                        //            break;
                    }
                }
            }
        }
        if (threadInterrupted) {
            Thread.currentThread().interrupt();
        }
    }

    public void handleError(Throwable ex) {
        log.error("error", ex);
    }

    /**
     * Intended to be used as an extension point for doing post processing after a request completes.
     *
     * @param respBody the body of the response, subclasses must not close this stream.
     */
    public void onSuccess(Response resp, InputStream respBody) {
        // no-op by design, override to add functionality
    }

    @Override
    public synchronized void close() {
        if (closed) {
            interruptRunnerThreadsPolling();
            return;
        }
        closed = true;

        try {
            if (shutdownExecutor) {
                updateExecutor.shutdown();
                interruptRunnerThreadsPolling();
                try {
                    if (!updateExecutor.awaitTermination(60, TimeUnit.SECONDS)) {
                        updateExecutor.shutdownNow();
                        if (!updateExecutor.awaitTermination(60, TimeUnit.SECONDS))
                            log.error("ExecutorService did not terminate");
                    }
                } catch (InterruptedException ie) {
                    updateExecutor.shutdownNow();
                    Thread.currentThread().interrupt();
                }
            } else {
                interruptRunnerThreadsPolling();
            }
        } finally {
            if (shutdownClient) client.close();
        }
    }

    private void interruptRunnerThreadsPolling() {
        synchronized (updateRunners) {
            for (Runner ignored : updateRunners) {
                updateQueue.backdoorOffer();
            }
        }
    }

    public void shutdownNow() {
        if (closed) {
            return;
        }
        closed = true;

        if (shutdownExecutor) {
            updateExecutor.shutdown();
            interruptRunnerThreadsPolling();
            updateExecutor.shutdownNow(); // Cancel currently executing tasks
            try {
                if (!updateExecutor.awaitTermination(30, TimeUnit.SECONDS))
                    log.error("ExecutorService did not terminate");
            } catch (InterruptedException ie) {
                updateExecutor.shutdownNow();
                Thread.currentThread().interrupt();
            }
        } else {
            interruptRunnerThreadsPolling();
        }
    }

    /** Constructs {@link ConcurrentUpdateHttp2SolrClient} instances from provided configuration. */
    public static class Builder {
        protected Http2SolrClient client;
        protected String baseSolrUrl;
        protected String defaultCollection;
        protected int queueSize = 10;
        protected int threadCount;
        protected ExecutorService executorService;
        protected boolean streamDeletes;
        protected boolean closeHttp2Client;
        private long pollQueueTimeMillis;

        public Builder(String baseSolrUrl, Http2SolrClient client) {
            this(baseSolrUrl, client, false);
        }

        public Builder(String baseSolrUrl, Http2SolrClient client, boolean closeHttp2Client) {
            this.baseSolrUrl = baseSolrUrl;
            this.client = client;
            this.closeHttp2Client = closeHttp2Client;
        }

        /**
         * The maximum number of requests buffered by the SolrClient's internal queue before being
         * processed by background threads.
         *
         * <p>This value should be carefully paired with the number of queue-consumer threads. A queue
         * with a maximum size set too high may require more memory. A queue with a maximum size set too
         * low may suffer decreased throughput as {@link
         * ConcurrentUpdateHttp2SolrClient#request(SolrRequest)} calls block waiting to add requests to
         * the queue.
         *
         * <p>If not set, this defaults to 10.
         *
         * @see #withThreadCount(int)
         */
        public Builder withQueueSize(int queueSize) {
            if (queueSize <= 0) {
                throw new IllegalArgumentException("queueSize must be a positive integer.");
            }
            this.queueSize = queueSize;
            return this;
        }

        /**
         * The maximum number of threads used to empty {@link ConcurrentUpdateHttp2SolrClient}s queue.
         *
         * <p>Threads are created when documents are added to the client's internal queue and exit when
         * no updates remain in the queue.
         *
         * <p>This value should be carefully paired with the maximum queue capacity. A client with too
         * few threads may suffer decreased throughput as the queue fills up and {@link
         * ConcurrentUpdateHttp2SolrClient#request(SolrRequest)} calls block waiting to add requests to
         * the queue.
         */
        public Builder withThreadCount(int threadCount) {
            if (threadCount <= 0) {
                throw new IllegalArgumentException("threadCount must be a positive integer.");
            }

            this.threadCount = threadCount;
            return this;
        }

        /**
         * Provides the {@link ExecutorService} for the created client to use when servicing the
         * update-request queue.
         */
        public Builder withExecutorService(ExecutorService executorService) {
            this.executorService = executorService;
            return this;
        }

        /**
         * Configures created clients to always stream delete requests.
         *
         * <p>Streamed deletes are put into the update-queue and executed like any other update request.
         */
        public Builder alwaysStreamDeletes() {
            this.streamDeletes = true;
            return this;
        }

        /**
         * Configures created clients to not stream delete requests.
         *
         * <p>With this option set when the created ConcurrentUpdateHttp2SolrClient sents a delete
         * request it will first will lock the queue and block until all queued updates have been sent,
         * and then send the delete request.
         */
        public Builder neverStreamDeletes() {
            this.streamDeletes = false;
            return this;
        }

        /** Sets a default data store for core- or collection-based requests. */
        public Builder withDefaultDataStore(String defaultCoreOrCollection) {
            this.defaultCollection = defaultCoreOrCollection;
            return this;
        }

        /**
         * @param pollQueueTime time for an open connection to wait for updates when the queue is empty.
         */
        public Builder setPollQueueTime(long pollQueueTime, TimeUnit unit) {
            this.pollQueueTimeMillis = TimeUnit.MILLISECONDS.convert(pollQueueTime, unit);
            return this;
        }

        /**
         * Create a {@link ConcurrentUpdateHttp2SolrClient} based on the provided configuration options.
         */
        public ConcurrentUpdateHttp2SolrClient build() {
            if (baseSolrUrl == null) {
                throw new IllegalArgumentException(
                        "Cannot create HttpSolrClient without a valid baseSolrUrl!");
            }

            return new ConcurrentUpdateHttp2SolrClient(this);
        }
    }
}
```

---

**Summary of Changes:**
- All identified attributes have been renamed for clarity and readability.
- All usages have been updated accordingly, including attribute definitions, constructors, and method bodies.

**No business logic has been altered, only attribute names.**

---

If you would like any further refinements or focus on other kinds of refactoring, please let me know!

Compiles