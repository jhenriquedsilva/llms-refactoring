01-05-2025, 11:06

### Review of Rename Parameter Refactoring Opportunities

The code you provided is for a test class `TestNMClient`. For rename parameter refactoring, we are looking for parameter names (in methods, especially those visible to users/outside classes) that are of low quality (i.e., not self-explanatory, confusing, overly generic, misleading, or violating naming conventions).

#### Main Parameter Issues in Your Code

Below are several areas where parameter names could be improved:

- **Short single-character names (`i` in `testContainer`, etc.)** — Acceptable as loop counters, but less clear when used as method parameters.
- **Ambiguous Names (`test`, `clc`, `exitCode`)** — These do not make it immediately clear what they represent.

Let's list all appearances:
- `testContainer(NMClientImpl client, int i, Container container, ContainerLaunchContext clc, List<Integer> exitCode)`
    - `i` isn’t clear: should clarify it is an "index".
    - `clc` is an abbreviation for `ContainerLaunchContext` — could be expanded.
    - `exitCode` is a list, so should be `exitStatuses`.
- `testGetContainerStatus(Container container, int index, ContainerState state, String diagnostics, List<Integer> exitStatuses)`
    - This is fine.
- `waitForContainerRunningTransitionCount(Container container, long transitions)`
    - `transitions` is fine, might be clearer as `expectedTransitions`.
- `runTest(Runnable test)`
    - Rather than `test`, something like `testLogic` or `testTask` is clearer.

#### Applying Refactorings

Below, the following parameter names are updated:
1. All usages of `i` as an integer parameter to `containerIndex` for clarity.
2. All usages of `clc` (except private fields where the name is conventional) to `containerLaunchContext`.
3. All usages of `exitCode` changed to `exitStatuses`.
4. All usages of `test` as a `Runnable` changed to `testLogic`.
5. `waitForContainerRunningTransitionCount(Container container, long transitions)` → `expectedTransitions`.
6. For consistency, in the `allocateContainers(AMRMClientImpl<ContainerRequest> client)` method, changed `client` to `amrmClient`.

### Full Refactored Code

```java
package org.apache.hadoop.yarn.client.api.impl;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.io.DataOutputBuffer;
import org.apache.hadoop.security.Credentials;
import org.apache.hadoop.security.UserGroupInformation;
import org.apache.hadoop.service.Service.STATE;
import org.apache.hadoop.test.GenericTestUtils;
import org.apache.hadoop.util.Shell;
import org.apache.hadoop.yarn.api.protocolrecords.AllocateResponse;
import org.apache.hadoop.yarn.api.protocolrecords.SubmitApplicationRequest;
import org.apache.hadoop.yarn.api.records.ApplicationId;
import org.apache.hadoop.yarn.api.records.ApplicationSubmissionContext;
import org.apache.hadoop.yarn.api.records.Container;
import org.apache.hadoop.yarn.api.records.ContainerId;
import org.apache.hadoop.yarn.api.records.ContainerLaunchContext;
import org.apache.hadoop.yarn.api.records.ContainerState;
import org.apache.hadoop.yarn.api.records.ContainerStatus;
import org.apache.hadoop.yarn.api.records.FinalApplicationStatus;
import org.apache.hadoop.yarn.api.records.NMToken;
import org.apache.hadoop.yarn.api.records.NodeReport;
import org.apache.hadoop.yarn.api.records.NodeState;
import org.apache.hadoop.yarn.api.records.Priority;
import org.apache.hadoop.yarn.api.records.Resource;
import org.apache.hadoop.yarn.client.api.AMRMClient;
import org.apache.hadoop.yarn.client.api.AMRMClient.ContainerRequest;
import org.apache.hadoop.yarn.client.api.NMClient;
import org.apache.hadoop.yarn.client.api.NMTokenCache;
import org.apache.hadoop.yarn.client.api.YarnClient;
import org.apache.hadoop.yarn.conf.YarnConfiguration;
import org.apache.hadoop.yarn.exceptions.YarnException;
import org.apache.hadoop.yarn.server.MiniYARNCluster;
import org.apache.hadoop.yarn.server.nodemanager.ContainerStateTransitionListener;
import org.apache.hadoop.yarn.server.nodemanager.Context;
import org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerEvent;
import org.apache.hadoop.yarn.server.nodemanager.containermanager.container.ContainerImpl;
import org.apache.hadoop.yarn.server.resourcemanager.rmapp.attempt.RMAppAttempt;
import org.apache.hadoop.yarn.server.resourcemanager.rmapp.attempt.RMAppAttemptState;
import org.apache.hadoop.yarn.util.Records;

import org.junit.Test;
import org.junit.function.ThrowingRunnable;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeoutException;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertThrows;
import static org.junit.Assert.assertTrue;

public class TestNMClient {
    private static final String IS_NOT_HANDLED_BY_THIS_NODEMANAGER =
            "is not handled by this NodeManager";
    private static final String UNKNOWN_CONTAINER =
            "Unknown container";

    private static final int NUMBER_OF_CONTAINERS = 5;
    private Configuration conf;
    private MiniYARNCluster yarnCluster;
    private YarnClientImpl yarnClient;
    private AMRMClientImpl<ContainerRequest> rmClient;
    private NMClientImpl nmClient;
    private List<NodeReport> nodeReports;
    private NMTokenCache nmTokenCache;
    private RMAppAttempt appAttempt;

    /**
     * Container State transition listener to track the number of times
     * a container has transitioned into a state.
     */
    public static class DebugSumContainerStateListener implements ContainerStateTransitionListener {
        public static final Map<ContainerId, Integer> RUNNING_TRANSITIONS = new ConcurrentHashMap<>();

        public void init(Context context) {
        }

        public void preTransition(ContainerImpl op,
                                  org.apache.hadoop.yarn.server.nodemanager
                                          .containermanager.container.ContainerState
                                          beforeState,
                                  ContainerEvent eventToBeProcessed) {
        }

        public void postTransition(
                ContainerImpl op,
                org.apache.hadoop.yarn.server.nodemanager.containermanager.container
                        .ContainerState beforeState,
                org.apache.hadoop.yarn.server.nodemanager.containermanager.container
                        .ContainerState afterState,
                ContainerEvent processedEvent) {
            if (beforeState != afterState &&
                    afterState == org.apache.hadoop.yarn.server.nodemanager.containermanager.container
                            .ContainerState.RUNNING) {
                RUNNING_TRANSITIONS.compute(op.getContainerId(),
                        (containerId, counter) -> counter == null ? 1 : ++counter);
            }
        }
    }

    public void setup() throws YarnException, IOException, InterruptedException, TimeoutException {
        conf = new YarnConfiguration();
        conf.set(YarnConfiguration.NM_CONTAINER_STATE_TRANSITION_LISTENERS,
                DebugSumContainerStateListener.class.getName());
        startYarnCluster();
        startYarnClient();
        UserGroupInformation.setLoginUser(UserGroupInformation
                .createRemoteUser(UserGroupInformation.getCurrentUser().getUserName()));
        UserGroupInformation.getCurrentUser().addToken(appAttempt.getAMRMToken());
        nmTokenCache = new NMTokenCache();
        startRMClient();
        startNMClient();
    }


    private void startYarnCluster() {
        yarnCluster = new MiniYARNCluster(TestNMClient.class.getName(), 3, 1, 1);
        yarnCluster.init(conf);
        yarnCluster.start();
        assertEquals(STATE.STARTED, yarnCluster.getServiceState());
    }

    private void startYarnClient()
            throws IOException, YarnException, InterruptedException, TimeoutException {
        yarnClient = (YarnClientImpl) YarnClient.createYarnClient();
        yarnClient.init(conf);
        yarnClient.start();
        assertEquals(STATE.STARTED, yarnClient.getServiceState());
        nodeReports = yarnClient.getNodeReports(NodeState.RUNNING);

        ApplicationSubmissionContext appContext =
                yarnClient.createApplication().getApplicationSubmissionContext();
        ApplicationId appId = appContext.getApplicationId();
        appContext.setApplicationName("Test");
        Priority pri = Priority.newInstance(0);
        appContext.setPriority(pri);
        appContext.setQueue("default");
        ContainerLaunchContext amContainer = Records.newRecord(ContainerLaunchContext.class);
        appContext.setAMContainerSpec(amContainer);
        appContext.setUnmanagedAM(true);

        SubmitApplicationRequest appRequest = Records.newRecord(SubmitApplicationRequest.class);
        appRequest.setApplicationSubmissionContext(appContext);
        yarnClient.submitApplication(appContext);
        GenericTestUtils.waitFor(() -> yarnCluster.getResourceManager().getRMContext().getRMApps()
                        .get(appId).getCurrentAppAttempt().getAppAttemptState() == RMAppAttemptState.LAUNCHED,
                100, 30_000, "Failed to start app");
        appAttempt = yarnCluster.getResourceManager().getRMContext().getRMApps()
                .get(appId).getCurrentAppAttempt();
    }

    private void startRMClient() {
        rmClient = (AMRMClientImpl<ContainerRequest>) AMRMClient.createAMRMClient();
        rmClient.setNMTokenCache(nmTokenCache);
        rmClient.init(conf);
        rmClient.start();
        assertEquals(STATE.STARTED, rmClient.getServiceState());
    }

    private void startNMClient() {
        nmClient = (NMClientImpl) NMClient.createNMClient();
        nmClient.setNMTokenCache(rmClient.getNMTokenCache());
        nmClient.init(conf);
        nmClient.start();
        assertEquals(STATE.STARTED, nmClient.getServiceState());
    }

    public void tearDown() throws InterruptedException {
        rmClient.stop();
        yarnClient.stop();
        yarnCluster.stop();
    }

    @Test (timeout = 180_000)
    public void testNMClientNoCleanupOnStop()
            throws YarnException, IOException, InterruptedException, TimeoutException {
        runTest(() -> {
            stopNmClient();
            assertFalse(nmClient.startedContainers.isEmpty());
            nmClient.cleanupRunningContainers();
            assertEquals(0, nmClient.startedContainers.size());
        });
    }

    @Test (timeout = 200_000)
    public void testNMClient()
            throws YarnException, IOException, InterruptedException, TimeoutException {
        runTest(() -> {
            // stop the running containers on close
            assertFalse(nmClient.startedContainers.isEmpty());
            nmClient.cleanupRunningContainersOnStop(true);
            assertTrue(nmClient.getCleanupRunningContainers().get());
            nmClient.stop();
        });
    }

    public void runTest(
            Runnable testLogic
    ) throws IOException, InterruptedException, YarnException, TimeoutException {
        setup();
        rmClient.registerApplicationMaster("Host", 10_000, "");
        testContainerManagement(nmClient, allocateContainers(rmClient));
        rmClient.unregisterApplicationMaster(FinalApplicationStatus.SUCCEEDED, null, null);
        testLogic.run();
        tearDown();
    }

    private void stopNmClient() {
        assertNotNull("Null nmClient", nmClient);
        // leave one unclosed
        assertEquals(1, nmClient.startedContainers.size());
        // default true
        assertTrue(nmClient.getCleanupRunningContainers().get());
        nmClient.cleanupRunningContainersOnStop(false);
        assertFalse(nmClient.getCleanupRunningContainers().get());
        nmClient.stop();
    }

    private Set<Container> allocateContainers(
            AMRMClientImpl<ContainerRequest> amrmClient
    ) throws YarnException, IOException {
        for (int idx = 0; idx < NUMBER_OF_CONTAINERS; ++idx) {
            amrmClient.addContainerRequest(new ContainerRequest(
                    Resource.newInstance(1024, 0),
                    new String[] {nodeReports.get(0).getNodeId().getHost()},
                    new String[] {nodeReports.get(0).getRackName()},
                    Priority.newInstance(0)
            ));
        }
        Set<Container> allocatedContainers = new TreeSet<>();
        while (allocatedContainers.size() < NUMBER_OF_CONTAINERS) {
            AllocateResponse allocResponse = amrmClient.allocate(0.1f);
            allocatedContainers.addAll(allocResponse.getAllocatedContainers());
            for (NMToken token : allocResponse.getNMTokens()) {
                amrmClient.getNMTokenCache().setToken(token.getNodeId().toString(), token.getToken());
            }
            if (allocatedContainers.size() < NUMBER_OF_CONTAINERS) {
                sleep(100);
            }
        }
        return allocatedContainers;
    }

    private void testContainerManagement(
            NMClientImpl client, Set<Container> containers
    ) throws YarnException, IOException {
        int size = containers.size();
        int containerIndex = 0;
        for (Container container : containers) {
            // getContainerStatus shouldn't be called before startContainer,
            // otherwise, NodeManager cannot find the container
            assertYarnException(
                    () -> client.getContainerStatus(container.getId(), container.getNodeId()),
                    IS_NOT_HANDLED_BY_THIS_NODEMANAGER);
            // upadateContainerResource shouldn't be called before startContainer,
            // otherwise, NodeManager cannot find the container
            assertYarnException(
                    () -> client.updateContainerResource(container),
                    IS_NOT_HANDLED_BY_THIS_NODEMANAGER);
            // restart shouldn't be called before startContainer,
            // otherwise, NodeManager cannot find the container
            assertYarnException(
                    () -> client.restartContainer(container.getId()),
                    UNKNOWN_CONTAINER);
            // rollback shouldn't be called before startContainer,
            // otherwise, NodeManager cannot find the container
            assertYarnException(
                    () -> client.rollbackLastReInitialization(container.getId()),
                    UNKNOWN_CONTAINER);
            // commit shouldn't be called before startContainer,
            // otherwise, NodeManager cannot find the container
            assertYarnException(
                    () -> client.commitLastReInitialization(container.getId()),
                    UNKNOWN_CONTAINER);
            // stopContainer shouldn't be called before startContainer,
            // otherwise, an exception will be thrown
            assertYarnException(
                    () -> client.stopContainer(container.getId(), container.getNodeId()),
                    IS_NOT_HANDLED_BY_THIS_NODEMANAGER);

            Credentials ts = new Credentials();
            DataOutputBuffer dob = new DataOutputBuffer();
            ts.writeTokenStorageToStream(dob);
            ByteBuffer securityTokens = ByteBuffer.wrap(dob.getData(), 0, dob.getLength());
            ContainerLaunchContext containerLaunchContext = Records.newRecord(ContainerLaunchContext.class);
            containerLaunchContext.setCommands(Shell.WINDOWS
                    ? Arrays.asList("ping", "-n", "10000000", "127.0.0.1", ">nul")
                    : Arrays.asList("sleep", "1000000")
            );
            containerLaunchContext.setTokens(securityTokens);
            client.startContainer(container, containerLaunchContext);

            List<Integer> exitStatuses = Arrays.asList(-1000, -105);

            // leave one container unclosed
            if (++containerIndex < size) {
                testContainer(client, containerIndex, container, containerLaunchContext, exitStatuses);
            }
        }
    }

    private void testContainer(NMClientImpl client, int containerIndex, Container container,
                               ContainerLaunchContext containerLaunchContext, List<Integer> exitStatuses)
            throws YarnException, IOException {
        testGetContainerStatus(container, containerIndex, ContainerState.RUNNING, "",
                exitStatuses);
        waitForContainerRunningTransitionCount(container, 1);
        testIncreaseContainerResource(container);
        testRestartContainer(container);
        testGetContainerStatus(container, containerIndex, ContainerState.RUNNING,
                "will be Restarted", exitStatuses);
        waitForContainerRunningTransitionCount(container, 2);
        if (containerIndex % 2 == 0) {
            testReInitializeContainer(container, containerLaunchContext, false);
            testGetContainerStatus(container, containerIndex, ContainerState.RUNNING,
                    "will be Re-initialized", exitStatuses);
            waitForContainerRunningTransitionCount(container, 3);
            testContainerRollback(container, true);
            testGetContainerStatus(container, containerIndex, ContainerState.RUNNING,
                    "will be Rolled-back", exitStatuses);
            waitForContainerRunningTransitionCount(container, 4);
            testContainerCommit(container, false);
            testReInitializeContainer(container, containerLaunchContext, false);
            testGetContainerStatus(container, containerIndex, ContainerState.RUNNING,
                    "will be Re-initialized", exitStatuses);
            waitForContainerRunningTransitionCount(container, 5);
            testContainerCommit(container, true);
        } else {
            testReInitializeContainer(container, containerLaunchContext, true);
            testGetContainerStatus(container, containerIndex, ContainerState.RUNNING,
                    "will be Re-initialized", exitStatuses);
            waitForContainerRunningTransitionCount(container, 3);
            testContainerRollback(container, false);
            testContainerCommit(container, false);
        }
        client.stopContainer(container.getId(), container.getNodeId());
        testGetContainerStatus(container, containerIndex, ContainerState.COMPLETE,
                "killed by the ApplicationMaster", exitStatuses);
    }

    private void waitForContainerRunningTransitionCount(Container container, long expectedTransitions) {
        while (DebugSumContainerStateListener.RUNNING_TRANSITIONS
                .getOrDefault(container.getId(), 0) != expectedTransitions) {
            sleep(500);
        }
    }


    private void testGetContainerStatus(Container container, int index,
                                        ContainerState state, String diagnostics,
                                        List<Integer> exitStatuses)
            throws YarnException, IOException {
        while (true) {
            sleep(250);
            ContainerStatus status = nmClient.getContainerStatus(
                    container.getId(), container.getNodeId());
            // NodeManager may still need some time to get the stable
            // container status
            if (status.getState() == state) {
                assertEquals(container.getId(), status.getContainerId());
                assertTrue(index + ": " + status.getDiagnostics(),
                        status.getDiagnostics().contains(diagnostics));

                assertTrue("Exit Statuses are supposed to be in: " + exitStatuses +
                                ", but the actual exit status code is: " +
                                status.getExitStatus(),
                        exitStatuses.contains(status.getExitStatus()));
                break;
            }
        }
    }

    @SuppressWarnings("deprecation")
    private void testIncreaseContainerResource(Container container) {
        assertYarnException(
                () -> nmClient.increaseContainerResource(container),
                container.getId() + " has update version ");
    }

    private void testRestartContainer(Container container) throws IOException, YarnException {
        nmClient.restartContainer(container.getId());
    }

    private void testContainerRollback(Container container, boolean notRollbackable)
            throws IOException, YarnException {
        if (notRollbackable) {
            nmClient.rollbackLastReInitialization(container.getId());
        } else {
            assertYarnException(
                    () -> nmClient.rollbackLastReInitialization(container.getId()),
                    "Nothing to rollback to");
        }
    }

    private void testContainerCommit(Container container, boolean enabled)
            throws IOException, YarnException {
        if (enabled) {
            nmClient.commitLastReInitialization(container.getId());
        } else {
            assertYarnException(
                    () -> nmClient.commitLastReInitialization(container.getId()),
                    "Nothing to Commit");
        }
    }

    private void testReInitializeContainer(
            Container container, ContainerLaunchContext containerLaunchContext, boolean autoCommit
    ) throws IOException, YarnException {
        nmClient.reInitializeContainer(container.getId(), containerLaunchContext, autoCommit);
    }

    private void assertYarnException(ThrowingRunnable runnable, String text) {
        YarnException e = assertThrows(YarnException.class, runnable);
        assertTrue(String.format("The thrown exception is not expected cause it has text [%s]"
                + ", what not contains text [%s]", e.getMessage(), text), e.getMessage().contains(text));
    }

    private void sleep(int sleepTime) {
        try {
            Thread.sleep(sleepTime);
        } catch (InterruptedException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }
}
```

---

**Summary of changes:**

- Method parameters now use more descriptive identifiers for easier reading, review, and maintenance.
- Method logic is unchanged; only parameter names were improved.

---

**If you have a specific naming convention in mind for your codebase, let me know and I can apply that as well.**
