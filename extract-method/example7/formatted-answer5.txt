package org.hibernate.event.internal;

import org.hibernate.HibernateException;
import org.hibernate.LockMode;
import org.hibernate.LockOptions;
import org.hibernate.NonUniqueObjectException;
import org.hibernate.TransientObjectException;
import org.hibernate.UnresolvableObjectException;
import org.hibernate.cache.spi.access.CollectionDataAccess;
import org.hibernate.cache.spi.access.EntityDataAccess;
import org.hibernate.cache.spi.access.SoftLock;
import org.hibernate.engine.internal.Cascade;
import org.hibernate.engine.internal.CascadePoint;
import org.hibernate.engine.spi.ActionQueue;
import org.hibernate.engine.spi.CascadingActions;
import org.hibernate.engine.spi.EntityEntry;
import org.hibernate.engine.spi.EntityKey;
import org.hibernate.engine.spi.PersistenceContext;
import org.hibernate.engine.spi.SessionFactoryImplementor;
import org.hibernate.event.spi.EventSource;
import org.hibernate.event.spi.RefreshContext;
import org.hibernate.event.spi.RefreshEvent;
import org.hibernate.event.spi.RefreshEventListener;
import org.hibernate.internal.CoreLogging;
import org.hibernate.internal.CoreMessageLogger;
import org.hibernate.loader.ast.spi.CascadingFetchProfile;
import org.hibernate.metamodel.spi.MappingMetamodelImplementor;
import org.hibernate.persister.collection.CollectionPersister;
import org.hibernate.persister.entity.EntityPersister;
import org.hibernate.proxy.HibernateProxy;
import org.hibernate.proxy.LazyInitializer;
import org.hibernate.type.CollectionType;
import org.hibernate.type.CompositeType;
import org.hibernate.type.Type;

import static org.hibernate.pretty.MessageHelper.infoString;

public class DefaultRefreshEventListener implements RefreshEventListener {
    private static final CoreMessageLogger LOG = CoreLogging.messageLogger(DefaultRefreshEventListener.class);

    public void onRefresh(RefreshEvent event) throws HibernateException {
        onRefresh(event, RefreshContext.create());
    }

    public void onRefresh(RefreshEvent event, RefreshContext refreshedAlready) {
        final EventSource source = event.getSession();
        final PersistenceContext persistenceContext = source.getPersistenceContextInternal();
        final Object object = event.getObject();
        if (persistenceContext.reassociateIfUninitializedProxy(object)) {
            final boolean isTransient = isTransient(event, source, object);
            final LazyInitializer lazyInitializer = HibernateProxy.extractLazyInitializer(object);
            final EntityPersister persister = source.getEntityPersister(lazyInitializer.getEntityName(), object);
            Object id = persister.getIdentifier(object, event.getSession());
            final Object result = source.getLoadQueryInfluencers().fromInternalFetchProfile(CascadingFetchProfile.REFRESH, () -> doRefresh(event, source, null, null, persister, lazyInitializer, id, persistenceContext));
            UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());
            if (isTransient) {
                source.setReadOnly(object, source.isDefaultReadOnly());
            }
        } else {
            final Object entity = persistenceContext.unproxyAndReassociate(object);
            if (refreshedAlready.add(entity)) {
                refresh(event, refreshedAlready, entity);
            } else {
                LOG.trace("Already refreshed");
            }
        }
    }

    private static boolean isTransient(RefreshEvent event, EventSource source, Object object) {
        final String entityName = event.getEntityName();
        return entityName != null ? !source.contains(entityName, object) : !source.contains(object);
    }

    private static void refresh(RefreshEvent event, RefreshContext refreshedAlready, Object object) {
        final EventSource source = event.getSession();
        final PersistenceContext persistenceContext = source.getPersistenceContextInternal();
        final EntityEntry entry = persistenceContext.getEntry(object);
        final EntityPersister persister;
        final Object id;
        if (entry == null) {
            persister = source.getEntityPersister(event.getEntityName(), object);
            id = persister.getIdentifier(object, event.getSession());
            if (id == null) {
                throw new TransientObjectException("transient instance passed to refresh");
            }
            if (LOG.isTraceEnabled()) {
                LOG.tracev("Refreshing transient {0}", infoString(persister, id, source.getFactory()));
            }
            if (persistenceContext.getEntry(source.generateEntityKey(id, persister)) != null) {
                throw new NonUniqueObjectException(id, persister.getEntityName());
            }
        } else {
            if (LOG.isTraceEnabled()) {
                LOG.tracev("Refreshing ", infoString(entry.getPersister(), entry.getId(), source.getFactory()));
            }
            if (!entry.isExistsInDatabase()) {
                throw new UnresolvableObjectException(entry.getId(), "this instance does not yet exist as a row in the database");
            }
            persister = entry.getPersister();
            id = entry.getId();
        }
        Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);
        if (entry != null) {
            final EntityKey key = source.generateEntityKey(id, persister);
            persistenceContext.removeEntity(key);
            if (persister.hasCollections()) {
                new EvictVisitor(source, object).process(object, persister);
            }
        }
        evictEntity(object, persister, id, source);
        evictCachedCollections(persister, id, source);
        final Object result = source.getLoadQueryInfluencers().fromInternalFetchProfile(CascadingFetchProfile.REFRESH, () -> doRefresh(event, source, object, entry, persister, null, id, persistenceContext));
        UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());
    }

    private static void evictEntity(Object object, EntityPersister persister, Object id, EventSource source) {
        if (persister.canWriteToCache()) {
            Object previousVersion = null;
            if (persister.isVersionPropertyGenerated()) {
                previousVersion = persister.getVersion(object);
            }
            final EntityDataAccess cache = persister.getCacheAccessStrategy();
            executeCacheEviction(cache, id, persister, source.getFactory(), source.getTenantIdentifier(), source, previousVersion, source.getActionQueue());
        }
    }

    private static Object doRefresh(RefreshEvent event, EventSource source, Object object, EntityEntry entry, EntityPersister persister, LazyInitializer lazyInitializer, Object id, PersistenceContext persistenceContext) {
        LockOptions lockOptionsToUse = event.getLockOptions();
        final LockMode requestedLockMode = lockOptionsToUse.getLockMode();
        final LockMode postRefreshLockMode;
        if (entry != null) {
            final LockMode currentLockMode = entry.getLockMode();
            if (currentLockMode.greaterThan(requestedLockMode)) {
                lockOptionsToUse = event.getLockOptions().makeCopy();
                if (currentLockMode == LockMode.WRITE || currentLockMode == LockMode.PESSIMISTIC_WRITE || currentLockMode == LockMode.PESSIMISTIC_READ) {
                    lockOptionsToUse.setLockMode(LockMode.READ);
                    postRefreshLockMode = currentLockMode;
                } else {
                    lockOptionsToUse.setLockMode(currentLockMode);
                    postRefreshLockMode = null;
                }
            } else {
                postRefreshLockMode = null;
            }
        } else {
            postRefreshLockMode = null;
        }
        final Object result = persister.load(id, object, lockOptionsToUse, source);
        if (result != null) {
            if (postRefreshLockMode != null) {
                persistenceContext.getEntry(result).setLockMode(postRefreshLockMode);
            }
            source.setReadOnly(result, isReadOnly(entry, persister, lazyInitializer, source));
        }
        return result;
    }

    private static boolean isReadOnly(EntityEntry entry, EntityPersister persister, LazyInitializer lazyInitializer, EventSource source) {
        if (!persister.isMutable()) {
            return true;
        } else if (entry != null) {
            return entry.isReadOnly();
        } else if (lazyInitializer != null) {
            return lazyInitializer.isReadOnly();
        } else {
            return source.isDefaultReadOnly();
        }
    }

    private static void evictCachedCollections(EntityPersister persister, Object id, EventSource source) {
        evictCachedCollections(persister.getPropertyTypes(), id, source);
    }

    private static void evictCachedCollections(Type[] types, Object id, EventSource source) throws HibernateException {
        final ActionQueue actionQueue = source.getActionQueue();
        final SessionFactoryImplementor factory = source.getFactory();
        final MappingMetamodelImplementor metamodel = factory.getRuntimeMetamodels().getMappingMetamodel();
        for (Type type : types) {
            if (type.isCollectionType()) {
                final String role = ((CollectionType) type).getRole();
                final CollectionPersister collectionPersister = metamodel.getCollectionDescriptor(role);
                if (collectionPersister.hasCache()) {
                    final CollectionDataAccess cache = collectionPersister.getCacheAccessStrategy();
                    executeCacheEviction(cache, id, collectionPersister, factory, source.getTenantIdentifier(), source, null, actionQueue);
                }
            } else if (type.isComponentType()) {
                final CompositeType compositeType = (CompositeType) type;
                evictCachedCollections(compositeType.getSubtypes(), id, source);
            }
        }
    }

    private static void executeCacheEviction(Object cacheAccessStrategy, Object id, Object persister, SessionFactoryImplementor factory, String tenantIdentifier, EventSource source, Object version, ActionQueue actionQueue) {
        Object cacheKey;
        SoftLock lock;
        if (cacheAccessStrategy instanceof EntityDataAccess) {
            EntityDataAccess cache = (EntityDataAccess) cacheAccessStrategy;
            cacheKey = cache.generateCacheKey(id, (EntityPersister) persister, factory, tenantIdentifier);
            lock = cache.lockItem(source, cacheKey, version);
            cache.remove(source, cacheKey);
            actionQueue.registerProcess((success, session) -> cache.unlockItem(session, cacheKey, lock));
        } else if (cacheAccessStrategy instanceof CollectionDataAccess) {
            CollectionDataAccess cache = (CollectionDataAccess) cacheAccessStrategy;
            cacheKey = cache.generateCacheKey(id, (CollectionPersister) persister, factory, tenantIdentifier);
            lock = cache.lockItem(source, cacheKey, null);
            cache.remove(source, cacheKey);
            actionQueue.registerProcess((success, session) -> cache.unlockItem(session, cacheKey, lock));
        }
    }
}