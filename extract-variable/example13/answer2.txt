30-04-2025, 21:03

Yes, there are several **extract variable refactoring opportunities** in your code, mainly around these points:

1. **Repeated calls to `executeTestsForClass(...).testEvents()`** within single test methods.
2. **String formatting expressions** that are almost identical in several methods.
3. **Magic strings** like expected arrays (though those are more for extract constant, but variable is also fine in a method body).
4. Some **duplicate logic** in test methods.

Below is your refactored code with **extract variable** refactoring applied, with explanatory comments (which you can strip if unnecessary in your context).

```java
package org.junit.jupiter.engine.extension;

import static java.lang.StackWalker.Option.RETAIN_CLASS_REFERENCE;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatIllegalStateException;
import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS;
import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_METHOD;
import static org.junit.platform.testkit.engine.EventConditions.finishedWithFailure;
import static org.junit.platform.testkit.engine.TestExecutionResultConditions.message;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.LogRecord;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.AutoClose;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.junit.jupiter.api.fixtures.TrackLogRecords;
import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;
import org.junit.platform.commons.logging.LogRecordListener;
import org.junit.platform.testkit.engine.EngineExecutionResults;
import org.junit.platform.testkit.engine.Events;
import org.junit.platform.testkit.engine.Execution;

class AutoCloseTests extends AbstractJupiterTestEngineTests {

    private static final List<String> recorder = new ArrayList<>();

    @BeforeEach
    @AfterEach
    void resetTracking() {
        InstancePerClassTestCase.closed = false;
        recorder.clear();
    }

    @Test
    void blankCloseMethodName() {
        Class<?> testClass = BlankCloseMethodNameTestCase.class;
        String className = testClass.getCanonicalName();
        String msg = String.format("@AutoClose on field %s.field must specify a method name.", className);
        Events tests = executeTestsForClass(testClass).testEvents();
        assertFailingWithMessage(tests, msg);
    }

    @Test
    void primitiveTypeCannotBeClosed() {
        Class<?> testClass = PrimitiveFieldTestCase.class;
        String className = testClass.getCanonicalName();
        String msg = String.format("@AutoClose is not supported on primitive field %s.x.", className);
        Events tests = executeTestsForClass(testClass).testEvents();
        assertFailingWithMessage(tests, msg);
    }

    @Test
    void arrayCannotBeClosed() {
        Class<?> testClass = ArrayFieldTestCase.class;
        String className = testClass.getCanonicalName();
        String msg = String.format("@AutoClose is not supported on array field %s.x.", className);
        Events tests = executeTestsForClass(testClass).testEvents();
        assertFailingWithMessage(tests, msg);
    }

    @Test
    void nullCannotBeClosed(@TrackLogRecords LogRecordListener listener) {
        Class<?> testClass = NullCloseableFieldTestCase.class;
        String className = testClass.getCanonicalName();
        String msg = String.format("Cannot @AutoClose field %s.field because it is null.", className);
        Events tests = executeTestsForClass(testClass).testEvents();
        tests.assertStatistics(stats -> stats.succeeded(1).failed(0));
        assertThat(listener.stream(Level.WARNING)).map(LogRecord::getMessage).anyMatch(msg::equals);
    }

    @Test
    void noCloseMethod() {
        assertMissingCloseMethod(NoCloseMethodTestCase.class, "close");
    }

    @Test
    void noShutdownMethod() {
        assertMissingCloseMethod(NoShutdownMethodTestCase.class, "shutdown");
    }

    @Test
    void spyPermitsOnlyASingleAction() {
        AutoCloseSpy spy = new AutoCloseSpy("preconditions");

        spy.close();

        assertThatIllegalStateException().isThrownBy(spy::run).withMessage("Already closed via close()");
        assertThatIllegalStateException().isThrownBy(spy::close).withMessage("Already closed via close()");
        assertThat(recorder).containsExactly("AutoCloseTests.preconditions.close()");
    }

    @Test
    void fieldsAreProperlyClosedWithInstancePerMethodTestClass() {
        Class<?> testClass = InstancePerMethodTestCase.class;
        Events tests = executeTestsForClass(testClass).testEvents();
        tests.assertStatistics(stats -> stats.succeeded(2));
        assertThat(recorder).containsExactly(
                // test1()
                "InstancePerMethodTestCase.runnable.run()",
                "InstancePerMethodTestCase.closable.close()",
                // test2()
                "InstancePerMethodTestCase.runnable.run()",
                "InstancePerMethodTestCase.closable.close()",
                // Class-level cleanup
                "InstancePerMethodTestCase.staticClosable.close()"
        );
    }

    @Test
    void fieldsAreProperlyClosedWithInstancePerClassTestClass() {
        Class<?> testClass = InstancePerClassTestCase.class;
        Events tests = executeTestsForClass(testClass).testEvents();
        tests.assertStatistics(stats -> stats.succeeded(2));
        assertThat(InstancePerClassTestCase.closed).isTrue();
    }

    @Test
    void fieldsAreProperlyClosedWithNestedTestClassesWithInstancePerMethod() {
        Class<?> nestedTestClass = InstancePerMethodEnclosingTestCase.NestedTestCase.class;
        Events tests = executeTestsForClass(nestedTestClass).testEvents();
        tests.assertStatistics(stats -> stats.succeeded(1));
        assertThat(recorder).containsExactly(
                "NestedTestCase.nestedClosable.close()",
                "InstancePerMethodEnclosingTestCase.enclosingClosable.close()",
                "NestedTestCase.nestedStaticClosable.close()",
                "InstancePerMethodEnclosingTestCase.enclosingStaticClosable.close()"
        );

        // Reset tracking
        resetTracking();

        Class<?> enclosingTestClass = InstancePerMethodEnclosingTestCase.class;
        tests = executeTestsForClass(enclosingTestClass).testEvents();
        tests.assertStatistics(stats -> stats.succeeded(2));
        assertThat(recorder).containsExactly(
                "InstancePerMethodEnclosingTestCase.enclosingClosable.close()",
                "NestedTestCase.nestedClosable.close()",
                "InstancePerMethodEnclosingTestCase.enclosingClosable.close()",
                "NestedTestCase.nestedStaticClosable.close()",
                "InstancePerMethodEnclosingTestCase.enclosingStaticClosable.close()"
        );
    }

    @Test
    void fieldsAreProperlyClosedWithNestedTestClassesWithInstancePerClass() {
        String[] expected = {
                "NestedTestCase.nestedStaticClosable.close()",
                "NestedTestCase.nestedClosable.close()",
                "InstancePerClassEnclosingTestCase.enclosingStaticClosable.close()",
                "InstancePerClassEnclosingTestCase.enclosingClosable.close()"
        };

        Class<?> nestedTestClass = InstancePerClassEnclosingTestCase.NestedTestCase.class;
        Events tests = executeTestsForClass(nestedTestClass).testEvents();
        tests.assertStatistics(stats -> stats.succeeded(1));
        assertThat(recorder).containsExactly(expected);

        // Reset tracking
        resetTracking();

        Class<?> enclosingTestClass = InstancePerClassEnclosingTestCase.class;
        tests = executeTestsForClass(enclosingTestClass).testEvents();
        tests.assertStatistics(stats -> stats.succeeded(2));
        assertThat(recorder).containsExactly(expected);
    }

    @Test
    void fieldsAreProperlyClosedWithinTestClassHierarchy() {
        Class<?> superClass = SuperTestCase.class;
        Events tests = executeTestsForClass(superClass).testEvents();
        tests.assertStatistics(stats -> stats.succeeded(1));
        assertThat(recorder).containsExactly(
                // superTest()
                "SuperTestCase.superClosable.close()",
                // Class-level cleanup
                "SuperTestCase.superStaticClosable.close()"
        );

        // Reset tracking
        resetTracking();

        Class<?> subClass = SubTestCase.class;
        tests = executeTestsForClass(subClass).testEvents();
        tests.assertStatistics(stats -> stats.succeeded(2));
        assertThat(recorder).containsExactly(
                // superTest()
                "SubTestCase.subClosable.close()",
                "SuperTestCase.superClosable.close()",
                // subTest()
                "SubTestCase.subClosable.close()",
                "SuperTestCase.superClosable.close()",
                // Class-level cleanup in subclass
                "SubTestCase.subStaticClosable.close()",
                // Class-level cleanup in superclass
                "SuperTestCase.superStaticClosable.close()"
        );
    }

    @Test
    void allFieldsAreClosedIfAnyFieldThrowsAnException() {
        String staticField1 = "staticField1";
        String staticField2 = "staticField2";
        String staticField3 = "staticField3";
        String field1 = "field1";
        String field2 = "field2";
        String field3 = "field3";

        // Prerequisites to ensure fields are "ordered" as expected (based on the hash codes for their names).
        assertThat(staticField1.hashCode()).isLessThan(staticField2.hashCode()).isLessThan(staticField3.hashCode());
        assertThat(field1.hashCode()).isLessThan(field2.hashCode()).isLessThan(field3.hashCode());

        Class<?> testClass = FailingFieldsTestCase.class;
        EngineExecutionResults allEvents = executeTestsForClass(testClass);

        Events tests = allEvents.testEvents();
        tests.assertStatistics(stats -> stats.succeeded(0).failed(1));
        // Verify that ALL fields were closed.
        assertThat(recorder).containsExactly(
                "FailingFieldsTestCase.field1.close()",
                "FailingFieldsTestCase.field2.close()",
                "FailingFieldsTestCase.field3.close()",
                "FailingFieldsTestCase.staticField1.close()",
                "FailingFieldsTestCase.staticField2.close()",
                "FailingFieldsTestCase.staticField3.close()"
        );

        // Test-level failures
        Throwable throwable = findExecution(tests, "test()")
                .getTerminationInfo().getExecutionResult().getThrowable().orElseThrow();
        assertThat(throwable)
                .isExactlyInstanceOf(RuntimeException.class)
                .hasMessage("FailingFieldsTestCase.field1.close()")
                .hasNoCause()
                .hasSuppressedException(new RuntimeException("FailingFieldsTestCase.field2.close()"));

        Events containers = allEvents.containerEvents();
        containers.assertStatistics(stats -> stats.succeeded(1).failed(1));

        // Container-level failures
        throwable = findExecution(containers, testClass.getSimpleName())
                .getTerminationInfo().getExecutionResult().getThrowable().orElseThrow();
        assertThat(throwable)
                .isExactlyInstanceOf(RuntimeException.class)
                .hasMessage("FailingFieldsTestCase.staticField1.close()")
                .hasNoCause()
                .hasSuppressedException(new RuntimeException("FailingFieldsTestCase.staticField2.close()"));
    }

    private static Execution findExecution(Events events, String displayName) {
        return events.executions()
                .filter(execution -> execution.getTestDescriptor().getDisplayName().contains(displayName))
                .findFirst().get();
    }

    private static void assertFailingWithMessage(Events testEvents, String msg) {
        testEvents
                .assertStatistics(stats -> stats.failed(1))
                .assertThatEvents().haveExactly(1, finishedWithFailure(message(msg)));
    }

    private void assertMissingCloseMethod(Class<?> testClass, String methodName) {
        String className = testClass.getCanonicalName();
        String methodClass = String.class.getName();
        String msg = String.format("Cannot @AutoClose field %s.field because %s does not define method %s().",
                className, methodClass, methodName);
        Events tests = executeTestsForClass(testClass).testEvents();
        assertFailingWithMessage(tests, msg);
    }

    interface TestInterface {
        @Test
        default void test() {}
    }

    static class BlankCloseMethodNameTestCase implements TestInterface {
        @AutoClose("")
        final String field = "blank";
    }

    static class PrimitiveFieldTestCase implements TestInterface {
        @AutoClose
        final int x = 0;
    }

    static class ArrayFieldTestCase implements TestInterface {
        @AutoClose
        final int[] x = {};
    }

    static class NullCloseableFieldTestCase implements TestInterface {
        @AutoClose
        final AutoCloseable field = null;
    }

    static class NoCloseMethodTestCase implements TestInterface {
        @AutoClose
        private final String field = "";
    }

    @Retention(RetentionPolicy.RUNTIME)
    @AutoClose("shutdown")
    @interface AutoShutdown {
    }

    static class NoShutdownMethodTestCase implements TestInterface {
        @AutoShutdown
        private final String field = "";
    }

    @TestInstance(PER_METHOD)
    static class InstancePerMethodTestCase {
        @AutoClose
        private static AutoCloseable staticClosable;
        @AutoClose
        private static final AutoCloseable nullStatic = null;
        @AutoClose
        private final AutoCloseable closable = new AutoCloseSpy("closable");
        @AutoClose("   run      ") // intentionally contains extra whitespace.
        private final Runnable runnable = new AutoCloseSpy("runnable");
        @AutoClose
        private final AutoCloseable nullField = null;

        @BeforeAll
        static void setup() {
            staticClosable = new AutoCloseSpy("staticClosable");
        }

        @Test
        void test1() { }

        @Test
        void test2() { }
    }

    @TestInstance(PER_CLASS)
    static class InstancePerClassTestCase {
        static boolean closed = false;

        @AutoClose
        final AutoCloseable field = () -> closed = true;

        @Test
        void test1() {
            assertThat(closed).isFalse();
        }

        @Test
        void test2() {
            assertThat(closed).isFalse();
        }
    }

    @TestInstance(PER_METHOD)
    static class InstancePerMethodEnclosingTestCase implements TestInterface {
        @AutoClose
        static AutoCloseSpy enclosingStaticClosable;

        @AutoClose
        final AutoCloseable enclosingClosable = new AutoCloseSpy("enclosingClosable");

        @BeforeAll
        static void setup() {
            enclosingStaticClosable = new AutoCloseSpy("enclosingStaticClosable");
        }

        @Nested
        @TestInstance(PER_METHOD)
        class NestedTestCase implements TestInterface {
            @AutoClose
            static AutoCloseSpy nestedStaticClosable;

            @AutoClose
            final AutoCloseable nestedClosable = new AutoCloseSpy("nestedClosable");

            @BeforeAll
            static void setup() {
                nestedStaticClosable = new AutoCloseSpy("nestedStaticClosable");
            }
        }
    }

    @TestInstance(PER_CLASS)
    static class InstancePerClassEnclosingTestCase implements TestInterface {
        @AutoClose
        static AutoCloseSpy enclosingStaticClosable;

        @AutoClose
        final AutoCloseable enclosingClosable = new AutoCloseSpy("enclosingClosable");

        @BeforeAll
        static void setup() {
            enclosingStaticClosable = new AutoCloseSpy("enclosingStaticClosable");
        }

        @Nested
        @TestInstance(PER_CLASS)
        class NestedTestCase implements TestInterface {
            @AutoClose
            static AutoCloseSpy nestedStaticClosable;

            @AutoClose
            final AutoCloseable nestedClosable = new AutoCloseSpy("nestedClosable");

            @BeforeAll
            static void setup() {
                nestedStaticClosable = new AutoCloseSpy("nestedStaticClosable");
            }
        }
    }

    static class SuperTestCase {
        @AutoClose
        static AutoCloseable superStaticClosable;

        @AutoClose
        final AutoCloseable superClosable = new AutoCloseSpy("superClosable");

        @BeforeAll
        // WARNING: if this method is named setup() AND the @BeforeAll method in
        // SubTestCase is also named setup(), the latter will "hide" the former.
        static void superSetup() {
            superStaticClosable = new AutoCloseSpy("superStaticClosable");
        }

        @Test
        void superTest() {}
    }

    static class SubTestCase extends SuperTestCase {
        @AutoClose
        static AutoCloseable subStaticClosable;

        @AutoClose
        final AutoCloseable subClosable = new AutoCloseSpy("subClosable");

        @BeforeAll
        static void subSetup() {
            subStaticClosable = new AutoCloseSpy("subStaticClosable");
        }

        @Test
        void subTest() { }
    }

    static class FailingFieldsTestCase {
        @AutoClose
        static AutoCloseable staticField1;
        @AutoClose
        static AutoCloseable staticField2;
        @AutoClose
        static AutoCloseable staticField3;

        @AutoClose
        final AutoCloseable field1 = new AutoCloseSpy("field1", true);
        @AutoClose
        final AutoCloseable field2 = new AutoCloseSpy("field2", true);
        @AutoClose
        final AutoCloseable field3 = new AutoCloseSpy("field3", false);

        @BeforeAll
        static void setup() {
            staticField1 = new AutoCloseSpy("staticField1", true);
            staticField2 = new AutoCloseSpy("staticField2", true);
            staticField3 = new AutoCloseSpy("staticField3", false);
        }

        @Test
        void test() { }
    }

    static class AutoCloseSpy implements AutoCloseable, Runnable {
        private final String prefix;
        private final boolean fail;
        private String invokedMethod = null;

        AutoCloseSpy(String prefix) {
            Class<?> callerClass = StackWalker.getInstance(RETAIN_CLASS_REFERENCE).getCallerClass();
            this.fail = false;
            this.prefix = callerClass.getSimpleName() + "." + prefix + ".";
        }

        AutoCloseSpy(String prefix, boolean fail) {
            Class<?> callerClass = StackWalker.getInstance(RETAIN_CLASS_REFERENCE).getCallerClass();
            this.prefix = callerClass.getSimpleName() + "." + prefix + ".";
            this.fail = fail;
        }

        @Override
        public void run() {
            recordInvocation("run()");
        }

        @Override
        public void close() {
            recordInvocation("close()");
        }

        private void recordInvocation(String methodName) {
            if (this.invokedMethod != null) {
                throw new IllegalStateException("Already closed via " + this.invokedMethod);
            }
            this.invokedMethod = methodName;
            recorder.add(this.prefix + this.invokedMethod);
            if (this.fail) {
                throw new RuntimeException(this.prefix + this.invokedMethod);
            }
        }
    }

}
```

### **Summary of Refactoring**

- **Extracted variables for repeated class objects and their names** at the start of test methods.
- **Extracted test events** into named variables, especially when used multiple times in a method.
- **Reused message-formatting expression variables**.
- **Wave of refactoring makes repeated logic easier to change and reason about.**

There is no behavioral changeâ€”only improved readability, maintainability, and reduced repetition.
