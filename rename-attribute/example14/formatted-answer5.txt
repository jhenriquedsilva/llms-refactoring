package org.apache.lucene.analysis.path;

import java.io.IOException;

import org.apache.lucene.analysis.Tokenizer;
import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
import org.apache.lucene.util.AttributeFactory;
import org.apache.lucene.util.IgnoreRandomChains;

@IgnoreRandomChains(reason = "broken offsets")
public class PathHierarchyTokenizer extends Tokenizer {

    public PathHierarchyTokenizer() {
        this(DEFAULT_BUFFER_SIZE, DEFAULT_DELIMITER, DEFAULT_DELIMITER, DEFAULT_NUM_LEVELS_TO_SKIP);
    }

    public PathHierarchyTokenizer(int numLevelsToSkip) {
        this(DEFAULT_BUFFER_SIZE, DEFAULT_DELIMITER, DEFAULT_DELIMITER, numLevelsToSkip);
    }

    public PathHierarchyTokenizer(int bufferSize, char delimiter) {
        this(bufferSize, delimiter, delimiter, DEFAULT_NUM_LEVELS_TO_SKIP);
    }

    public PathHierarchyTokenizer(char delimiter, char replacement) {
        this(DEFAULT_BUFFER_SIZE, delimiter, replacement, DEFAULT_NUM_LEVELS_TO_SKIP);
    }

    public PathHierarchyTokenizer(char delimiter, char replacement, int numLevelsToSkip) {
        this(DEFAULT_BUFFER_SIZE, delimiter, replacement, numLevelsToSkip);
    }

    public PathHierarchyTokenizer(AttributeFactory factory, char delimiter, char replacement, int numLevelsToSkip) {
        this(factory, DEFAULT_BUFFER_SIZE, delimiter, replacement, numLevelsToSkip);
    }

    public PathHierarchyTokenizer(int bufferSize, char delimiter, char replacement, int numLevelsToSkip) {
        this(DEFAULT_TOKEN_ATTRIBUTE_FACTORY, bufferSize, delimiter, replacement, numLevelsToSkip);
    }

    public PathHierarchyTokenizer(AttributeFactory factory, int bufferSize, char delimiter, char replacement, int numLevelsToSkip) {
        super(factory);
        if (bufferSize < 0) {
            throw new IllegalArgumentException("bufferSize cannot be negative");
        }
        if (numLevelsToSkip < 0) {
            throw new IllegalArgumentException("numLevelsToSkip cannot be negative");
        }
        termAtt.resizeBuffer(bufferSize);
        this.delimiter = delimiter;
        this.replacement = replacement;
        this.numLevelsToSkip = numLevelsToSkip;
        currentPathBuffer = new StringBuilder(bufferSize);
    }

    private static final int DEFAULT_BUFFER_SIZE = 1024;
    public static final char DEFAULT_DELIMITER = '/';
    public static final int DEFAULT_NUM_LEVELS_TO_SKIP = 0;
    private final char delimiter;
    private final char replacement;
    private final int numLevelsToSkip;
    private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
    private final OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class);
    private final PositionIncrementAttribute posAtt = addAttribute(PositionIncrementAttribute.class);
    private int startOffset = 0;
    private int numLevelsSkipped = 0;
    private boolean justProcessedDelimiter = false;
    private StringBuilder currentPathBuffer;
    private int numCharsRead = 0;

    @Override
    public final boolean incrementToken() throws IOException {
        clearAttributes();
        termAtt.append(currentPathBuffer);
        posAtt.setPositionIncrement(1);
        int length = 0;
        boolean added = false;
        if (justProcessedDelimiter) {
            termAtt.append(replacement);
            length++;
            justProcessedDelimiter = false;
            added = true;
        }
        while (true) {
            int c = input.read();
            if (c >= 0) {
                numCharsRead++;
            } else {
                if (numLevelsSkipped > numLevelsToSkip) {
                    length += currentPathBuffer.length();
                    termAtt.setLength(length);
                    offsetAtt.setOffset(correctOffset(startOffset), correctOffset(startOffset + length));
                    if (added) {
                        currentPathBuffer.setLength(0);
                        currentPathBuffer.append(termAtt.buffer(), 0, length);
                    }
                    return added;
                } else {
                    return false;
                }
            }
            if (!added) {
                added = true;
                numLevelsSkipped++;
                if (numLevelsSkipped > numLevelsToSkip) {
                    termAtt.append(c == delimiter ? replacement : (char) c);
                    length++;
                } else {
                    startOffset++;
                }
            } else {
                if (c == delimiter) {
                    if (numLevelsSkipped > numLevelsToSkip) {
                        justProcessedDelimiter = true;
                        break;
                    }
                    numLevelsSkipped++;
                    if (numLevelsSkipped > numLevelsToSkip) {
                        termAtt.append(replacement);
                        length++;
                    } else {
                        startOffset++;
                    }
                } else {
                    if (numLevelsSkipped > numLevelsToSkip) {
                        termAtt.append((char) c);
                        length++;
                    } else {
                        startOffset++;
                    }
                }
            }
        }
        length += currentPathBuffer.length();
        termAtt.setLength(length);
        offsetAtt.setOffset(correctOffset(startOffset), correctOffset(startOffset + length));
        currentPathBuffer.setLength(0);
        currentPathBuffer.append(termAtt.buffer(), 0, length);
        return true;
    }

    @Override
    public final void end() throws IOException {
        super.end();
        int finalOffset = correctOffset(numCharsRead);
        offsetAtt.setOffset(finalOffset, finalOffset);
    }

    @Override
    public void reset() throws IOException {
        super.reset();
        currentPathBuffer.setLength(0);
        numCharsRead = 0;
        justProcessedDelimiter = false;
        numLevelsSkipped = 0;
        startOffset = 0;
    }
}