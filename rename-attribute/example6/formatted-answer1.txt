package org.apache.hadoop.ipc;

import java.util.Arrays;
import java.util.UUID;
import java.util.concurrent.locks.ReentrantLock;

import org.apache.hadoop.classification.InterfaceAudience;
import org.apache.hadoop.ipc.metrics.RetryCacheMetrics;
import org.apache.hadoop.util.LightWeightCache;
import org.apache.hadoop.util.LightWeightGSet;
import org.apache.hadoop.util.LightWeightGSet.LinkedElement;
import org.apache.hadoop.classification.VisibleForTesting;
import org.apache.hadoop.util.Preconditions;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@InterfaceAudience.Private
public class RetryCache {
    public static final Logger LOG = LoggerFactory.getLogger(RetryCache.class);
    private final RetryCacheMetrics retryCacheMetrics;
    private static final int MAX_CAPACITY = 16;

    public static class CacheEntry implements LightWeightCache.Entry {
        private static final byte INPROGRESS = 0;
        private static final byte SUCCESS = 1;
        private static final byte FAILED = 2;
        private byte state = INPROGRESS;
        private final long clientIdMostSignificantBits;
        private final long clientIdLeastSignificantBits;
        private final int callId;
        private final long expirationTime;
        private LightWeightGSet.LinkedElement next;

        CacheEntry(byte[] clientId, int callId, long expirationTime) {
            Preconditions.checkArgument(clientId.length == ClientId.BYTE_LENGTH, "Invalid clientId - length is " + clientId.length + " expected length " + ClientId.BYTE_LENGTH);
            clientIdMostSignificantBits = ClientId.getMsb(clientId);
            clientIdLeastSignificantBits = ClientId.getLsb(clientId);
            this.callId = callId;
            this.expirationTime = expirationTime;
        }

        CacheEntry(byte[] clientId, int callId, long expirationTime, boolean success) {
            this(clientId, callId, expirationTime);
            this.state = success ? SUCCESS : FAILED;
        }

        private static int hashCode(long value) {
            return (int) (value ^ (value >>> 32));
        }

        @Override
        public int hashCode() {
            return (hashCode(clientIdMostSignificantBits) * 31 + hashCode(clientIdLeastSignificantBits)) * 31 + callId;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (!(obj instanceof CacheEntry)) {
                return false;
            }
            CacheEntry other = (CacheEntry) obj;
            return callId == other.callId && clientIdMostSignificantBits == other.clientIdMostSignificantBits && clientIdLeastSignificantBits == other.clientIdLeastSignificantBits;
        }

        @Override
        public void setNext(LinkedElement next) {
            this.next = next;
        }

        @Override
        public LinkedElement getNext() {
            return next;
        }

        synchronized void completed(boolean success) {
            state = success ? SUCCESS : FAILED;
            this.notifyAll();
        }

        public synchronized boolean isSuccess() {
            return state == SUCCESS;
        }

        @Override
        public void setExpirationTime(long timeNano) {
        }

        @Override
        public long getExpirationTime() {
            return expirationTime;
        }

        @Override
        public String toString() {
            return String.format("%s:%s:%s", new UUID(this.clientIdMostSignificantBits, this.clientIdLeastSignificantBits), this.callId, this.state);
        }
    }

    public static class CacheEntryWithPayload extends CacheEntry {
        private Object responsePayload;

        CacheEntryWithPayload(byte[] clientId, int callId, Object responsePayload, long expirationTime) {
            super(clientId, callId, expirationTime);
            this.responsePayload = responsePayload;
        }

        CacheEntryWithPayload(byte[] clientId, int callId, Object responsePayload, long expirationTime, boolean success) {
            super(clientId, callId, expirationTime, success);
            this.responsePayload = responsePayload;
        }

        @Override
        public boolean equals(Object obj) {
            return super.equals(obj);
        }

        @Override
        public int hashCode() {
            return super.hashCode();
        }

        public Object getResponsePayload() {
            return responsePayload;
        }
    }

    private final LightWeightGSet<CacheEntry, CacheEntry> cacheSet;
    private final long expirationTime;
    private final String cacheName;
    private final ReentrantLock cacheLock = new ReentrantLock();

    public RetryCache(String cacheName, double percentage, long expirationTime) {
        int capacity = LightWeightGSet.computeCapacity(percentage, cacheName);
        capacity = Math.max(capacity, MAX_CAPACITY);
        this.cacheSet = new LightWeightCache<CacheEntry, CacheEntry>(capacity, capacity, expirationTime, 0);
        this.expirationTime = expirationTime;
        this.cacheName = cacheName;
        this.retryCacheMetrics = RetryCacheMetrics.create(this);
    }

    private static boolean skipRetryCache(byte[] clientId, int callId) {
        return !Server.isRpcInvocation() || callId < 0 || Arrays.equals(clientId, RpcConstants.DUMMY_CLIENT_ID);
    }

    public void lock() {
        this.cacheLock.lock();
    }

    public void unlock() {
        this.cacheLock.unlock();
    }

    private void incrCacheClearedCounter() {
        retryCacheMetrics.incrCacheCleared();
    }

    @VisibleForTesting
    public LightWeightGSet<CacheEntry, CacheEntry> getCacheSet() {
        return cacheSet;
    }

    @VisibleForTesting
    public RetryCacheMetrics getMetricsForTests() {
        return retryCacheMetrics;
    }

    public String getCacheName() {
        return cacheName;
    }

    private CacheEntry waitForCompletion(CacheEntry newEntry) {
        CacheEntry mapEntry = null;
        cacheLock.lock();
        try {
            mapEntry = cacheSet.get(newEntry);
            if (mapEntry == null) {
                if (LOG.isTraceEnabled()) {
                    LOG.trace("Adding Rpc request clientId " + newEntry.clientIdMostSignificantBits + newEntry.clientIdLeastSignificantBits + " callId " + newEntry.callId + " to retryCache");
                }
                cacheSet.put(newEntry);
                retryCacheMetrics.incrCacheUpdated();
                return newEntry;
            } else {
                retryCacheMetrics.incrCacheHit();
            }
        } finally {
            cacheLock.unlock();
        }
        Preconditions.checkNotNull(mapEntry, "Entry from the cache should not be null");
        synchronized (mapEntry) {
            while (mapEntry.state == CacheEntry.INPROGRESS) {
                try {
                    mapEntry.wait();
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                }
            }
            if (mapEntry.state != CacheEntry.SUCCESS) {
                mapEntry.state = CacheEntry.INPROGRESS;
            }
        }
        return mapEntry;
    }

    public void addCacheEntry(byte[] clientId, int callId) {
        CacheEntry newEntry = new CacheEntry(clientId, callId, System.nanoTime() + expirationTime, true);
        cacheLock.lock();
        try {
            cacheSet.put(newEntry);
        } finally {
            cacheLock.unlock();
        }
        retryCacheMetrics.incrCacheUpdated();
    }

    public void addCacheEntryWithPayload(byte[] clientId, int callId, Object responsePayload) {
        CacheEntry newEntry = new CacheEntryWithPayload(clientId, callId, responsePayload, System.nanoTime() + expirationTime, true);
        cacheLock.lock();
        try {
            cacheSet.put(newEntry);
        } finally {
            cacheLock.unlock();
        }
        retryCacheMetrics.incrCacheUpdated();
    }

    private static CacheEntry newEntry(long expirationTime, byte[] clientId, int callId) {
        return new CacheEntry(clientId, callId, System.nanoTime() + expirationTime);
    }

    private static CacheEntryWithPayload newEntry(Object responsePayload, long expirationTime, byte[] clientId, int callId) {
        return new CacheEntryWithPayload(clientId, callId, responsePayload, System.nanoTime() + expirationTime);
    }

    public static CacheEntry waitForCompletion(RetryCache cache, byte[] clientId, int callId) {
        if (skipRetryCache(clientId, callId)) {
            return null;
        }
        return cache != null ? cache.waitForCompletion(newEntry(cache.expirationTime, clientId, callId)) : null;
    }

    public static CacheEntryWithPayload waitForCompletion(RetryCache cache, Object responsePayload, byte[] clientId, int callId) {
        if (skipRetryCache(clientId, callId)) {
            return null;
        }
        return (CacheEntryWithPayload) (cache != null ? cache.waitForCompletion(newEntry(responsePayload, cache.expirationTime, clientId, callId)) : null);
    }

    public static void setState(CacheEntry e, boolean success) {
        if (e == null) {
            return;
        }
        e.completed(success);
    }

    public static void setState(CacheEntryWithPayload e, boolean success, Object responsePayload) {
        if (e == null) {
            return;
        }
        e.responsePayload = responsePayload;
        e.completed(success);
    }

    public static void clear(RetryCache cache) {
        if (cache != null) {
            cache.cacheSet.clear();
            cache.incrCacheClearedCounter();
        }
    }
}