package org.apache.flink.table.planner.hint;

import org.apache.calcite.rel.BiRel;
import org.apache.calcite.rel.RelNode;
import org.apache.calcite.rel.RelShuttleImpl;
import org.apache.calcite.rel.hint.Hintable;
import org.apache.calcite.rel.hint.RelHint;
import org.apache.calcite.rel.logical.LogicalCorrelate;
import org.apache.calcite.rel.logical.LogicalJoin;
import org.apache.calcite.sql.SqlNode;
import org.apache.calcite.sql2rel.SqlToRelConverter;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

public class ClearQueryHintsWithInvalidPropagationShuttle extends QueryHintsRelShuttle {

    @Override
    protected RelNode visitBiRel(BiRel binaryRelNode) {
        List<RelHint> hints = ((Hintable) binaryRelNode).getHints();
        Set<String> allHintNames = hints.stream().map(hint -> hint.hintName).collect(Collectors.toSet());
        if (allHintNames.stream().noneMatch(FlinkHints::isQueryHint)) {
            return super.visit(binaryRelNode);
        }
        Optional<RelHint> firstAliasHint = hints.stream().filter(hint -> FlinkHints.HINT_ALIAS.equals(hint.hintName)).findFirst();
        if (!firstAliasHint.isPresent()) {
            return super.visit(binaryRelNode);
        }
        List<RelHint> queryHintsFromOuterQueryBlock = hints.stream().filter(hint -> FlinkHints.isQueryHint(hint.hintName) && hint.inheritPath.size() > firstAliasHint.get().inheritPath.size()).collect(Collectors.toList());
        if (queryHintsFromOuterQueryBlock.isEmpty()) {
            return super.visit(binaryRelNode);
        }
        RelNode newRelNode = binaryRelNode;
        ClearOuterQueryHintShuttle clearOuterQueryHintShuttle;
        for (RelHint outerQueryHint : queryHintsFromOuterQueryBlock) {
            clearOuterQueryHintShuttle = new ClearOuterQueryHintShuttle(outerQueryHint);
            newRelNode = newRelNode.accept(clearOuterQueryHintShuttle);
        }
        return super.visit(newRelNode);
    }

    private static class ClearOuterQueryHintShuttle extends RelShuttleImpl {
        private final Deque<Integer> currentInheritPath;

        private final RelHint queryHintToRemove;

        public ClearOuterQueryHintShuttle(RelHint queryHintToRemove) {
            this.queryHintToRemove = queryHintToRemove;
            this.currentInheritPath = new ArrayDeque<>();
            this.currentInheritPath.addAll(queryHintToRemove.inheritPath);
        }

        @Override
        protected RelNode visitChild(RelNode parent, int index, RelNode child) {
            currentInheritPath.addLast(index);
            RelNode newNode = super.visitChild(parent, index, child);
            currentInheritPath.removeLast();
            return newNode;
        }

        @Override
        public RelNode visit(LogicalCorrelate correlate) {
            return visitBiRel(correlate);
        }

        @Override
        public RelNode visit(LogicalJoin join) {
            return visitBiRel(join);
        }

        private RelNode visitBiRel(BiRel binaryRelNode) {
            Hintable hintableBinaryRel = (Hintable) binaryRelNode;
            List<RelHint> hints = new ArrayList<>(hintableBinaryRel.getHints());
            Optional<RelHint> invalidQueryHint = getInvalidQueryHint(hints);
            if (invalidQueryHint.isPresent()) {
                hints.remove(invalidQueryHint.get());
                return super.visit(hintableBinaryRel.withHints(hints));
            }
            return super.visit(binaryRelNode);
        }

        private Optional<RelHint> getInvalidQueryHint(List<RelHint> hints) {
            for (RelHint hint : hints) {
                if (hint.hintName.equals(queryHintToRemove.hintName) && isMatchInvalidInheritPath(new ArrayList<>(currentInheritPath), hint.inheritPath)) {
                    return Optional.of(hint);
                }
            }
            return Optional.empty();
        }

        private boolean isMatchInvalidInheritPath(List<Integer> expectedInheritPath, List<Integer> actualInheritPath) {
            if (expectedInheritPath.size() != actualInheritPath.size()) {
                return false;
            }
            for (int i = 0; i < expectedInheritPath.size(); i++) {
                if (!Objects.equals(expectedInheritPath.get(i), actualInheritPath.get(i))) {
                    return false;
                }
            }
            return true;
        }
    }
}