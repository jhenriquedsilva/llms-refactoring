29-04-2025, 20:33

Certainly! Upon reviewing the code, several method names could be improved to increase clarity and self-documentation. Here are notable candidates for **rename method refactoring**:

### Refactoring Opportunities

#### 1. **getFilters**
Current Name:
```java
private List<Filter> getFilters(AssertableWebApplicationContext context, Class<? extends Filter> filter)
```
- Problem: Ambiguous, does not identify from _where_ filters are fetched, or for _what_ purpose.
- Suggestion: `findFiltersInSecurityChain` or `findFiltersOfType`

#### 2. **getSecurityFilterChain**
Current Name:
```java
private SecurityFilterChain getSecurityFilterChain(AssertableWebApplicationContext context)
```
- Problem: Sounds like it returns the main/a single security filter chain, but might be ambiguous in multi-chain scenarios.
- Suggestion: `getFirstSecurityFilterChain`

#### 3. **getFilterChainProxy**
Current Name:
```java
private FilterChainProxy getFilterChainProxy(Filter filter)
```
- Problem: The logic is actually deciphering or _extracting_ the first FilterChainProxy, not just a trivial getter.
- Suggestion: `extractFilterChainProxy`

#### 4. **isEqual**
Current Name:
```java
private boolean isEqual(ClientRegistration reg1, ClientRegistration reg2)
```
- Problem: Sounds generic, does not convey that this is a deep comparison specific for `ClientRegistration`.
- Suggestion: `areClientRegistrationsEqual`

#### 5. **getClientRegistration**
Current Name:
```java
private ClientRegistration getClientRegistration(String id, String userInfoUri)
```
- Problem: The prefix "get" is typically for trivial getters; here it actually _creates_ a new registration object.
- Suggestion: `createClientRegistration`

### Refactored Class

Below is the class with refactored method names, with all usages fixed accordingly for consistency:

```java
package org.springframework.boot.autoconfigure.security.oauth2.client.servlet;

import java.util.ArrayList;
import java.util.List;

import jakarta.servlet.Filter;
import org.junit.jupiter.api.Test;

import org.springframework.boot.autoconfigure.AutoConfigurations;
import org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration;
import org.springframework.boot.test.context.FilteredClassLoader;
import org.springframework.boot.test.context.assertj.AssertableWebApplicationContext;
import org.springframework.boot.test.context.runner.WebApplicationContextRunner;
import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.security.config.BeanIds;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.oauth2.client.InMemoryOAuth2AuthorizedClientService;
import org.springframework.security.oauth2.client.OAuth2AuthorizedClientService;
import org.springframework.security.oauth2.client.registration.ClientRegistration;
import org.springframework.security.oauth2.client.registration.ClientRegistrationRepository;
import org.springframework.security.oauth2.client.registration.InMemoryClientRegistrationRepository;
import org.springframework.security.oauth2.client.web.AuthenticatedPrincipalOAuth2AuthorizedClientRepository;
import org.springframework.security.oauth2.client.web.OAuth2AuthorizationCodeGrantFilter;
import org.springframework.security.oauth2.client.web.OAuth2AuthorizedClientRepository;
import org.springframework.security.oauth2.client.web.OAuth2LoginAuthenticationFilter;
import org.springframework.security.oauth2.core.AuthorizationGrantType;
import org.springframework.security.web.FilterChainProxy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.test.util.ReflectionTestUtils;
import org.springframework.util.ObjectUtils;
import org.springframework.web.filter.CompositeFilter;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Tests for {@link OAuth2WebSecurityConfiguration}.
 *
 * @author Madhura Bhave
 */
class OAuth2WebSecurityConfigurationTests {

    private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner();

    @Test
    void securityConfigurerConfiguresOAuth2Login() {
        this.contextRunner
                .withUserConfiguration(ClientRegistrationRepositoryConfiguration.class,
                        OAuth2WebSecurityConfiguration.class)
                .run((context) -> {
                    ClientRegistrationRepository expected = context.getBean(ClientRegistrationRepository.class);
                    ClientRegistrationRepository actual = (ClientRegistrationRepository) ReflectionTestUtils.getField(
                            findFiltersOfType(context, OAuth2LoginAuthenticationFilter.class).get(0),
                            "clientRegistrationRepository");
                    assertThat(areClientRegistrationsEqual(expected.findByRegistrationId("first"), actual.findByRegistrationId("first")))
                            .isTrue();
                    assertThat(areClientRegistrationsEqual(expected.findByRegistrationId("second"), actual.findByRegistrationId("second")))
                            .isTrue();
                });
    }

    @Test
    void securityConfigurerConfiguresAuthorizationCode() {
        this.contextRunner
                .withUserConfiguration(ClientRegistrationRepositoryConfiguration.class,
                        OAuth2WebSecurityConfiguration.class)
                .run((context) -> {
                    ClientRegistrationRepository expected = context.getBean(ClientRegistrationRepository.class);
                    ClientRegistrationRepository actual = (ClientRegistrationRepository) ReflectionTestUtils.getField(
                            findFiltersOfType(context, OAuth2AuthorizationCodeGrantFilter.class).get(0),
                            "clientRegistrationRepository");
                    assertThat(areClientRegistrationsEqual(expected.findByRegistrationId("first"), actual.findByRegistrationId("first")))
                            .isTrue();
                    assertThat(areClientRegistrationsEqual(expected.findByRegistrationId("second"), actual.findByRegistrationId("second")))
                            .isTrue();
                });
    }

    @Test
    void securityConfigurerBacksOffWhenClientRegistrationBeanAbsent() {
        this.contextRunner.withUserConfiguration(TestConfig.class, OAuth2WebSecurityConfiguration.class)
                .run((context) -> {
                    assertThat(findFiltersOfType(context, OAuth2LoginAuthenticationFilter.class)).isEmpty();
                    assertThat(findFiltersOfType(context, OAuth2AuthorizationCodeGrantFilter.class)).isEmpty();
                });
    }

    @Test
    void configurationRegistersAuthorizedClientServiceBean() {
        this.contextRunner
                .withUserConfiguration(ClientRegistrationRepositoryConfiguration.class,
                        OAuth2WebSecurityConfiguration.class)
                .run((context) -> assertThat(context).hasSingleBean(OAuth2AuthorizedClientService.class));
    }

    @Test
    void configurationRegistersAuthorizedClientRepositoryBean() {
        this.contextRunner
                .withUserConfiguration(ClientRegistrationRepositoryConfiguration.class,
                        OAuth2WebSecurityConfiguration.class)
                .run((context) -> assertThat(context).hasSingleBean(OAuth2AuthorizedClientRepository.class));
    }

    @Test
    void securityFilterChainConfigBacksOffWhenOtherSecurityFilterChainBeanPresent() {
        this.contextRunner.withConfiguration(AutoConfigurations.of(WebMvcAutoConfiguration.class))
                .withUserConfiguration(TestSecurityFilterChainConfiguration.class, OAuth2WebSecurityConfiguration.class)
                .run((context) -> {
                    assertThat(findFiltersOfType(context, OAuth2LoginAuthenticationFilter.class)).isEmpty();
                    assertThat(findFiltersOfType(context, OAuth2AuthorizationCodeGrantFilter.class)).isEmpty();
                    assertThat(context).getBean(OAuth2AuthorizedClientService.class).isNotNull();
                });
    }

    @Test
    void securityFilterChainConfigConditionalOnSecurityFilterChainClass() {
        this.contextRunner
                .withUserConfiguration(ClientRegistrationRepositoryConfiguration.class,
                        OAuth2WebSecurityConfiguration.class)
                .withClassLoader(new FilteredClassLoader(SecurityFilterChain.class))
                .run((context) -> {
                    assertThat(findFiltersOfType(context, OAuth2LoginAuthenticationFilter.class)).isEmpty();
                    assertThat(findFiltersOfType(context, OAuth2AuthorizationCodeGrantFilter.class)).isEmpty();
                });
    }

    @Test
    void authorizedClientServiceBeanIsConditionalOnMissingBean() {
        this.contextRunner
                .withUserConfiguration(OAuth2AuthorizedClientServiceConfiguration.class,
                        OAuth2WebSecurityConfiguration.class)
                .run((context) -> {
                    assertThat(context).hasSingleBean(OAuth2AuthorizedClientService.class);
                    assertThat(context).hasBean("testAuthorizedClientService");
                });
    }

    @Test
    void authorizedClientRepositoryBeanIsConditionalOnMissingBean() {
        this.contextRunner
                .withUserConfiguration(OAuth2AuthorizedClientRepositoryConfiguration.class,
                        OAuth2WebSecurityConfiguration.class)
                .run((context) -> {
                    assertThat(context).hasSingleBean(OAuth2AuthorizedClientRepository.class);
                    assertThat(context).hasBean("testAuthorizedClientRepository");
                });
    }

    private List<Filter> findFiltersOfType(AssertableWebApplicationContext context, Class<? extends Filter> filterType) {
        return getFirstSecurityFilterChain(context).getFilters().stream().filter(filterType::isInstance).toList();
    }

    private SecurityFilterChain getFirstSecurityFilterChain(AssertableWebApplicationContext context) {
        Filter springSecurityFilterChain = context.getBean(BeanIds.SPRING_SECURITY_FILTER_CHAIN, Filter.class);
        FilterChainProxy filterChainProxy = extractFilterChainProxy(springSecurityFilterChain);
        SecurityFilterChain securityFilterChain = filterChainProxy.getFilterChains().get(0);
        return securityFilterChain;
    }

    private FilterChainProxy extractFilterChainProxy(Filter filter) {
        if (filter instanceof FilterChainProxy filterChainProxy) {
            return filterChainProxy;
        }
        if (filter instanceof CompositeFilter) {
            List<?> filters = (List<?>) ReflectionTestUtils.getField(filter, "filters");
            return (FilterChainProxy) filters.stream()
                    .filter(FilterChainProxy.class::isInstance)
                    .findFirst()
                    .orElseThrow();
        }
        throw new IllegalStateException("No FilterChainProxy found");
    }

    private boolean areClientRegistrationsEqual(ClientRegistration reg1, ClientRegistration reg2) {
        boolean result = ObjectUtils.nullSafeEquals(reg1.getClientId(), reg2.getClientId());
        result = result && ObjectUtils.nullSafeEquals(reg1.getClientName(), reg2.getClientName());
        result = result && ObjectUtils.nullSafeEquals(reg1.getClientSecret(), reg2.getClientSecret());
        result = result && ObjectUtils.nullSafeEquals(reg1.getScopes(), reg2.getScopes());
        result = result && ObjectUtils.nullSafeEquals(reg1.getRedirectUri(), reg2.getRedirectUri());
        result = result && ObjectUtils.nullSafeEquals(reg1.getRegistrationId(), reg2.getRegistrationId());
        result = result
                && ObjectUtils.nullSafeEquals(reg1.getAuthorizationGrantType(), reg2.getAuthorizationGrantType());
        result = result && ObjectUtils.nullSafeEquals(reg1.getProviderDetails().getAuthorizationUri(),
                reg2.getProviderDetails().getAuthorizationUri());
        result = result && ObjectUtils.nullSafeEquals(reg1.getProviderDetails().getUserInfoEndpoint(),
                reg2.getProviderDetails().getUserInfoEndpoint());
        result = result && ObjectUtils.nullSafeEquals(reg1.getProviderDetails().getTokenUri(),
                reg2.getProviderDetails().getTokenUri());
        return result;
    }

    @Configuration(proxyBeanMethods = false)
    @EnableWebSecurity
    static class TestConfig {

        @Bean
        TomcatServletWebServerFactory tomcat() {
            return new TomcatServletWebServerFactory(0);
        }

    }

    @Configuration(proxyBeanMethods = false)
    @Import(TestConfig.class)
    static class ClientRegistrationRepositoryConfiguration {

        @Bean
        ClientRegistrationRepository clientRegistrationRepository() {
            List<ClientRegistration> registrations = new ArrayList<>();
            registrations.add(createClientRegistration("first", "https://user-info-uri.com"));
            registrations.add(createClientRegistration("second", "https://other-user-info"));
            return new InMemoryClientRegistrationRepository(registrations);
        }

        private ClientRegistration createClientRegistration(String id, String userInfoUri) {
            ClientRegistration.Builder builder = ClientRegistration.withRegistrationId(id);
            builder.clientName("foo")
                    .clientId("foo")
                    .clientAuthenticationMethod(
                            org.springframework.security.oauth2.core.ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                    .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                    .scope("read")
                    .clientSecret("secret")
                    .redirectUri("https://redirect-uri.com")
                    .authorizationUri("https://authorization-uri.com")
                    .tokenUri("https://token-uri.com")
                    .userInfoUri(userInfoUri)
                    .userNameAttributeName("login");
            return builder.build();
        }

    }

    @Configuration(proxyBeanMethods = false)
    @Import(ClientRegistrationRepositoryConfiguration.class)
    static class TestSecurityFilterChainConfiguration {

        @Bean
        SecurityFilterChain testSecurityFilterChain(HttpSecurity http) throws Exception {
            return http.securityMatcher("/**")
                    .authorizeHttpRequests((authorize) -> authorize.anyRequest().authenticated())
                    .build();

        }

    }

    @Configuration(proxyBeanMethods = false)
    @Import(ClientRegistrationRepositoryConfiguration.class)
    static class OAuth2AuthorizedClientServiceConfiguration {

        @Bean
        OAuth2AuthorizedClientService testAuthorizedClientService(
                ClientRegistrationRepository clientRegistrationRepository) {
            return new InMemoryOAuth2AuthorizedClientService(clientRegistrationRepository);
        }

    }

    @Configuration(proxyBeanMethods = false)
    @Import(ClientRegistrationRepositoryConfiguration.class)
    static class OAuth2AuthorizedClientRepositoryConfiguration {

        @Bean
        OAuth2AuthorizedClientRepository testAuthorizedClientRepository(
                OAuth2AuthorizedClientService authorizedClientService) {
            return new AuthenticatedPrincipalOAuth2AuthorizedClientRepository(authorizedClientService);
        }

    }

}
```

---

**Summary:**
The above refactorings focus on improving code readability and intent expression by making method names more descriptive regarding what they do and what entities they act upon. This should improve maintainability and onboarding for other team members.

Compiles
Tests pass