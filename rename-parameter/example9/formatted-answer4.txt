package com.intellij.util.indexing;

import com.intellij.navigation.ItemPresentation;
import com.intellij.openapi.application.ReadAction;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.module.Module;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.projectRoots.Sdk;
import com.intellij.openapi.roots.AdditionalLibraryRootsProvider;
import com.intellij.openapi.roots.SyntheticLibrary;
import com.intellij.openapi.util.Pair;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.openapi.vfs.VfsUtilCore;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.platform.backend.workspace.WorkspaceModel;
import com.intellij.platform.workspace.jps.entities.LibraryId;
import com.intellij.platform.workspace.jps.entities.ModuleId;
import com.intellij.platform.workspace.storage.EntityPointer;
import com.intellij.platform.workspace.storage.EntityStorage;
import com.intellij.platform.workspace.storage.WorkspaceEntity;
import com.intellij.platform.backend.workspace.VirtualFileUrls;
import com.intellij.platform.workspace.storage.url.VirtualFileUrl;
import com.intellij.platform.workspace.storage.url.VirtualFileUrlManager;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.util.containers.MultiMap;
import com.intellij.util.indexing.roots.IndexableIteratorPresentation;
import com.intellij.util.indexing.roots.builders.IndexableIteratorBuilders;
import com.intellij.util.indexing.roots.builders.IndexableSetContributorFilesIteratorBuilder;
import com.intellij.util.indexing.roots.builders.SyntheticLibraryIteratorBuilder;
import com.intellij.util.indexing.roots.origin.IndexingUrlRootHolder;
import com.intellij.util.indexing.roots.origin.IndexingUrlSourceRootHolder;
import com.intellij.workspaceModel.core.fileIndex.WorkspaceFileIndex;
import com.intellij.workspaceModel.core.fileIndex.WorkspaceFileKind;
import com.intellij.workspaceModel.core.fileIndex.WorkspaceFileSet;
import com.intellij.workspaceModel.core.fileIndex.impl.WorkspaceFileIndexImpl;
import com.intellij.workspaceModel.core.fileIndex.impl.WorkspaceFileSetRecognizer;
import com.intellij.workspaceModel.ide.legacyBridge.ModuleBridge;
import org.jetbrains.annotations.ApiStatus;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.*;
import java.util.function.Predicate;

import static com.intellij.util.indexing.roots.IndexableEntityProvider.IndexableIteratorBuilder;

@ApiStatus.Experimental
public final class ReincludedRootsUtil {
    private static final Logger LOG = Logger.getInstance(ReincludedRootsUtil.class);

    private ReincludedRootsUtil() {
    }

    @NotNull
    public static Collection<IndexableIteratorBuilder> createBuildersForReincludedFiles(@NotNull Project project, @NotNull Collection<VirtualFile> reincludedFiles) {
        if (reincludedFiles.isEmpty()) return Collections.emptyList();
        return classifyFiles(project, reincludedFiles).createAllBuilders(project);
    }

    public interface Classifier {
        @NotNull Collection<VirtualFile> getFilesFromAdditionalLibraryRootsProviders();

        @NotNull Collection<IndexableIteratorBuilder> createBuildersFromWorkspaceFiles();

        Collection<IndexableIteratorBuilder> createBuildersFromFilesFromIndexableSetContributors(@NotNull Project project);

        @NotNull Collection<IndexableIteratorBuilder> createAllBuilders(@NotNull Project project);
    }

    @NotNull
    public static Classifier classifyFiles(@NotNull Project project, @NotNull Collection<VirtualFile> filesToClassify) {
        return new CustomizableRootsBuilder(project, filesToClassify);
    }

    private static final class CustomizableRootsBuilder implements Classifier {
        private final @NotNull EntityStorage entityStorage;
        private final Set<EntityPointer<?>> pointers = new HashSet<>();
        private final List<ModuleRootData<?>> moduleRootDataList = new ArrayList<>();
        private final List<ContentRootData<?>> contentRootDataList = new ArrayList<>();
        private final List<ExternalRootData<?>> externalRootDataList = new ArrayList<>();
        private final List<CustomKindRootData<?>> customKindRootDataList = new ArrayList<>();
        private final MultiMap<Sdk, VirtualFile> sdkToFileMap = MultiMap.createSet();
        private final MultiMap<LibraryId, VirtualFile> sourceFilesByLibrary = MultiMap.createSet();
        private final MultiMap<LibraryId, VirtualFile> classFilesByLibrary = MultiMap.createSet();
        private final List<VirtualFile> indexableSetContributorFiles = new ArrayList<>();
        private final List<VirtualFile> additionalLibraryRootsProviderFiles = new ArrayList<>();

        private CustomizableRootsBuilder(@NotNull Project project, @NotNull Collection<VirtualFile> filesToClassify) {
            entityStorage = WorkspaceModel.getInstance(project).getEntityStorage().getCurrent();
            classifyFiles(project, filesToClassify);
        }

        @Override
        public @NotNull Collection<VirtualFile> getFilesFromAdditionalLibraryRootsProviders() {
            return additionalLibraryRootsProviderFiles;
        }

        void classifyFiles(@NotNull Project project, @NotNull Collection<VirtualFile> filesToClassify) {
            WorkspaceFileIndex workspaceFileIndex = WorkspaceFileIndex.getInstance(project);
            VirtualFileUrlManager fileUrlManager = VirtualFileUrls.getVirtualFileUrlManager(project);
            for (VirtualFile file : filesToClassify) {
                WorkspaceFileSet fileSet = ReadAction.nonBlocking(() -> {
                    return workspaceFileIndex.findFileSet(file, true, true, true, true, true);
                }).expireWith(project).executeSynchronously();
                if (fileSet == null) {
                    indexableSetContributorFiles.add(file);
                    continue;
                }
                EntityPointer<?> entityPointer = WorkspaceFileSetRecognizer.INSTANCE.getEntityPointer(fileSet);
                if (fileSet.getKind() == WorkspaceFileKind.CONTENT || fileSet.getKind() == WorkspaceFileKind.TEST_CONTENT) {
                    LOG.assertTrue(entityPointer != null, "Content element's fileSet without entity reference, " + fileSet);
                    Module module = WorkspaceFileSetRecognizer.INSTANCE.getModuleForContent(fileSet);
                    VirtualFileUrl url = VirtualFileUrls.toVirtualFileUrl(file, fileUrlManager);
                    if (module != null) {
                        addModuleRoot(module, entityPointer, url);
                    } else {
                        addContentRoot(entityPointer, url);
                    }
                    continue;
                }
                Sdk sdk = WorkspaceFileSetRecognizer.INSTANCE.getSdk(fileSet);
                if (sdk != null) {
                    addSdkFile(sdk, file);
                    continue;
                }
                if (WorkspaceFileSetRecognizer.INSTANCE.isFromAdditionalLibraryRootsProvider(fileSet)) {
                    additionalLibraryRootsProviderFiles.add(file);
                    continue;
                }
                LibraryId libraryId = WorkspaceFileSetRecognizer.INSTANCE.getLibraryId(fileSet, entityStorage);
                if (libraryId != null) {
                    addLibraryFile(libraryId, file, fileSet.getKind() == WorkspaceFileKind.EXTERNAL_SOURCE);
                    continue;
                }
                LOG.assertTrue(entityPointer != null, "External element's fileSet without entity reference, " + fileSet);
                VirtualFileUrl url = VirtualFileUrls.toVirtualFileUrl(file, fileUrlManager);
                if (fileSet.getKind() == WorkspaceFileKind.EXTERNAL_SOURCE) {
                    addExternalRoots(entityPointer, Collections.emptyList(), Collections.singletonList(url));
                } else if (fileSet.getKind() == WorkspaceFileKind.EXTERNAL) {
                    addExternalRoots(entityPointer, Collections.singletonList(url), Collections.emptyList());
                } else {
                    addCustomKindRoot(entityPointer, url);
                }
            }
        }

        private void addModuleRoot(Module module, EntityPointer<?> moduleEntityPointer, VirtualFileUrl rootUrl) {
            moduleRootDataList.add(new ModuleRootData<>(moduleEntityPointer, ((ModuleBridge) module).getModuleEntityId(), rootUrl));
            pointers.add(moduleEntityPointer);
        }

        private void addContentRoot(EntityPointer<?> contentEntityPointer, VirtualFileUrl contentRootUrl) {
            contentRootDataList.add(new ContentRootData<>(contentEntityPointer, contentRootUrl));
            pointers.add(contentEntityPointer);
        }

        private void addExternalRoots(EntityPointer<?> externalEntityPointer, List<VirtualFileUrl> roots, List<VirtualFileUrl> sourceRoots) {
            externalRootDataList.add(new ExternalRootData<>(externalEntityPointer, roots, sourceRoots));
            pointers.add(externalEntityPointer);
        }

        private void addCustomKindRoot(EntityPointer<?> customEntityPointer, VirtualFileUrl customKindRootUrl) {
            customKindRootDataList.add(new CustomKindRootData<>(customEntityPointer, customKindRootUrl));
            pointers.add(customEntityPointer);
        }

        private void addSdkFile(Sdk sdk, VirtualFile sdkFile) {
            sdkToFileMap.putValue(sdk, sdkFile);
        }

        private void addLibraryFile(LibraryId libraryId, VirtualFile libraryFile, boolean isSource) {
            if (isSource) {
                sourceFilesByLibrary.putValue(libraryId, libraryFile);
            } else {
                classFilesByLibrary.putValue(libraryId, libraryFile);
            }
        }

        private record ModuleRootData<E extends WorkspaceEntity>(@NotNull EntityPointer<E> entityPointer,
                                                                 @NotNull ModuleId moduleId,
                                                                 @NotNull VirtualFileUrl url) {
            private @NotNull Collection<IndexableIteratorBuilder> createBuilders(Map<EntityPointer<?>, WorkspaceEntity> entityPointerMap, Map<Class<WorkspaceEntity>, CustomizingIndexingPresentationContributor<?>> presentationContributorMap) {
                IndexableIteratorPresentation presentation = findPresentation(entityPointer, entityPointerMap, presentationContributorMap);
                if (presentation == null) {
                    return IndexableIteratorBuilders.INSTANCE.forModuleRootsFileBased(moduleId, IndexingUrlRootHolder.Companion.fromUrl(url));
                }
                return IndexableIteratorBuilders.INSTANCE.forModuleAwareCustomizedContentEntity(moduleId, entityPointer, IndexingUrlRootHolder.Companion.fromUrl(url), presentation);
            }
        }

        private record ContentRootData<E extends WorkspaceEntity>(@NotNull EntityPointer<E> entityPointer,
                                                                  @NotNull VirtualFileUrl url) {
            public @NotNull Collection<IndexableIteratorBuilder> createBuilders(Map<EntityPointer<?>, WorkspaceEntity> entityPointerMap, Map<Class<WorkspaceEntity>, CustomizingIndexingPresentationContributor<?>> presentationContributorMap) {
                IndexableIteratorPresentation customization = findPresentation(entityPointer, entityPointerMap, presentationContributorMap);
                return IndexableIteratorBuilders.INSTANCE.forGenericContentEntity(entityPointer, IndexingUrlRootHolder.Companion.fromUrl(url), customization);
            }
        }

        private record ExternalRootData<E extends WorkspaceEntity>(@NotNull EntityPointer<E> entityPointer,
                                                                   @NotNull List<VirtualFileUrl> roots,
                                                                   @NotNull List<VirtualFileUrl> sourceRoots) {
            public @NotNull Collection<IndexableIteratorBuilder> createBuilders(Map<EntityPointer<?>, WorkspaceEntity> entityPointerMap, Map<Class<WorkspaceEntity>, CustomizingIndexingPresentationContributor<?>> presentationContributorMap) {
                IndexableIteratorPresentation presentation = findPresentation(entityPointer, entityPointerMap, presentationContributorMap);
                return IndexableIteratorBuilders.INSTANCE.forExternalEntity(entityPointer, IndexingUrlSourceRootHolder.Companion.fromUrls(roots, sourceRoots), presentation);
            }
        }

        private record CustomKindRootData<E extends WorkspaceEntity>(@NotNull EntityPointer<E> entityPointer,
                                                                     @NotNull VirtualFileUrl fileUrl) {
            public @NotNull Collection<IndexableIteratorBuilder> createBuilders(Map<EntityPointer<?>, WorkspaceEntity> entityPointerMap, Map<Class<WorkspaceEntity>, CustomizingIndexingPresentationContributor<?>> presentationContributorMap) {
                IndexableIteratorPresentation customization = findPresentation(entityPointer, entityPointerMap, presentationContributorMap);
                return IndexableIteratorBuilders.INSTANCE.forCustomKindEntity(entityPointer, IndexingUrlRootHolder.Companion.fromUrl(fileUrl), customization);
            }
        }

        @Override
        @NotNull
        public Collection<IndexableIteratorBuilder> createBuildersFromWorkspaceFiles() {
            Map<EntityPointer<?>, WorkspaceEntity> entityPointerMap = ContainerUtil.map2MapNotNull(pointers, pointer -> Pair.create(pointer, pointer.resolve(entityStorage)));
            Map<Class<WorkspaceEntity>, CustomizingIndexingPresentationContributor<?>> presentationContributorMap = ContainerUtil.map2MapNotNull(WorkspaceFileIndexImpl.Companion.getEP_NAME().getExtensionList(), contributor -> {
                if (contributor instanceof CustomizingIndexingPresentationContributor<?>) {
                    return Pair.create((Class<WorkspaceEntity>) contributor.getEntityClass(), (CustomizingIndexingPresentationContributor<?>) contributor);
                }
                return null;
            });
            List<IndexableIteratorBuilder> result = new ArrayList<>();
            for (ModuleRootData<?> data : moduleRootDataList) {
                result.addAll(data.createBuilders(entityPointerMap, presentationContributorMap));
            }
            for (ContentRootData<?> data : contentRootDataList) {
                result.addAll(data.createBuilders(entityPointerMap, presentationContributorMap));
            }
            for (Map.Entry<LibraryId, Collection<VirtualFile>> entry : sourceFilesByLibrary.entrySet()) {
                result.addAll(IndexableIteratorBuilders.INSTANCE.forLibraryEntity(entry.getKey(), true, Collections.emptyList(), entry.getValue()));
            }
            for (Map.Entry<LibraryId, Collection<VirtualFile>> entry : classFilesByLibrary.entrySet()) {
                result.addAll(IndexableIteratorBuilders.INSTANCE.forLibraryEntity(entry.getKey(), true, entry.getValue(), Collections.emptyList()));
            }
            for (Map.Entry<Sdk, Collection<VirtualFile>> entry : sdkToFileMap.entrySet()) {
                result.addAll(IndexableIteratorBuilders.INSTANCE.forSdk(entry.getKey(), entry.getValue()));
            }
            for (ExternalRootData<?> data : externalRootDataList) {
                result.addAll(data.createBuilders(entityPointerMap, presentationContributorMap));
            }
            for (CustomKindRootData<?> data : customKindRootDataList) {
                result.addAll(data.createBuilders(entityPointerMap, presentationContributorMap));
            }
            return result;
        }

        @Override
        public Collection<IndexableIteratorBuilder> createBuildersFromFilesFromIndexableSetContributors(@NotNull Project project) {
            if (indexableSetContributorFiles.isEmpty()) {
                return Collections.emptyList();
            }
            List<IndexableIteratorBuilder> result = new ArrayList<>();
            for (IndexableSetContributor contributor : IndexableSetContributor.EP_NAME.getExtensionList()) {
                Set<VirtualFile> applicationRoots = collectAndRemoveFilesUnder(indexableSetContributorFiles, contributor.getAdditionalRootsToIndex());
                Set<VirtualFile> projectRoots = collectAndRemoveFilesUnder(indexableSetContributorFiles, contributor.getAdditionalProjectRootsToIndex(project));
                if (!applicationRoots.isEmpty()) {
                    result.add(new IndexableSetContributorFilesIteratorBuilder(null, contributor.getDebugName(), applicationRoots, false, contributor));
                }
                if (!projectRoots.isEmpty()) {
                    result.add(new IndexableSetContributorFilesIteratorBuilder(null, contributor.getDebugName(), projectRoots, true, contributor));
                }
                if (indexableSetContributorFiles.isEmpty()) {
                    break;
                }
            }
            return result;
        }

        @NotNull
        private Collection<IndexableIteratorBuilder> createBuildersFromFilesFromAdditionalLibraryRootsProviders(@NotNull Project project) {
            if (additionalLibraryRootsProviderFiles.isEmpty()) return Collections.emptyList();
            List<IndexableIteratorBuilder> result = new ArrayList<>();
            List<VirtualFile> remainingRoots = new ArrayList<>(additionalLibraryRootsProviderFiles);
            for (AdditionalLibraryRootsProvider provider : AdditionalLibraryRootsProvider.EP_NAME.getExtensionList()) {
                for (SyntheticLibrary library : provider.getAdditionalProjectLibraries(project)) {
                    Set<VirtualFile> roots = collectAndRemove(remainingRoots, file -> library.contains(file, true, true));
                    if (!roots.isEmpty()) {
                        String name = library instanceof ItemPresentation ? ((ItemPresentation) library).getPresentableText() : null;
                        result.add(new SyntheticLibraryIteratorBuilder(library, name, roots));
                    }
                    if (remainingRoots.isEmpty()) {
                        break;
                    }
                }
                if (remainingRoots.isEmpty()) {
                    break;
                }
            }
            if (!remainingRoots.isEmpty()) {
                LOG.error("Failed to find any SyntheticLibrary roots for " + StringUtil.join(remainingRoots, "\n"));
            }
            return result;
        }

        @Override
        public @NotNull Collection<IndexableIteratorBuilder> createAllBuilders(@NotNull Project project) {
            List<IndexableIteratorBuilder> result = new ArrayList<>(createBuildersFromWorkspaceFiles());
            result.addAll(createBuildersFromFilesFromIndexableSetContributors(project));
            result.addAll(createBuildersFromFilesFromAdditionalLibraryRootsProviders(project));
            return result;
        }
    }

    @Nullable
    private static <E extends WorkspaceEntity> IndexableIteratorPresentation findPresentation(@NotNull EntityPointer<E> entityPointer, @NotNull Map<EntityPointer<?>, WorkspaceEntity> entityPointerMap, @NotNull Map<Class<WorkspaceEntity>, CustomizingIndexingPresentationContributor<?>> presentationContributorMap) {
        E entity = (E) entityPointerMap.get(entityPointer);
        if (entity == null) {
            return null;
        }
        CustomizingIndexingPresentationContributor<E> contributor = (CustomizingIndexingPresentationContributor<E>) presentationContributorMap.get(entity.getEntityInterface());
        return contributor == null ? null : contributor.customizeIteratorPresentation(entity);
    }

    @NotNull
    private static Set<VirtualFile> collectAndRemoveFilesUnder(Collection<VirtualFile> files, Set<VirtualFile> roots) {
        return collectAndRemove(files, file -> VfsUtilCore.isUnder(file, roots));
    }

    @NotNull
    private static Set<VirtualFile> collectAndRemove(@NotNull Collection<VirtualFile> files, @NotNull Predicate<VirtualFile> shouldRemove) {
        Iterator<VirtualFile> iterator = files.iterator();
        Set<VirtualFile> roots = new HashSet<>();
        while (iterator.hasNext()) {
            VirtualFile nextFile = iterator.next();
            if (shouldRemove.test(nextFile)) {
                roots.add(nextFile);
                iterator.remove();
            }
        }
        return roots;
    }
}