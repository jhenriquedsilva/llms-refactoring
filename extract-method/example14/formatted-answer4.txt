package org.apache.lucene.util.automaton;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import org.apache.lucene.util.ArrayUtil;
import org.apache.lucene.util.hppc.BitMixer;

public class NFARunAutomaton implements ByteRunnable, TransitionAccessor {

    public static final int MISSING = -1;

    private static final int NOT_COMPUTED = -2;

    private final Automaton automaton;
    private final int[] points;
    private final Map<DState, Integer> dStateToOrd = new HashMap<>();
    private DState[] dStates;
    private final int alphabetSize;
    final int[] classmap;

    private final Operations.PointTransitionSet transitionSet = new Operations.PointTransitionSet();
    private final StateSet statesSet = new StateSet(5);

    public NFARunAutomaton(Automaton automaton) {
        this(automaton, Character.MAX_CODE_POINT + 1);
    }

    public NFARunAutomaton(Automaton automaton, int alphabetSize) {
        this.automaton = automaton;
        points = automaton.getStartPoints();
        this.alphabetSize = alphabetSize;
        dStates = new DState[10];
        findDState(new DState(new int[]{0}));
        classmap = new int[Math.min(256, alphabetSize)];
        int i = 0;
        for (int j = 0; j < classmap.length; j++) {
            if (i + 1 < points.length && j == points[i + 1]) {
                i++;
            }
            classmap[j] = i;
        }
    }

    @Override
    public int step(int state, int c) {
        assert dStates[state] != null;
        return step(dStates[state], c);
    }

    @Override
    public boolean isAccept(int state) {
        assert dStates[state] != null;
        return dStates[state].isAccept;
    }

    @Override
    public int getSize() {
        return dStates.length;
    }

    boolean run(int[] s) {
        int p = 0;
        for (int c : s) {
            p = step(p, c);
            if (p == MISSING) return false;
        }
        return dStates[p].isAccept;
    }

    private int step(DState dState, int c) {
        int charClass = getCharClass(c);
        return dState.nextState(charClass);
    }

    private int findDState(DState dState) {
        if (dState == null) {
            return MISSING;
        }
        int ord = dStateToOrd.getOrDefault(dState, -1);
        if (ord >= 0) {
            return ord;
        }
        ord = dStateToOrd.size();
        dStateToOrd.put(dState, ord);
        assert ord >= dStates.length || dStates[ord] == null;
        if (ord >= dStates.length) {
            dStates = ArrayUtil.grow(dStates, ord + 1);
        }
        dStates[ord] = dState;
        return ord;
    }

    final int getCharClass(int c) {
        assert c < alphabetSize;
        if (c < classmap.length) {
            return classmap[c];
        }
        int a = 0;
        int b = points.length;
        while (b - a > 1) {
            int d = (a + b) >>> 1;
            if (points[d] > c) b = d;
            else if (points[d] < c) a = d;
            else return d;
        }
        return a;
    }

    @Override
    public int initTransition(int state, Transition t) {
        t.source = state;
        t.transitionUpto = -1;
        return getNumTransitions(state);
    }

    @Override
    public void getNextTransition(Transition t) {
        assert t.transitionUpto < points.length - 1 && t.transitionUpto >= -1;
        while (dStates[t.source].transitions[++t.transitionUpto] == MISSING) {
        }
        assert dStates[t.source].transitions[t.transitionUpto] != NOT_COMPUTED;
        t.dest = dStates[t.source].transitions[t.transitionUpto];
        setTransitionMinMax(t);
    }

    @Override
    public int getNumTransitions(int state) {
        dStates[state].determinize();
        return dStates[state].outgoingTransitions;
    }

    @Override
    public void getTransition(int state, int index, Transition t) {
        dStates[state].determinize();
        int outgoingTransitions = -1;
        t.transitionUpto = -1;
        t.source = state;
        while (outgoingTransitions < index && t.transitionUpto < points.length - 1) {
            if (dStates[t.source].transitions[++t.transitionUpto] != MISSING) {
                outgoingTransitions++;
            }
        }
        assert outgoingTransitions == index;
        t.dest = dStates[t.source].transitions[t.transitionUpto];
        setTransitionMinMax(t);
    }

    private void setTransitionMinMax(Transition t) {
        t.min = points[t.transitionUpto];
        if (t.transitionUpto == points.length - 1) {
            t.max = alphabetSize - 1;
        } else {
            t.max = points[t.transitionUpto + 1] - 1;
        }
    }

    private class DState {
        private final int[] nfaStates;
        private int[] transitions;
        private final int hashCode;
        private final boolean isAccept;
        private final Transition stepTransition = new Transition();
        private Transition minimalTransition;
        private int computedTransitions;
        private int outgoingTransitions;

        private DState(int[] nfaStates) {
            assert nfaStates != null && nfaStates.length > 0;
            this.nfaStates = nfaStates;
            int hashCode = nfaStates.length;
            boolean isAccept = false;
            for (int s : nfaStates) {
                hashCode += BitMixer.mix(s);
                if (automaton.isAccept(s)) {
                    isAccept = true;
                }
            }
            this.isAccept = isAccept;
            this.hashCode = hashCode;
        }

        private int nextState(int charClass) {
            initTransitions();
            assert charClass < transitions.length;
            if (transitions[charClass] == NOT_COMPUTED) {
                assignTransition(charClass, findDState(step(points[charClass])));
                if (minimalTransition != null) {
                    int cls = charClass;
                    while (cls > 0 && points[--cls] >= minimalTransition.min) {
                        assert transitions[cls] == NOT_COMPUTED || transitions[cls] == transitions[charClass];
                        assignTransition(cls, transitions[charClass]);
                    }
                    cls = charClass;
                    while (cls < points.length - 1 && points[++cls] <= minimalTransition.max) {
                        assert transitions[cls] == NOT_COMPUTED || transitions[cls] == transitions[charClass];
                        assignTransition(cls, transitions[charClass]);
                    }
                    minimalTransition = null;
                }
            }
            return transitions[charClass];
        }

        private void assignTransition(int charClass, int dest) {
            if (transitions[charClass] == NOT_COMPUTED) {
                computedTransitions++;
                transitions[charClass] = dest;
                if (transitions[charClass] != MISSING) {
                    outgoingTransitions++;
                }
            }
        }

        private DState step(int c) {
            statesSet.reset();
            int numTransitions;
            int left = -1, right = alphabetSize;
            for (int nfaState : nfaStates) {
                numTransitions = automaton.initTransition(nfaState, stepTransition);
                for (int i = 0; i < numTransitions; i++) {
                    automaton.getNextTransition(stepTransition);
                    if (stepTransition.min <= c && stepTransition.max >= c) {
                        statesSet.incr(stepTransition.dest);
                        left = Math.max(stepTransition.min, left);
                        right = Math.min(stepTransition.max, right);
                    }
                    if (stepTransition.max < c) {
                        left = Math.max(stepTransition.max + 1, left);
                    }
                    if (stepTransition.min > c) {
                        right = Math.min(stepTransition.min - 1, right);
                        break;
                    }
                }
            }
            if (statesSet.size() == 0) {
                return null;
            }
            minimalTransition = new Transition();
            minimalTransition.min = left;
            minimalTransition.max = right;
            return new DState(statesSet.getArray());
        }

        private void determinize() {
            if (transitions != null && computedTransitions == transitions.length) {
                return;
            }
            initTransitions();
            transitionSet.reset();
            for (int nfaState : nfaStates) {
                int numTransitions = automaton.initTransition(nfaState, stepTransition);
                for (int i = 0; i < numTransitions; i++) {
                    automaton.getNextTransition(stepTransition);
                    transitionSet.add(stepTransition);
                }
            }
            if (transitionSet.count == 0) {
                Arrays.fill(transitions, MISSING);
                computedTransitions = transitions.length;
                return;
            }

            transitionSet.sort();
            statesSet.reset();
            int lastPoint = -1;
            int charClass = 0;
            for (int i = 0; i < transitionSet.count; i++) {
                final int point = transitionSet.points[i].point;
                if (statesSet.size() > 0) {
                    assert lastPoint != -1;
                    int ord = findDState(new DState(statesSet.getArray()));
                    while (points[charClass] < lastPoint) {
                        assignTransition(charClass++, MISSING);
                    }
                    assert points[charClass] == lastPoint;
                    while (charClass < points.length && points[charClass] < point) {
                        assert transitions[charClass] == NOT_COMPUTED || transitions[charClass] == ord;
                        assignTransition(charClass++, ord);
                    }
                    assert (charClass == points.length && point == alphabetSize) || points[charClass] == point;
                }
                int[] transitions = transitionSet.points[i].ends.transitions;
                int limit = transitionSet.points[i].ends.next;
                for (int j = 0; j < limit; j += 3) {
                    int dest = transitions[j];
                    statesSet.decr(dest);
                }
                transitionSet.points[i].ends.next = 0;
                transitions = transitionSet.points[i].starts.transitions;
                limit = transitionSet.points[i].starts.next;
                for (int j = 0; j < limit; j += 3) {
                    int dest = transitions[j];
                    statesSet.incr(dest);
                }
                lastPoint = point;
                transitionSet.points[i].starts.next = 0;
            }
            assert statesSet.size() == 0;
            assert computedTransitions >= charClass;
            assert charClass == transitions.length || transitions[charClass] == MISSING || transitions[charClass] == NOT_COMPUTED;
            Arrays.fill(transitions, charClass, transitions.length, MISSING);
            computedTransitions = transitions.length;
        }

        private void initTransitions() {
            if (transitions == null) {
                transitions = new int[points.length];
                Arrays.fill(transitions, NOT_COMPUTED);
            }
        }

        @Override
        public int hashCode() {
            return hashCode;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            DState dState = (DState) o;
            return hashCode == dState.hashCode && Arrays.equals(nfaStates, dState.nfaStates);
        }
    }
}