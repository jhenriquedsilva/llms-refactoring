23-04-2025, 19:59

**Refactoring Analysis:**

Yes, there are several opportunities for **Extract Method** refactoring in the posted code. The `testDifferentStateTtlForDifferentOneInputOperator` and `innerTestRegularJoin` methods both contain sequences of logic that can benefit from being broken into smaller, named methods to increase readability and maintainability. For instance:

- Registering data for tables can be extracted.
- The repeated creation of source and sink tables can be extracted.
- The repeated transformation of JSON plans with TTL metadata can be extracted.
- Comments explaining table expectations can be moved into helper naming.

Below is the **refactored code** with extracted methods and improved readability:

---

```java
package org.apache.flink.table.planner.runtime.stream.jsonplan;

import org.apache.flink.table.api.TableException;
import org.apache.flink.table.data.GenericRowData;
import org.apache.flink.table.data.StringData;
import org.apache.flink.table.planner.factories.TestValuesTableFactory;
import org.apache.flink.table.planner.utils.JsonPlanTestBase;
import org.apache.flink.table.planner.utils.JsonTestUtils;

import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;

import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;

class ConfigureOperatorLevelStateTtlJsonITCase extends JsonPlanTestBase {

    @Test
    void testDifferentStateTtlForDifferentOneInputOperator() throws Exception {
        String dataId = registerOrdersData();
        createOrdersSourceTable(dataId);
        createOrdersStatsSinkTable();

        Function<String, String> jsonPlanTransformer = json -> setStateTtlForOperators(json, 6000L, 9000L);

        compileSqlAndExecutePlan(
                getOrdersStatsInsertSql(),
                jsonPlanTransformer
        ).await();

        List<String> expected = getExpectedOrdersStatsResults();
        assertResult(expected, TestValuesTableFactory.getResultsAsStrings("OrdersStats"));
    }

    @Test
    void testDifferentStateTtlForSameTwoInputStreamOperator() throws Exception {
        innerTestRegularJoin(
                getOrderShipInfoInsertSql(),
                this::setStateTtlForJoinOperators
        );
    }

    @Test
    void testDifferentStateTtlThroughSqlHintForSameTwoInputStreamOperator() throws Exception {
        innerTestRegularJoin(
                getOrderShipInfoInsertSqlWithHint(),
                Function.identity()
        );
    }

    // =================== Extracted Methods =====================

    private String registerOrdersData() {
        return TestValuesTableFactory.registerRowData(
                Arrays.asList(
                        GenericRowData.of(1, StringData.fromString("Tom"), 1, 199.9d),
                        GenericRowData.of(2, StringData.fromString("Jerry"), 2, 99.9d),
                        GenericRowData.of(1, StringData.fromString("Tom"), 1, 199.9d),
                        GenericRowData.of(3, StringData.fromString("Tom"), 1, 29.9d),
                        GenericRowData.of(4, StringData.fromString("Olivia"), 1, 100d),
                        GenericRowData.of(4, StringData.fromString("Olivia"), 1, 100d),
                        GenericRowData.of(2, StringData.fromString("Jerry"), 2, 99.9d),
                        GenericRowData.of(5, StringData.fromString("Michael"), 3, 599.9d),
                        GenericRowData.of(6, StringData.fromString("Olivia"), 3, 1000d)
                ));
    }

    private void createOrdersSourceTable(String dataId) {
        createTestSourceTable(
                "Orders",
                new String[] {
                        "`order_id` INT", "`buyer` STRING", "`quantity` INT", "`amount` DOUBLE"
                },
                null,
                getProperties(dataId, 1, "2s"));
    }

    private void createOrdersStatsSinkTable() {
        createTestNonInsertOnlyValuesSinkTable(
                "OrdersStats",
                "`buyer` STRING",
                "`ord_cnt` BIGINT",
                "`quantity_cnt` BIGINT",
                "`total_amount` DOUBLE"
        );
    }

    private String getOrdersStatsInsertSql() {
        return "INSERT INTO OrdersStats \n"
                + "SELECT buyer, COUNT(1) AS ord_cnt, SUM(quantity) AS quantity_cnt, SUM(amount) AS total_amount FROM (\n"
                + "SELECT *, ROW_NUMBER() OVER(PARTITION BY order_id, buyer, quantity, amount ORDER BY proctime() ASC) AS rk FROM Orders) tmp\n"
                + "WHERE rk = 1\n"
                + "GROUP BY buyer";
    }

    private Function<String, String> setStateTtlForOperators(String json, long dedupTtl, long aggTtl) {
        try {
            JsonNode target = JsonTestUtils.readFromString(json);
            JsonTestUtils.setExecNodeStateMetadata(target, "stream-exec-deduplicate", 0, dedupTtl);
            JsonTestUtils.setExecNodeStateMetadata(target, "stream-exec-group-aggregate", 0, aggTtl);
            return JsonTestUtils.writeToString(target);
        } catch (IOException e) {
            throw new TableException("Cannot modify compiled json plan.", e);
        }
    }

    private List<String> getExpectedOrdersStatsResults() {
        return Arrays.asList(
                "+I[Tom, 2, 2, 229.8]",
                "+I[Jerry, 1, 2, 99.9]",
                "+I[Jerry, 1, 2, 99.9]",
                "+I[Olivia, 2, 4, 1100.0]",
                "+I[Michael, 1, 3, 599.9]"
        );
    }

    private String getOrderShipInfoInsertSql() {
        return "INSERT INTO OrdersShipInfo \n"
                + "SELECT a.order_id, a.line_order_id, b.ship_mode FROM Orders a JOIN LineOrders b ON a.line_order_id = b.line_order_id";
    }

    private String getOrderShipInfoInsertSqlWithHint() {
        return "INSERT INTO OrdersShipInfo \n"
                + "SELECT /*+ STATE_TTL('a' = '3s', 'b' = '9s') */\n"
                + " a.order_id, a.line_order_id, b.ship_mode \n"
                + "FROM Orders a JOIN LineOrders b ON a.line_order_id = b.line_order_id";
    }

    private String setStateTtlForJoinOperators(String json) {
        try {
            JsonNode target = JsonTestUtils.readFromString(json);
            JsonTestUtils.setExecNodeStateMetadata(target, "stream-exec-join", 0, 3000L);
            JsonTestUtils.setExecNodeStateMetadata(target, "stream-exec-join", 1, 9000L);
            return JsonTestUtils.writeToString(target);
        } catch (IOException e) {
            throw new TableException("Cannot modify compiled json plan.", e);
        }
    }

    private void innerTestRegularJoin(String sql, Function<String, String> jsonPlanTransformer)
            throws Exception {
        String leftTableDataId = registerOrdersJoinLeftData();
        createOrdersJoinLeftSourceTable(leftTableDataId);

        String rightTableDataId = registerOrdersJoinRightData();
        createOrdersJoinRightSourceTable(rightTableDataId);

        createOrderShipInfoSinkTable();
        compileSqlAndExecutePlan(sql, jsonPlanTransformer).await();

        List<String> expected = Arrays.asList(
                "+I[1, 1000002, TRUCK]",
                "+I[1, 1000004, RAIL]",
                "+I[1, 1000005, AIR]"
        );
        assertResult(expected, TestValuesTableFactory.getResultsAsStrings("OrdersShipInfo"));
    }

    private String registerOrdersJoinLeftData() {
        return TestValuesTableFactory.registerRowData(
                Arrays.asList(
                        GenericRowData.of(1, 1000001),
                        GenericRowData.of(1, 1000002),
                        GenericRowData.of(1, 1000003),
                        GenericRowData.of(1, 1000004),
                        GenericRowData.of(1, 1000005),
                        GenericRowData.of(2, 2000001)
                ));
    }

    private void createOrdersJoinLeftSourceTable(String dataId) {
        createTestSourceTable(
                "Orders",
                new String[] {"`order_id` INT", "`line_order_id` INT"},
                null,
                getProperties(dataId, 1, "2s"));
    }

    private String registerOrdersJoinRightData() {
        return TestValuesTableFactory.registerRowData(
                Arrays.asList(
                        GenericRowData.of(2000001, StringData.fromString("TRUCK")),
                        GenericRowData.of(1000005, StringData.fromString("AIR")),
                        GenericRowData.of(1000001, StringData.fromString("SHIP")),
                        GenericRowData.of(1000002, StringData.fromString("TRUCK")),
                        GenericRowData.of(1000003, StringData.fromString("RAIL")),
                        GenericRowData.of(1000004, StringData.fromString("RAIL"))
                ));
    }

    private void createOrdersJoinRightSourceTable(String dataId) {
        createTestSourceTable(
                "LineOrders",
                new String[] {"`line_order_id` INT", "`ship_mode` STRING"},
                null,
                getProperties(dataId, 2, "4s"));
    }

    private void createOrderShipInfoSinkTable() {
        createTestValuesSinkTable("OrdersShipInfo", "`order_id` INT", "`line_order_id` INT", "`ship_mode` STRING");
    }

    private static Map<String, String> getProperties(String dataId, int sleepAfterElements, String sleepTime) {
        return new HashMap<String, String>() {{
            put("connector", "values");
            put("bounded", "false");
            put("register-internal-data", "true");
            put("source.sleep-after-elements", String.valueOf(sleepAfterElements));
            put("source.sleep-time", sleepTime);
            put("data-id", dataId);
        }};
    }
}
```

---

## **Summary of Improvements**
- **Helper Methods**: Registration of test data, table creation, insert SQL, plan transformer functions, and assertion expectations now have dedicated methods with descriptive names.
- **Logic Decomposition**: Repetitive and "blocky" code is now expressed in concise, reusable methods.
- **Readability**: Test structure and intent are more obvious.
- **Maintainability**: Adding new cases is much easier, and refactoring the underlying logic for a specific table/data change requires editing in just one place.

**This extraction reduces cognitive overhead, avoids code duplication, and clearly delineates the different logical parts of the tests.**