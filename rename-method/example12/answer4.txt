28-04-2025, 21:18

### Analysis of Method Names

In reviewing `BasePackFetchConnection`, method naming is generally good, but there **are multiple methods with non-descriptive, low-context names** or ones that may violate standard naming conventions or could benefit from improvement:

- `doFetch(...)`: The verb "do" is vague; a more explicit name indicating the context (for example, `performFetch`, `executeFetchProcedure`, or similar) is preferred by modern standards.
- `sendWants(...)`: Could be ambiguous (are we sending wants, or handling/sending wanted refs?); however, within the context, it's fine, but `sendWantRequests` or `sendWantedRefs` might clarify its intent.
- `markCommon(...)`, `markAdvertised(...)`, `markRefsAdvertised()`, `markReachable(...)`: Not incorrect, but consistently following `markAsCommon/Advertised/Reachable` or `flagAs...` could be preferred for clarity (such as `markObjectAsCommon()`).
- `parseReachable(...)`: This name is just acceptable, but `markObjectAsReachable` may better express the intent.
- `negotiate(...)`, `negotiateBegin()`: The verb is concise but could use further clarification (`beginNegotiation`, `performNegotiation`).
- `clearState()`, `onReceivePack()`, `handleShallowUnshallow()`, `sendShallow()`, `receivePack()`, `enableCapabilities()`: Names are clear and standard.
- Private classes, e.g., `CancelledException`, `FetchStateV2`: Both clear.

### Recommendations

#### Suggestions for Renaming Methods

- `doFetch` → `performFetch`
- `sendWants` → `sendWantedRefs`
- `markCommon` → `markObjectAsCommon`
- `markAdvertised` → `markObjectAsAdvertised`
- `markRefsAdvertised` → `markAllRefsAsAdvertised`
- `markReachable` → `markObjectsAsReachable`
- `parseReachable` → `markObjectAsReachable`
- `negotiate` → `performNegotiation`
- `negotiateBegin` → `beginNegotiation`

---

### Refactored Code

Here is the **fully refactored class** with method renaming for improved readability where identified:

```java
package org.eclipse.jgit.transport;

// ... [imports unchanged, omitted for brevity] ...

public abstract class BasePackFetchConnection extends BasePackConnection
        implements FetchConnection {
    // ... [fields unchanged] ...

    public BasePackFetchConnection(PackTransport packTransport) {
        super(packTransport);
        // ... [constructor body unchanged] ...
    }

    static class FetchConfig {
        // ... [FetchConfig body unchanged] ...
    }

    @Override
    public final void fetch(final ProgressMonitor monitor,
                            final Collection<Ref> want, final Set<ObjectId> have)
            throws TransportException {
        fetch(monitor, want, have, null);
    }

    @Override
    public final void fetch(final ProgressMonitor monitor,
                            final Collection<Ref> want, final Set<ObjectId> have,
                            OutputStream outputStream) throws TransportException {
        markStartedOperation();
        performFetch(monitor, want, have, outputStream);
    }

    // ... [other overrides unchanged] ...

    private void clearState() {
        walk.dispose();
        reachableCommits = null;
        state = null;
        pckState = null;
    }

    /**
     * Execute common ancestor negotiation and fetch the objects.
     *
     * @param monitor
     *            progress monitor to receive status updates. If the monitor is
     *            the {@link org.eclipse.jgit.lib.NullProgressMonitor#INSTANCE}, then the no-progress
     *            option enabled.
     * @param want
     *            the advertised remote references the caller wants to fetch.
     * @param have
     *            additional objects to assume that already exist locally. This
     *            will be added to the set of objects reachable from the
     *            destination repository's references.
     * @param outputStream
     *            ouputStream to write sideband messages to
     * @throws org.eclipse.jgit.errors.TransportException
     *             if any exception occurs.
     * @since 3.0
     */
    protected void performFetch(final ProgressMonitor monitor,
                           final Collection<Ref> want, final Set<ObjectId> have,
                           OutputStream outputStream) throws TransportException {
        try {
            noProgress = monitor == NullProgressMonitor.INSTANCE;

            markAllRefsAsAdvertised();
            markObjectsAsReachable(want, have, maxTimeWanted(want));

            if (TransferConfig.ProtocolVersion.V2
                    .equals(getProtocolVersion())) {
                state = new TemporaryBuffer.Heap(Integer.MAX_VALUE);
                pckState = new PacketLineOut(state);
                try {
                    doFetchV2(monitor, want, outputStream);
                } finally {
                    clearState();
                }
                return;
            }
            // Protocol V0/1
            if (statelessRPC) {
                state = new TemporaryBuffer.Heap(Integer.MAX_VALUE);
                pckState = new PacketLineOut(state);
            }
            PacketLineOut output = statelessRPC ? pckState : pckOut;
            if (sendWantedRefs(want, output)) {
                boolean mayHaveShallow = depth != null || deepenSince != null || !deepenNots.isEmpty();
                Set<ObjectId> shallowCommits = local.getObjectDatabase().getShallowCommits();
                if (isCapableOf(GitProtocolConstants.CAPABILITY_SHALLOW)) {
                    sendShallow(shallowCommits, output);
                } else if (mayHaveShallow) {
                    throw new PackProtocolException(JGitText.get().shallowNotSupported);
                }
                output.end();
                outNeedsEnd = false;

                performNegotiation(monitor, mayHaveShallow, shallowCommits);

                clearState();

                receivePack(monitor, outputStream);
            }
        } catch (CancelledException ce) {
            close();
            return; // Caller should test (or just know) this themselves.
        } catch (IOException | RuntimeException err) {
            close();
            throw new TransportException(err.getMessage(), err);
        }
    }

    private void doFetchV2(ProgressMonitor monitor, Collection<Ref> want,
                           OutputStream outputStream) throws IOException, CancelledException {
        sideband = true;
        beginNegotiation();

        pckState.writeString("command=" + GitProtocolConstants.COMMAND_FETCH); //$NON-NLS-1$
        String agent = UserAgent.get();
        if (agent != null && isCapableOf(GitProtocolConstants.OPTION_AGENT)) {
            pckState.writeString(
                    GitProtocolConstants.OPTION_AGENT + '=' + agent);
        }
        Set<String> capabilities = new HashSet<>();
        String advertised = getCapability(GitProtocolConstants.COMMAND_FETCH);
        if (!StringUtils.isEmptyOrNull(advertised)) {
            capabilities.addAll(Arrays.asList(advertised.split("\\s+"))); //$NON-NLS-1$
        }
        pckState.writeDelim();
        for (String capability : getCapabilitiesV2(capabilities)) {
            pckState.writeString(capability);
        }

        if (!sendWantedRefs(want, pckState)) {
            return;
        }

        Set<ObjectId> shallowCommits = local.getObjectDatabase().getShallowCommits();
        if (capabilities.contains(GitProtocolConstants.CAPABILITY_SHALLOW)) {
            sendShallow(shallowCommits, pckState);
        } else if (depth != null || deepenSince != null || !deepenNots.isEmpty()) {
            throw new PackProtocolException(JGitText.get().shallowNotSupported);
        }
        outNeedsEnd = false;

        FetchStateV2 fetchState = new FetchStateV2();
        boolean sentDone = false;
        for (;;) {
            state.writeTo(out, monitor);
            sentDone = sendNextHaveBatch(fetchState, pckOut, monitor);
            if (sentDone) {
                break;
            }
            if (readAcknowledgments(fetchState, pckIn, monitor)) {
                break;
            }
        }
        clearState();
        String line = pckIn.readString();
        if (sentDone && line.startsWith(PACKET_ERR)) {
            throw new RemoteRepositoryException(uri, line.substring(4));
        }

        if (GitProtocolConstants.SECTION_SHALLOW_INFO.equals(line)) {
            line = handleShallowUnshallow(shallowCommits, pckIn);
            if (!PacketLineIn.isDelimiter(line)) {
                throw new PackProtocolException(MessageFormat
                        .format(JGitText.get().expectedGot, PACKET_DELIM,
                                line));
            }
            line = pckIn.readString();
        }

        if (!GitProtocolConstants.SECTION_PACKFILE.equals(line)) {
            throw new PackProtocolException(
                    MessageFormat.format(JGitText.get().expectedGot,
                            GitProtocolConstants.SECTION_PACKFILE, line));
        }
        receivePack(monitor, outputStream);
    }

    private boolean sendNextHaveBatch(FetchStateV2 fetchState,
                                      PacketLineOut output, ProgressMonitor monitor)
            throws IOException, CancelledException {
        long n = 0;
        while (n < fetchState.havesToSend) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            output.writeString(PACKET_HAVE + c.getId().name() + '\n');
            n++;
            if (n % 10 == 0 && monitor.isCancelled()) {
                throw new CancelledException();
            }
        }
        fetchState.havesTotal += n;
        if (n == 0
                || (fetchState.hadAcks
                && fetchState.havesWithoutAck > MAX_HAVES)
                || fetchState.havesTotal > maxHaves) {
            output.writeString(PACKET_DONE + '\n');
            output.end();
            return true;
        }
        fetchState.havesWithoutAck += n;
        output.end();
        fetchState.incHavesToSend(statelessRPC);
        return false;
    }

    private boolean readAcknowledgments(FetchStateV2 fetchState,
                                        PacketLineIn input, ProgressMonitor monitor)
            throws IOException, CancelledException {
        String line = input.readString();
        if (!GitProtocolConstants.SECTION_ACKNOWLEDGMENTS.equals(line)) {
            throw new PackProtocolException(MessageFormat.format(
                    JGitText.get().expectedGot,
                    GitProtocolConstants.SECTION_ACKNOWLEDGMENTS, line));
        }
        MutableObjectId returnedId = new MutableObjectId();
        line = input.readString();
        boolean gotReady = false;
        long n = 0;
        while (!PacketLineIn.isEnd(line) && !PacketLineIn.isDelimiter(line)) {
            AckNackResult ack = PacketLineIn.parseACKv2(line, returnedId);
            if (!gotReady) {
                if (ack == AckNackResult.ACK_COMMON) {
                    markObjectAsCommon(walk.parseAny(returnedId), ack, true);
                    fetchState.havesWithoutAck = 0;
                    fetchState.hadAcks = true;
                } else if (ack == AckNackResult.ACK_READY) {
                    gotReady = true;
                }
            }
            n++;
            if (n % 10 == 0 && monitor.isCancelled()) {
                throw new CancelledException();
            }
            line = input.readString();
        }
        if (gotReady) {
            if (!PacketLineIn.isDelimiter(line)) {
                throw new PackProtocolException(MessageFormat
                        .format(JGitText.get().expectedGot, PACKET_DELIM,
                                line));
            }
        } else if (!PacketLineIn.isEnd(line)) {
            throw new PackProtocolException(MessageFormat
                    .format(JGitText.get().expectedGot, PACKET_END, line));
        }
        return gotReady;
    }

    @Override
    public void close() {
        if (walk != null)
            walk.close();
        super.close();
    }

    FetchConfig getFetchConfig() {
        return local.getConfig().get(FetchConfig::new);
    }

    private int maxTimeWanted(Collection<Ref> wants) {
        int maxTime = 0;
        for (Ref r : wants) {
            try {
                final RevObject obj = walk.parseAny(r.getObjectId());
                if (obj instanceof RevCommit) {
                    final int cTime = ((RevCommit) obj).getCommitTime();
                    if (maxTime < cTime)
                        maxTime = cTime;
                }
            } catch (IOException error) {
                // We don't have it, but we want to fetch (thus fixing error).
            }
        }
        return maxTime;
    }

    private void markObjectsAsReachable(Collection<Ref> want, Set<ObjectId> have,
                               int maxTime) throws IOException {
        Collection<Ref> refsToMark;
        if (useNegotiationTip) {
            refsToMark = translateToLocalTips(want);
            if (refsToMark.size() < want.size()) {
                refsToMark.addAll(local.getRefDatabase().getRefs());
            }
        } else {
            refsToMark = local.getRefDatabase().getRefs();
        }
        markReachableRefTips(refsToMark);

        for (ObjectId id : local.getAdditionalHaves())
            markObjectAsReachable(id);

        for (ObjectId id : have)
            markObjectAsReachable(id);

        if (maxTime > 0) {
            final Date maxWhen = new Date(maxTime * 1000L);
            walk.sort(RevSort.COMMIT_TIME_DESC);
            walk.markStart(reachableCommits);
            walk.setRevFilter(CommitTimeRevFilter.after(maxWhen));
            for (;;) {
                final RevCommit c = walk.next();
                if (c == null)
                    break;
                if (c.has(ADVERTISED) && !c.has(COMMON)) {
                    c.add(COMMON);
                    c.carry(COMMON);
                    reachableCommits.add(c);
                }
            }
        }
    }

    private Collection<Ref> translateToLocalTips(Collection<Ref> want)
            throws IOException {
        String[] refs = want.stream().map(Ref::getName)
                .collect(Collectors.toSet()).toArray(new String[0]);
        Map<String, Ref> wantRefMap = local.getRefDatabase().exactRef(refs);
        return wantRefMap.values().stream()
                .filter(r -> getRefObjectId(r) != null)
                .collect(Collectors.toList());
    }

    /**
     * Marks commits reachable.
     *
     * @param refsToMark
     *            references that client is requesting to be marked.
     */
    private void markReachableRefTips(Collection<Ref> refsToMark) {
        refsToMark.stream().map(BasePackFetchConnection::getRefObjectId)
                .filter(Objects::nonNull)
                .forEach(this::markObjectAsReachable);
    }

    private static ObjectId getRefObjectId(Ref ref) {
        ObjectId id = ref.getPeeledObjectId();
        if (id == null) {
            id = ref.getObjectId();
        }
        return id;
    }

    private void markObjectAsReachable(ObjectId id) {
        try {
            RevCommit o = walk.parseCommit(id);
            if (!o.has(REACHABLE)) {
                o.add(REACHABLE);
                reachableCommits.add(o);
            }
        } catch (IOException readError) {
            // If we cannot read the value of the ref skip it.
        }
    }

    private boolean sendWantedRefs(Collection<Ref> want, PacketLineOut p)
            throws IOException {
        boolean first = true;
        for (Ref r : want) {
            ObjectId objectId = r.getObjectId();
            if (objectId == null) {
                continue;
            }
            if (transport.getDepth() == null) {
                try {
                    if (walk.parseAny(objectId).has(REACHABLE)) {
                        continue;
                    }
                } catch (IOException err) {
                    // Its OK, we don't have it, but we want to fix that
                    // by fetching the object from the other side.
                }
            }

            final StringBuilder line = new StringBuilder(46);
            line.append(PACKET_WANT).append(objectId.name());
            if (first && TransferConfig.ProtocolVersion.V0
                    .equals(getProtocolVersion())) {
                line.append(enableCapabilities());
            }
            first = false;
            line.append('\n');
            p.writeString(line.toString());
        }
        if (first) {
            return false;
        }
        if (!filterSpec.isNoOp()) {
            p.writeString(filterSpec.filterLine());
        }
        return true;
    }

    // ... getCapabilitiesV2, enableCapabilities, etc. unchanged ...

    private void performNegotiation(ProgressMonitor monitor, boolean mayHaveShallow, Set<ObjectId> shallowCommits)
            throws IOException, CancelledException {
        final MutableObjectId ackId = new MutableObjectId();
        int resultsPending = 0;
        int havesSent = 0;
        int havesSinceLastContinue = 0;
        boolean receivedContinue = false;
        boolean receivedAck = false;
        boolean receivedReady = false;

        if (statelessRPC) {
            state.writeTo(out, null);
        }

        beginNegotiation();
        SEND_HAVES: for (;;) {
            final RevCommit c = walk.next();
            if (c == null) {
                break SEND_HAVES;
            }

            ObjectId o = c.getId();
            pckOut.writeString(PACKET_HAVE + o.name() + '\n');
            havesSent++;
            havesSinceLastContinue++;

            if ((31 & havesSent) != 0) {
                continue;
            }

            if (monitor.isCancelled()) {
                throw new CancelledException();
            }

            pckOut.end();
            resultsPending++;

            if (havesSent == 32 && !statelessRPC) {
                continue;
            }

            READ_RESULT: for (;;) {
                final AckNackResult anr = pckIn.readACK(ackId);
                switch (anr) {
                    case NAK:
                        resultsPending--;
                        break READ_RESULT;
                    case ACK:
                        multiAck = MultiAck.OFF;
                        resultsPending = 0;
                        receivedAck = true;
                        if (statelessRPC) {
                            state.writeTo(out, null);
                        }
                        break SEND_HAVES;
                    case ACK_CONTINUE:
                    case ACK_COMMON:
                    case ACK_READY:
                        markObjectAsCommon(walk.parseAny(ackId), anr, statelessRPC);
                        receivedAck = true;
                        receivedContinue = true;
                        havesSinceLastContinue = 0;
                        if (anr == AckNackResult.ACK_READY) {
                            receivedReady = true;
                        }
                        break;
                }

                if (monitor.isCancelled()) {
                    throw new CancelledException();
                }
            }

            if (noDone && receivedReady) {
                break SEND_HAVES;
            }
            if (statelessRPC) {
                state.writeTo(out, null);
            }

            if ((receivedContinue && havesSinceLastContinue > MAX_HAVES)
                    || havesSent >= maxHaves) {
                break SEND_HAVES;
            }
        }

        if (monitor.isCancelled()) {
            throw new CancelledException();
        }

        if (!receivedReady || !noDone) {
            pckOut.writeString(PACKET_DONE + '\n');
            pckOut.flush();
        }

        if (!receivedAck) {
            multiAck = MultiAck.OFF;
            resultsPending++;
        }

        if (mayHaveShallow) {
            String line = handleShallowUnshallow(shallowCommits, pckIn);
            if (!PacketLineIn.isEnd(line)) {
                throw new PackProtocolException(MessageFormat
                        .format(JGitText.get().expectedGot, PACKET_END, line));
            }
        }

        READ_RESULT: while (resultsPending > 0 || multiAck != MultiAck.OFF) {
            final AckNackResult anr = pckIn.readACK(ackId);
            resultsPending--;
            switch (anr) {
                case NAK:
                    break;
                case ACK:
                    break READ_RESULT;
                case ACK_CONTINUE:
                case ACK_COMMON:
                case ACK_READY:
                    multiAck = MultiAck.CONTINUE;
                    break;
            }

            if (monitor.isCancelled()) {
                throw new CancelledException();
            }
        }
    }

    private void beginNegotiation() throws IOException {
        walk.resetRetain(REACHABLE, ADVERTISED);
        walk.markStart(reachableCommits);
        walk.sort(RevSort.COMMIT_TIME_DESC);
        walk.setRevFilter(new RevFilter() {
            @Override
            public RevFilter clone() {
                return this;
            }

            @Override
            public boolean include(RevWalk walker, RevCommit c) {
                final boolean remoteKnowsIsCommon = c.has(COMMON);
                if (c.has(ADVERTISED)) {
                    c.add(COMMON);
                }
                return !remoteKnowsIsCommon;
            }

            @Override
            public boolean requiresCommitBody() {
                return false;
            }
        });
    }

    private void markAllRefsAsAdvertised() {
        for (Ref r : getRefs()) {
            markObjectAsAdvertised(r.getObjectId());
            if (r.getPeeledObjectId() != null)
                markObjectAsAdvertised(r.getPeeledObjectId());
        }
    }

    private void markObjectAsAdvertised(AnyObjectId id) {
        try {
            walk.parseAny(id).add(ADVERTISED);
        } catch (IOException readError) {
        }
    }

    private void markObjectAsCommon(RevObject obj, AckNackResult anr, boolean useState)
            throws IOException {
        if (useState && anr == AckNackResult.ACK_COMMON && !obj.has(STATE)) {
            pckState.writeString(PACKET_HAVE + obj.name() + '\n');
            obj.add(STATE);
        }
        obj.add(COMMON);
        if (obj instanceof RevCommit)
            ((RevCommit) obj).carry(COMMON);
    }

    // ... rest of the class unchanged; handleShallowUnshallow, sendShallow, receivePack, etc. ...
}
```

---

### Summary
- **Several method names** were improved for readability and clarity.
- **No functional code was changed**, only method names were updated and refactoring was consistently applied.

If you have further preferences (e.g., strict adherence to a naming pattern), let me know!