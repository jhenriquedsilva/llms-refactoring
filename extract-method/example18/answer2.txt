28-05-2025, 21:15
Yes, there **are clear extract method refactoring opportunities** in your code, especially for repeated code patterns related to "returning the mime type or application/octet-stream if unknown." These repeated logic fragments can be extracted into a helper method to reduce duplication, improve maintainability, and make the main methods clearer.

## Key Duplication

In the three `guessMimeType()` methods—one accepting `Path`, one accepting `InputStream`, and one accepting `byte[]`—the following block is repeated:

```java
if (contentInfo == null) {
    return ContentType.OTHER.getMimeType();
} else {
    return contentInfo.getContentType().getMimeType();
}
```
Let's extract this into a **private helper method**. Here is the entire refactored class:

---

```java
package org.apache.solr.util;

import com.j256.simplemagic.ContentInfo;
import com.j256.simplemagic.ContentInfoUtil;
import com.j256.simplemagic.ContentType;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Locale;
import java.util.Set;
import org.apache.solr.common.SolrException;

/** Utility class to guess the mime type of file based on its magic number. */
public class FileTypeMagicUtil implements ContentInfoUtil.ErrorCallBack {
    private final ContentInfoUtil util;
    private static final Set<String> SKIP_FOLDERS = new HashSet<>(Arrays.asList(".", ".."));

    public static FileTypeMagicUtil INSTANCE = new FileTypeMagicUtil();

    FileTypeMagicUtil() {
        try {
            util = new ContentInfoUtil("/magic/executables", this);
        } catch (IOException e) {
            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Error parsing magic file", e);
        }
    }

    /**
     * Asserts that an entire configset folder is legal to upload.
     *
     * @param confPath the path to the folder
     * @throws SolrException if an illegal file is found in the folder structure
     */
    public static void assertConfigSetFolderLegal(Path confPath) throws IOException {
        Files.walkFileTree(
                confPath,
                new SimpleFileVisitor<>() {
                    @Override
                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
                        if (FileTypeMagicUtil.isFileForbiddenInConfigset(file)) {
                            throw new SolrException(
                                    SolrException.ErrorCode.BAD_REQUEST,
                                    String.format(
                                            Locale.ROOT,
                                            "Not uploading file %s to configset, as it matched the MAGIC signature of a forbidden mime type %s",
                                            file,
                                            FileTypeMagicUtil.INSTANCE.guessMimeType(file)));
                        }
                        return FileVisitResult.CONTINUE;
                    }

                    @Override
                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
                        if (SKIP_FOLDERS.contains(dir.getFileName().toString()))
                            return FileVisitResult.SKIP_SUBTREE;

                        return FileVisitResult.CONTINUE;
                    }
                });
    }

    /**
     * Guess the mime type of file based on its magic number.
     *
     * @param file file to check
     * @return string with content-type or "application/octet-stream" if unknown
     */
    public String guessMimeType(Path file) {
        try {
            ContentInfo contentInfo = util.findMatch(file.toFile());
            return toMimeType(contentInfo);
        } catch (IOException e) {
            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);
        }
    }

    /**
     * Guess the mime type of file based on its magic number.
     *
     * @param stream input stream of the file
     * @return string with content-type or "application/octet-stream" if unknown
     */
    String guessMimeType(InputStream stream) {
        try {
            ContentInfo contentInfo = util.findMatch(stream);
            return toMimeType(contentInfo);
        } catch (IOException e) {
            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);
        }
    }

    /**
     * Guess the mime type of file bytes based on its magic number.
     *
     * @param bytes the first bytes at start of the file
     * @return string with content-type or "application/octet-stream" if unknown
     */
    public String guessMimeType(byte[] bytes) {
        ContentInfo contentInfo = util.findMatch(bytes);
        return toMimeType(contentInfo);
    }

    /**
     * Extracts the mime type from ContentInfo or returns the default if unknown.
     *
     * @param contentInfo the ContentInfo object (may be null)
     * @return string with content-type or "application/octet-stream" if unknown
     */
    private String toMimeType(ContentInfo contentInfo) {
        if (contentInfo == null) {
            return ContentType.OTHER.getMimeType();
        } else {
            return contentInfo.getContentType().getMimeType();
        }
    }

    @Override
    public void error(String line, String details, Exception e) {
        throw new SolrException(
                SolrException.ErrorCode.SERVER_ERROR,
                String.format(Locale.ROOT, "%s: %s", line, details),
                e);
    }

    /**
     * Determine forbidden file type based on magic bytes matching of the file itself. Forbidden types
     * are:
     *
     * <ul>
     *   <li><code>application/x-java-applet</code>: java class file
     *   <li><code>application/zip</code>: jar or zip archives
     *   <li><code>application/x-tar</code>: tar archives
     *   <li><code>text/x-shellscript</code>: shell or bash script
     * </ul>
     *
     * @param file file to check
     * @return true if file is among the forbidden mime-types
     */
    public static boolean isFileForbiddenInConfigset(Path file) {
        try (InputStream fileStream = Files.newInputStream(file)) {
            return isFileForbiddenInConfigset(fileStream);
        } catch (IOException e) {
            throw new SolrException(
                    SolrException.ErrorCode.SERVER_ERROR,
                    String.format(Locale.ROOT, "Error reading file %s", file),
                    e);
        }
    }

    /**
     * Determine forbidden file type based on magic bytes matching of the file itself. Forbidden types
     * are:
     *
     * <ul>
     *   <li><code>application/x-java-applet</code>: java class file
     *   <li><code>application/zip</code>: jar or zip archives
     *   <li><code>application/x-tar</code>: tar archives
     *   <li><code>text/x-shellscript</code>: shell or bash script
     * </ul>
     *
     * @param fileStream stream from the file content
     * @return true if file is among the forbidden mime-types
     */
    static boolean isFileForbiddenInConfigset(InputStream fileStream) {
        return forbiddenTypes.contains(FileTypeMagicUtil.INSTANCE.guessMimeType(fileStream));
    }

    /**
     * Determine forbidden file type based on magic bytes matching of the first bytes of the file.
     *
     * @param bytes byte array of the file content
     * @return true if file is among the forbidden mime-types
     */
    public static boolean isFileForbiddenInConfigset(byte[] bytes) {
        if (bytes == null || bytes.length == 0)
            return false; // A ZK znode may be a folder with no content
        return forbiddenTypes.contains(FileTypeMagicUtil.INSTANCE.guessMimeType(bytes));
    }

    private static final Set<String> forbiddenTypes =
            new HashSet<>(
                    Arrays.asList(
                            System.getProperty(
                                            "solr.configset.upload.mimetypes.forbidden",
                                            "application/x-java-applet,application/zip,application/x-tar,text/x-shellscript")
                                    .split(",")));

}
```

---

**Summary:**
- Introduced `private String toMimeType(ContentInfo contentInfo)` to encapsulate and deduplicate the null check logic.
- All `guessMimeType` overloads now use this helper, making them more readable and consistent.

This is a classic **extract method refactoring** opportunity!

Levenshtein edit-distance: 946
Compiles
Tests pass