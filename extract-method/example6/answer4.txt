27-05-2025, 20:07

### Code Review: Extract Method Refactoring Opportunities

#### Analysis

Upon examining the code, two main kinds of code duplication can be observed:

1. **Nested Loops (across several test methods):**
   - The triple nested loop:
     ```java
     for (int i = 0; i <= 4; i++) {
         for (int j = 0; j <= 2; j++) {
             int fileSize = (int) Math.pow(2, i) * 256 * ONE_KB;
             int footerReadBufferSize = (int) Math.pow(2, j) * 256 * ONE_KB;
             ...
         }
     }
     ```
     This is copied and pasted in `testNumBackendCalls`, `testSeekAndReadWithConf`, `testPartialReadWithNoData`, and `testPartialReadWithSomeData`.

2. **File Preparation Pattern:**
   - In these places, `getFileSystem`, building filenames, random content, and `createFileWithContent` all follow the same "setup" pattern.

#### Refactoring Approach

- **Extract a Method** for the nested double-loop with a strategy callback acting on each test case encountered by the loop.
- **Extract a Method** for file preparation (filesystem, filename, file content, and path creation).

The goal is to improve readability, test maintainability, and help avoid errors in future test extension.

---

## Refactored Code

```java
package org.apache.hadoop.fs.azurebfs.services;

import java.io.IOException;
import java.util.Map;
import java.util.function.BiConsumer;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FutureDataInputStreamBuilder;
import org.apache.hadoop.fs.azurebfs.AzureBlobFileSystemStore;

import org.assertj.core.api.Assertions;
import org.junit.Test;

import org.apache.hadoop.fs.FSDataInputStream;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.fs.azurebfs.AbfsConfiguration;
import org.apache.hadoop.fs.azurebfs.AzureBlobFileSystem;
import org.apache.hadoop.fs.azurebfs.utils.TracingContext;

import static java.lang.Math.max;
import static java.lang.Math.min;

import static org.apache.hadoop.fs.azurebfs.constants.ConfigurationKeys.AZURE_FOOTER_READ_BUFFER_SIZE;
import static org.apache.hadoop.fs.azurebfs.constants.FileSystemConfigurations.DEFAULT_FOOTER_READ_BUFFER_SIZE;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.spy;

import static org.apache.hadoop.fs.azurebfs.AbfsStatistic.CONNECTIONS_MADE;
import static org.apache.hadoop.fs.azurebfs.constants.FileSystemConfigurations.ONE_KB;

/**
 * Refactored test class with method extraction for repeated test-loop scaffolding and
 * file preparation patterns.
 */
public class ITestAbfsInputStreamReadFooter extends ITestAbfsInputStream {

    private static final int TEN = 10;
    private static final int TWENTY = 20;

    public ITestAbfsInputStreamReadFooter() throws Exception {
    }

    @Test
    public void testOnlyOneServerCallIsMadeWhenTheConfIsTrue() throws Exception {
        loopOverFileAndBufferSizes((idx, params) ->
            runTestNumBackendCalls(params, true, idx)
        );
    }

    @Test
    public void testMultipleServerCallsAreMadeWhenTheConfIsFalse() throws Exception {
        loopOverFileAndBufferSizes((idx, params) ->
            runTestNumBackendCalls(params, false, idx)
        );
    }

    private void runTestNumBackendCalls(FileTestParams params, boolean optimizeFooterRead, int fileIdx)
            throws Exception {
        final AzureBlobFileSystem fs = getFileSystem(optimizeFooterRead, params.fileSize);
        String fileName = methodName.getMethodName() + fileIdx;
        byte[] fileContent = getRandomBytesArray(params.fileSize);
        Path testFilePath = createFileWithContent(fs, fileName, fileContent);
        int length = AbfsInputStream.FOOTER_SIZE;
        FutureDataInputStreamBuilder builder = getParameterizedBuilder(
                testFilePath, fs, params.footerReadBufferSize);
        try (FSDataInputStream iStream = builder.build().get()) {
            verifyConfigValueInStream(iStream, params.footerReadBufferSize);
            byte[] buffer = new byte[length];

            Map<String, Long> metricMap = getInstrumentationMap(fs);
            long requestsMadeBeforeTest = metricMap
                    .get(CONNECTIONS_MADE.getStatName());

            iStream.seek(params.fileSize - 8);
            iStream.read(buffer, 0, length);

            iStream.seek(params.fileSize - (TEN * ONE_KB));
            iStream.read(buffer, 0, length);

            iStream.seek(params.fileSize - (TWENTY * ONE_KB));
            iStream.read(buffer, 0, length);

            metricMap = getInstrumentationMap(fs);
            long requestsMadeAfterTest = metricMap
                    .get(CONNECTIONS_MADE.getStatName());

            if (optimizeFooterRead) {
                assertEquals(1, requestsMadeAfterTest - requestsMadeBeforeTest);
            } else {
                assertEquals(3, requestsMadeAfterTest - requestsMadeBeforeTest);
            }
        }
    }

    // Seek and read tests use same loop
    @Test
    public void testSeekToBeginAndReadWithConfTrue() throws Exception {
        loopOverFileAndBufferSizes((idx, params) ->
            testSeekAndReadWithConf(true, SeekTo.BEGIN, params, idx)
        );
    }

    @Test
    public void testSeekToBeginAndReadWithConfFalse() throws Exception {
        loopOverFileAndBufferSizes((idx, params) ->
            testSeekAndReadWithConf(false, SeekTo.BEGIN, params, idx)
        );
    }

    @Test
    public void testSeekToBeforeFooterAndReadWithConfTrue() throws Exception {
        loopOverFileAndBufferSizes((idx, params) ->
            testSeekAndReadWithConf(true, SeekTo.BEFORE_FOOTER_START, params, idx)
        );
    }

    @Test
    public void testSeekToBeforeFooterAndReadWithConfFalse() throws Exception {
        loopOverFileAndBufferSizes((idx, params) ->
            testSeekAndReadWithConf(false, SeekTo.BEFORE_FOOTER_START, params, idx)
        );
    }

    @Test
    public void testSeekToFooterAndReadWithConfTrue() throws Exception {
        loopOverFileAndBufferSizes((idx, params) ->
            testSeekAndReadWithConf(true, SeekTo.AT_FOOTER_START, params, idx)
        );
    }

    @Test
    public void testSeekToFooterAndReadWithConfFalse() throws Exception {
        loopOverFileAndBufferSizes((idx, params) ->
            testSeekAndReadWithConf(false, SeekTo.AT_FOOTER_START, params, idx)
        );
    }

    @Test
    public void testSeekToAfterFooterAndReadWithConfTrue() throws Exception {
        loopOverFileAndBufferSizes((idx, params) ->
            testSeekAndReadWithConf(true, SeekTo.AFTER_FOOTER_START, params, idx)
        );
    }

    @Test
    public void testSeekToToAfterFooterAndReadWithConfFalse() throws Exception {
        loopOverFileAndBufferSizes((idx, params) ->
            testSeekAndReadWithConf(false, SeekTo.AFTER_FOOTER_START, params, idx)
        );
    }

    @Test
    public void testSeekToEndAndReadWithConfTrue() throws Exception {
        loopOverFileAndBufferSizes((idx, params) ->
            testSeekAndReadWithConf(true, SeekTo.END, params, idx)
        );
    }

    @Test
    public void testSeekToEndAndReadWithConfFalse() throws Exception {
        loopOverFileAndBufferSizes((idx, params) ->
            testSeekAndReadWithConf(false, SeekTo.END, params, idx)
        );
    }


    private void testSeekAndReadWithConf(boolean optimizeFooterRead,
                                         SeekTo seekTo,
                                         FileTestParams params,
                                         int fileIdx) throws Exception {
        final AzureBlobFileSystem fs = getFileSystem(
                optimizeFooterRead, params.fileSize);
        String fileName = methodName.getMethodName() + fileIdx;
        byte[] fileContent = getRandomBytesArray(params.fileSize);
        Path testFilePath = createFileWithContent(fs, fileName, fileContent);
        seekReadAndTest(fs, testFilePath, seekPos(seekTo, params.fileSize), HUNDRED,
                fileContent, params.footerReadBufferSize);
    }

    // Loop extraction utility: executes action for each combo of fileSize & bufferSize.
    private void loopOverFileAndBufferSizes(BiConsumer<Integer, FileTestParams> testAction) throws Exception {
        int fileIdx = 0;
        for (int i = 0; i <= 4; i++) {
            for (int j = 0; j <= 2; j++) {
                int fileSize = (int) Math.pow(2, i) * 256 * ONE_KB;
                int bufferSize = (int) Math.pow(2, j) * 256 * ONE_KB;
                testAction.accept(fileIdx++, new FileTestParams(fileSize, bufferSize));
            }
        }
    }

    // A record for parameters inside the common loop
    private static class FileTestParams {
        int fileSize;
        int footerReadBufferSize;
        FileTestParams(int fileSize, int bufferSize) {
            this.fileSize = fileSize;
            this.footerReadBufferSize = bufferSize;
        }
    }

    private int seekPos(SeekTo seekTo, int fileSize) {
        if (seekTo == SeekTo.BEGIN) {
            return 0;
        }
        if (seekTo == SeekTo.BEFORE_FOOTER_START) {
            return fileSize - AbfsInputStream.FOOTER_SIZE - 1;
        }
        if (seekTo == SeekTo.AT_FOOTER_START) {
            return fileSize - AbfsInputStream.FOOTER_SIZE;
        }
        if (seekTo == SeekTo.END) {
            return fileSize - 1;
        }
        //seekTo == SeekTo.AFTER_FOOTER_START
        return fileSize - AbfsInputStream.FOOTER_SIZE + 1;
    }

    private void seekReadAndTest(final AzureBlobFileSystem fs,
                                 final Path testFilePath, final int seekPos, final int length,
                                 final byte[] fileContent, int footerReadBufferSize) throws Exception {
        AbfsConfiguration conf = getAbfsStore(fs).getAbfsConfiguration();
        long actualContentLength = fileContent.length;
        FutureDataInputStreamBuilder builder = getParameterizedBuilder(
                testFilePath, fs, footerReadBufferSize);
        try (FSDataInputStream iStream = builder.build().get()) {
            AbfsInputStream abfsInputStream = (AbfsInputStream) iStream.getWrappedStream();
            verifyConfigValueInStream(iStream, footerReadBufferSize);
            long readBufferSize = abfsInputStream.getBufferSize();
            seek(iStream, seekPos);
            byte[] buffer = new byte[length];
            long bytesRead = iStream.read(buffer, 0, length);

            long footerStart = max(0,
                    actualContentLength - AbfsInputStream.FOOTER_SIZE);
            boolean optimizationOn =
                    conf.optimizeFooterRead() && seekPos >= footerStart;

            long actualLength = length;
            if (seekPos + length > actualContentLength) {
                long delta = seekPos + length - actualContentLength;
                actualLength = length - delta;
            }
            long expectedLimit;
            long expectedBCursor;
            long expectedFCursor;
            if (optimizationOn) {
                if (actualContentLength <= footerReadBufferSize) {
                    expectedLimit = actualContentLength;
                    expectedBCursor = seekPos + actualLength;
                } else {
                    expectedLimit = footerReadBufferSize;
                    long lastBlockStart = max(0, actualContentLength - footerReadBufferSize);
                    expectedBCursor = seekPos - lastBlockStart + actualLength;
                }
                expectedFCursor = actualContentLength;
            } else {
                if (seekPos + readBufferSize < actualContentLength) {
                    expectedLimit = readBufferSize;
                    expectedFCursor = readBufferSize;
                } else {
                    expectedLimit = actualContentLength - seekPos;
                    expectedFCursor = min(seekPos + readBufferSize, actualContentLength);
                }
                expectedBCursor = actualLength;
            }

            assertEquals(expectedFCursor, abfsInputStream.getFCursor());
            assertEquals(expectedFCursor, abfsInputStream.getFCursorAfterLastRead());
            assertEquals(expectedLimit, abfsInputStream.getLimit());
            assertEquals(expectedBCursor, abfsInputStream.getBCursor());
            assertEquals(actualLength, bytesRead);
            //  Verify user-content read
            assertContentReadCorrectly(fileContent, seekPos, (int) actualLength, buffer, testFilePath);
            //  Verify data read to AbfsInputStream buffer
            int from = seekPos;
            if (optimizationOn) {
                from = (int) max(0, actualContentLength - footerReadBufferSize);
            }
            assertContentReadCorrectly(fileContent, from, (int) abfsInputStream.getLimit(),
                    abfsInputStream.getBuffer(), testFilePath);
        }
    }

    @Test
    public void testPartialReadWithNoData() throws Exception {
        loopOverFileAndBufferSizes((idx, params) -> {
            try {
                final AzureBlobFileSystem fs = getFileSystem(
                        true, params.fileSize, params.footerReadBufferSize);
                String fileName = methodName.getMethodName() + idx;
                byte[] fileContent = getRandomBytesArray(params.fileSize);
                Path testFilePath = createFileWithContent(fs, fileName, fileContent);
                testPartialReadWithNoData(fs, testFilePath,
                        params.fileSize - AbfsInputStream.FOOTER_SIZE, AbfsInputStream.FOOTER_SIZE,
                        fileContent, params.footerReadBufferSize);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
    }

    private void testPartialReadWithNoData(final FileSystem fs,
                                           final Path testFilePath, final int seekPos, final int length,
                                           final byte[] fileContent, int footerReadBufferSize) throws IOException {
        FSDataInputStream iStream = fs.open(testFilePath);
        try {
            AbfsInputStream abfsInputStream = (AbfsInputStream) iStream
                    .getWrappedStream();
            Assertions.assertThat(abfsInputStream.getFooterReadBufferSize())
                    .describedAs("Footer Read Buffer Size Should be same as what set in builder")
                    .isEqualTo(footerReadBufferSize);
            abfsInputStream = spy(abfsInputStream);
            doReturn(10).doReturn(10).doCallRealMethod().when(abfsInputStream)
                    .readRemote(anyLong(), any(), anyInt(), anyInt(),
                            any(TracingContext.class));

            iStream = new FSDataInputStream(abfsInputStream);
            seek(iStream, seekPos);

            byte[] buffer = new byte[length];
            int bytesRead = iStream.read(buffer, 0, length);
            assertEquals(length, bytesRead);
            assertContentReadCorrectly(fileContent, seekPos, length, buffer, testFilePath);
            assertEquals(fileContent.length, abfsInputStream.getFCursor());
            assertEquals(length, abfsInputStream.getBCursor());
            assertTrue(abfsInputStream.getLimit() >= length);
        } finally {
            iStream.close();
        }
    }

    @Test
    public void testPartialReadWithSomeData() throws Exception {
        loopOverFileAndBufferSizes((idx, params) -> {
            try {
                final AzureBlobFileSystem fs = getFileSystem(true,
                        params.fileSize, params.footerReadBufferSize);
                String fileName = methodName.getMethodName() + idx;
                byte[] fileContent = getRandomBytesArray(params.fileSize);
                Path testFilePath = createFileWithContent(fs, fileName, fileContent);
                testPartialReadWithSomeData(fs, testFilePath,
                        params.fileSize - AbfsInputStream.FOOTER_SIZE, AbfsInputStream.FOOTER_SIZE,
                        fileContent, params.footerReadBufferSize);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
    }

    private void testPartialReadWithSomeData(final FileSystem fs,
                                             final Path testFilePath, final int seekPos, final int length,
                                             final byte[] fileContent, final int footerReadBufferSize) throws IOException {
        FSDataInputStream iStream = fs.open(testFilePath);
        try {
            verifyConfigValueInStream(iStream, footerReadBufferSize);
            AbfsInputStream abfsInputStream = spy((AbfsInputStream) iStream
                    .getWrappedStream());
            //  first readRemote, will return first 10 bytes
            //  second readRemote returns data till the last 2 bytes
            int someDataLength = 2;
            int secondReturnSize =
                    min(fileContent.length, abfsInputStream.getFooterReadBufferSize()) - 10
                            - someDataLength;
            doReturn(10).doReturn(secondReturnSize).doCallRealMethod()
                    .when(abfsInputStream)
                    .readRemote(anyLong(), any(), anyInt(), anyInt(),
                            any(TracingContext.class));

            iStream = new FSDataInputStream(abfsInputStream);
            seek(iStream, seekPos);

            byte[] buffer = new byte[length];
            int bytesRead = iStream.read(buffer, 0, length);
            assertEquals(length, bytesRead);
            assertEquals(fileContent.length, abfsInputStream.getFCursor());
            //  someDataLength(2), because in the do-while loop in read, the 2nd loop
            //  will go to readoneblock and that resets the bCursor to 0 as
            //  bCursor == limit finally when the 2 bytes are read bCursor and limit
            //  will be at someDataLength(2)
            assertEquals(someDataLength, abfsInputStream.getBCursor());
            assertEquals(someDataLength, abfsInputStream.getLimit());
        } finally {
            iStream.close();
        }
    }

    @Test
    public void testFooterReadBufferSizeConfiguration() throws Exception {
        Configuration config = new Configuration(this.getRawConfiguration());
        config.unset(AZURE_FOOTER_READ_BUFFER_SIZE);
        try (AzureBlobFileSystem fs = (AzureBlobFileSystem) FileSystem.newInstance(config)){
            int fileIdx = 0;
            int fileSize = ONE_KB;
            String fileName = methodName.getMethodName() + fileIdx;
            byte[] fileContent = getRandomBytesArray(fileSize);
            Path testFilePath = createFileWithContent(fs, fileName, fileContent);
            final int footerReadBufferSizeConfig = 4 * ONE_KB;
            final int footerReadBufferSizeBuilder = 5 * ONE_KB;

            // Verify that default value is used if nothing is set explicitly
            FSDataInputStream iStream = fs.open(testFilePath);
            verifyConfigValueInStream(iStream, DEFAULT_FOOTER_READ_BUFFER_SIZE);

            // Verify that value set in config is used if builder is not used
            getAbfsStore(fs).getAbfsConfiguration()
                    .setFooterReadBufferSize(footerReadBufferSizeConfig);
            iStream = fs.open(testFilePath);
            verifyConfigValueInStream(iStream, footerReadBufferSizeConfig);

            // Verify that when builder is used value set in parameters is used
            getAbfsStore(fs).getAbfsConfiguration().unset(AZURE_FOOTER_READ_BUFFER_SIZE);
            FutureDataInputStreamBuilder builder = fs.openFile(testFilePath);
            builder.opt(AZURE_FOOTER_READ_BUFFER_SIZE,
                    footerReadBufferSizeBuilder);
            iStream = builder.build().get();
            verifyConfigValueInStream(iStream, footerReadBufferSizeBuilder);

            // Verify that when builder is used value set in parameters is used
            // even if config is set
            getAbfsStore(fs).getAbfsConfiguration()
                    .setFooterReadBufferSize(footerReadBufferSizeConfig);
            iStream = builder.build().get();
            verifyConfigValueInStream(iStream, footerReadBufferSizeBuilder);

            // Verify that when the builder is used and parameter in builder is not set,
            // the value set in configuration is used
            getAbfsStore(fs).getAbfsConfiguration()
                    .setFooterReadBufferSize(footerReadBufferSizeConfig);
            builder = fs.openFile(testFilePath);
            iStream = builder.build().get();
            verifyConfigValueInStream(iStream, footerReadBufferSizeConfig);
        }
    }

    private void verifyConfigValueInStream(final FSDataInputStream inputStream,
                                           final int expectedValue) {
        AbfsInputStream stream = (AbfsInputStream) inputStream.getWrappedStream();
        Assertions.assertThat(stream.getFooterReadBufferSize())
                .describedAs(
                        "Footer Read Buffer Size Value Is Not As Expected")
                .isEqualTo(expectedValue);
    }

    private FutureDataInputStreamBuilder getParameterizedBuilder(final Path path,
                                                                 final AzureBlobFileSystem fs, int footerReadBufferSize) throws Exception {
        FutureDataInputStreamBuilder builder = fs.openFile(path);
        builder.opt(AZURE_FOOTER_READ_BUFFER_SIZE,
                footerReadBufferSize);
        return builder;
    }

    private AzureBlobFileSystem getFileSystem(final boolean optimizeFooterRead,
                                              final int fileSize) throws IOException {
        final AzureBlobFileSystem fs = getFileSystem();
        AzureBlobFileSystemStore store = getAbfsStore(fs);
        store.getAbfsConfiguration().setOptimizeFooterRead(optimizeFooterRead);
        if (fileSize <= store.getAbfsConfiguration().getReadBufferSize()) {
            store.getAbfsConfiguration().setReadSmallFilesCompletely(false);
        }
        return fs;
    }

    private AzureBlobFileSystem getFileSystem(final boolean optimizeFooterRead,
                                              final int fileSize, final int footerReadBufferSize) throws IOException {
        final AzureBlobFileSystem fs = getFileSystem();
        AzureBlobFileSystemStore store = getAbfsStore(fs);
        store.getAbfsConfiguration().setOptimizeFooterRead(optimizeFooterRead);
        store.getAbfsConfiguration().setFooterReadBufferSize(footerReadBufferSize);
        if (fileSize <= store.getAbfsConfiguration().getReadBufferSize()) {
            store.getAbfsConfiguration().setReadSmallFilesCompletely(false);
        }
        return fs;
    }

    private enum SeekTo {
        BEGIN, AT_FOOTER_START, BEFORE_FOOTER_START, AFTER_FOOTER_START, END
    }
}
```

---

### **Summary of Refactoring**
- Introduced a `loopOverFileAndBufferSizes` method to consolidate all the repeated size/buffer testing loops.
- Pulled the main parameters into a simple utility class (`FileTestParams`).
- Tests now simply call the loop, passing a lambda, which executes the original inner test for one set of parameters; the main logic is moved to a helper.
- This significantly reduces code duplication and increases maintainability and readability.

---

If you have any further constraints or would prefer a different flavor of extraction, I can make other adjustments!

Levenshtein edit-distance: 4008