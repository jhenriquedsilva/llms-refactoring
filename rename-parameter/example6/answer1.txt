01-05-2025, 11:03

Below are the **rename parameter refactoring** opportunities found in your code. The goal is to enhance code readability by choosing more expressive, context-appropriate parameter names, especially in public or non-trivial methods. Here are places where better parameter names are possible:

### Refactoring Opportunities

#### 1. `runTest(Runnable test)`
- **test** → **testLogic** (the name “test” is too generic and conflicts mentally with "test" as in a test case; “testLogic” makes it clear it's the logic to execute).

#### 2. `allocateContainers(AMRMClientImpl<ContainerRequest> client)`
- **client** → **amrmClient** (more context specific).

#### 3. `testContainerManagement(NMClientImpl client, Set<Container> containers)`
- **client** → **nmClientImpl** (more context specific).

#### 4. `testContainer(NMClientImpl client, int i, Container container, ContainerLaunchContext clc, List<Integer> exitCode)`
- **client** → **nmClientImpl**
- **i** → **containerIndex**
- **exitCode** → **exitStatuses** (since it's List<Integer>)

#### 5. `waitForContainerRunningTransitionCount(Container container, long transitions)`
- **transitions** → **expectedTransitionCount** (makes it clear what the long parameter means).

#### 6. `testGetContainerStatus(Container container, int index, ... )`
- **index** → **containerIndex**

---

## Refactored Code

Below is the whole class with the proposed rename parameter refactorings applied:

```java
// ... [Imports unchanged]

public class TestNMClient {
    // ... [Fields and constants unchanged]

    /**
     * Container State transition listener to track the number of times
     * a container has transitioned into a state.
     */
    public static class DebugSumContainerStateListener implements ContainerStateTransitionListener {
        public static final Map<ContainerId, Integer> RUNNING_TRANSITIONS = new ConcurrentHashMap<>();

        public void init(Context context) {}

        public void preTransition(ContainerImpl op,
                                  org.apache.hadoop.yarn.server.nodemanager
                                          .containermanager.container.ContainerState
                                          beforeState,
                                  ContainerEvent eventToBeProcessed) {
        }

        public void postTransition(
                ContainerImpl op,
                org.apache.hadoop.yarn.server.nodemanager.containermanager.container
                        .ContainerState beforeState,
                org.apache.hadoop.yarn.server.nodemanager.containermanager.container
                        .ContainerState afterState,
                ContainerEvent processedEvent) {
            if (beforeState != afterState &&
                    afterState == org.apache.hadoop.yarn.server.nodemanager.containermanager.container
                            .ContainerState.RUNNING) {
                RUNNING_TRANSITIONS.compute(op.getContainerId(),
                        (containerId, counter) -> counter == null ? 1 : ++counter);
            }
        }
    }

    // ... [setup, startYarnCluster, startYarnClient, startRMClient, startNMClient, tearDown, tests unchanged]

    public void runTest(Runnable testLogic)
            throws IOException, InterruptedException, YarnException, TimeoutException {
        setup();
        rmClient.registerApplicationMaster("Host", 10_000, "");
        testContainerManagement(nmClient, allocateContainers(rmClient));
        rmClient.unregisterApplicationMaster(FinalApplicationStatus.SUCCEEDED, null, null);
        testLogic.run();
        tearDown();
    }

    private void stopNmClient() {
        assertNotNull("Null nmClient", nmClient);
        // leave one unclosed
        assertEquals(1, nmClient.startedContainers.size());
        // default true
        assertTrue(nmClient.getCleanupRunningContainers().get());
        nmClient.cleanupRunningContainersOnStop(false);
        assertFalse(nmClient.getCleanupRunningContainers().get());
        nmClient.stop();
    }

    private Set<Container> allocateContainers(AMRMClientImpl<ContainerRequest> amrmClient)
            throws YarnException, IOException {
        for (int i = 0; i < NUMBER_OF_CONTAINERS; ++i) {
            amrmClient.addContainerRequest(new ContainerRequest(
                    Resource.newInstance(1024, 0),
                    new String[] {nodeReports.get(0).getNodeId().getHost()},
                    new String[] {nodeReports.get(0).getRackName()},
                    Priority.newInstance(0)
            ));
        }
        Set<Container> allocatedContainers = new TreeSet<>();
        while (allocatedContainers.size() < NUMBER_OF_CONTAINERS) {
            AllocateResponse allocResponse = amrmClient.allocate(0.1f);
            allocatedContainers.addAll(allocResponse.getAllocatedContainers());
            for (NMToken token : allocResponse.getNMTokens()) {
                amrmClient.getNMTokenCache().setToken(token.getNodeId().toString(), token.getToken());
            }
            if (allocatedContainers.size() < NUMBER_OF_CONTAINERS) {
                sleep(100);
            }
        }
        return allocatedContainers;
    }

    private void testContainerManagement(NMClientImpl nmClientImpl, Set<Container> containers)
            throws YarnException, IOException {
        int size = containers.size();
        int containerIndex = 0;
        for (Container container : containers) {
            // getContainerStatus shouldn't be called before startContainer,
            // otherwise, NodeManager cannot find the container
            assertYarnException(
                    () -> nmClientImpl.getContainerStatus(container.getId(), container.getNodeId()),
                    IS_NOT_HANDLED_BY_THIS_NODEMANAGER);
            // upadateContainerResource shouldn't be called before startContainer,
            // otherwise, NodeManager cannot find the container
            assertYarnException(
                    () -> nmClientImpl.updateContainerResource(container),
                    IS_NOT_HANDLED_BY_THIS_NODEMANAGER);
            // restart shouldn't be called before startContainer,
            // otherwise, NodeManager cannot find the container
            assertYarnException(
                    () -> nmClientImpl.restartContainer(container.getId()),
                    UNKNOWN_CONTAINER);
            // rollback shouldn't be called before startContainer,
            // otherwise, NodeManager cannot find the container
            assertYarnException(
                    () -> nmClientImpl.rollbackLastReInitialization(container.getId()),
                    UNKNOWN_CONTAINER);
            // commit shouldn't be called before startContainer,
            // otherwise, NodeManager cannot find the container
            assertYarnException(
                    () -> nmClientImpl.commitLastReInitialization(container.getId()),
                    UNKNOWN_CONTAINER);
            // stopContainer shouldn't be called before startContainer,
            // otherwise, an exception will be thrown
            assertYarnException(
                    () -> nmClientImpl.stopContainer(container.getId(), container.getNodeId()),
                    IS_NOT_HANDLED_BY_THIS_NODEMANAGER);

            Credentials ts = new Credentials();
            DataOutputBuffer dob = new DataOutputBuffer();
            ts.writeTokenStorageToStream(dob);
            ByteBuffer securityTokens = ByteBuffer.wrap(dob.getData(), 0, dob.getLength());
            ContainerLaunchContext clc = Records.newRecord(ContainerLaunchContext.class);
            clc.setCommands(Shell.WINDOWS
                    ? Arrays.asList("ping", "-n", "10000000", "127.0.0.1", ">nul")
                    : Arrays.asList("sleep", "1000000")
            );
            clc.setTokens(securityTokens);
            nmClientImpl.startContainer(container, clc);
            List<Integer> exitStatuses = Arrays.asList(-1000, -105);

            containerIndex++;
            // leave one container unclosed
            if (containerIndex < size) {
                testContainer(nmClientImpl, containerIndex, container, clc, exitStatuses);
            }
        }
    }

    private void testContainer(NMClientImpl nmClientImpl, int containerIndex, Container container,
                               ContainerLaunchContext clc, List<Integer> exitStatuses)
            throws YarnException, IOException {
        testGetContainerStatus(container, containerIndex, ContainerState.RUNNING, "",
                exitStatuses);
        waitForContainerRunningTransitionCount(container, 1);
        testIncreaseContainerResource(container);
        testRestartContainer(container);
        testGetContainerStatus(container, containerIndex, ContainerState.RUNNING,
                "will be Restarted", exitStatuses);
        waitForContainerRunningTransitionCount(container, 2);
        if (containerIndex % 2 == 0) {
            testReInitializeContainer(container, clc, false);
            testGetContainerStatus(container, containerIndex, ContainerState.RUNNING,
                    "will be Re-initialized", exitStatuses);
            waitForContainerRunningTransitionCount(container, 3);
            testContainerRollback(container, true);
            testGetContainerStatus(container, containerIndex, ContainerState.RUNNING,
                    "will be Rolled-back", exitStatuses);
            waitForContainerRunningTransitionCount(container, 4);
            testContainerCommit(container, false);
            testReInitializeContainer(container, clc, false);
            testGetContainerStatus(container, containerIndex, ContainerState.RUNNING,
                    "will be Re-initialized", exitStatuses);
            waitForContainerRunningTransitionCount(container, 5);
            testContainerCommit(container, true);
        } else {
            testReInitializeContainer(container, clc, true);
            testGetContainerStatus(container, containerIndex, ContainerState.RUNNING,
                    "will be Re-initialized", exitStatuses);
            waitForContainerRunningTransitionCount(container, 3);
            testContainerRollback(container, false);
            testContainerCommit(container, false);
        }
        nmClientImpl.stopContainer(container.getId(), container.getNodeId());
        testGetContainerStatus(container, containerIndex, ContainerState.COMPLETE,
                "killed by the ApplicationMaster", exitStatuses);
    }

    private void waitForContainerRunningTransitionCount(Container container, long expectedTransitionCount) {
        while (DebugSumContainerStateListener.RUNNING_TRANSITIONS
                .getOrDefault(container.getId(), 0) != expectedTransitionCount) {
            sleep(500);
        }
    }

    private void testGetContainerStatus(Container container, int containerIndex,
                                        ContainerState state, String diagnostics,
                                        List<Integer> exitStatuses)
            throws YarnException, IOException {
        while (true) {
            sleep(250);
            ContainerStatus status = nmClient.getContainerStatus(
                    container.getId(), container.getNodeId());
            // NodeManager may still need some time to get the stable
            // container status
            if (status.getState() == state) {
                assertEquals(container.getId(), status.getContainerId());
                assertTrue(containerIndex + ": " + status.getDiagnostics(),
                        status.getDiagnostics().contains(diagnostics));

                assertTrue("Exit Statuses are supposed to be in: " + exitStatuses +
                                ", but the actual exit status code is: " +
                                status.getExitStatus(),
                        exitStatuses.contains(status.getExitStatus()));
                break;
            }
        }
    }

    // ... [Other methods unchanged]
}
```

## Summary

- **Parameter names are now more descriptive, context-specific, and eliminate ambiguity.**
- No changes were made to method signatures where the names were already clear or to class/field names.
- The functional logic is unchanged.

---

**If you need a diff or further reasoning about each specific change, let me know!**
