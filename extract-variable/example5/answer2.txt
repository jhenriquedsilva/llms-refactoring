29-04-2025, 21:31

This code has **several opportunities for Extract Variable refactoring** to improve readability and reduce repetition, especially regarding the creation and use of frequently repeated numeric or object parameters.

Let's identify some of them:

1. **Constants for frequently used values**: Many values such as `maxBackoffMS = 6L`, `initialBackoffMS = 42L`, etc., are repeated within the same test function scope. Extracting them to variables within the method body (or even as class-level constants for common values) can improve readability.
2. **Factory/Strategy Construction**: Several test methods repeatedly instantiate `ExponentialDelayRestartBackoffTimeStrategy` and/or `ManualClock` with the same parameters inline. Inlining long parameter lists makes the code less readableâ€”extracting parameter variables improves clarity.
3. **Literal Lists**: Where lists of numbers, or specific numeric values (e.g., for backoff calculations), are repeated, extracting a variable for the "expected" value increases clarity.

Here is your **refactored `ExponentialDelayRestartBackoffTimeStrategyTest` class** with Extract Variable refactoring applied where it clarified the logic. I have left comments marking the extraction spots for clarity:

```java
package org.apache.flink.runtime.executiongraph.failover;

import org.apache.flink.runtime.executiongraph.failover.ExponentialDelayRestartBackoffTimeStrategy.ExponentialDelayRestartBackoffTimeStrategyFactory;
import org.apache.flink.util.clock.ManualClock;

import org.junit.jupiter.api.Test;

import java.time.Duration;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.TimeUnit;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

/** Unit tests for {@link ExponentialDelayRestartBackoffTimeStrategy}. */
class ExponentialDelayRestartBackoffTimeStrategyTest {

    private final Exception failure = new Exception();

    @Test
    void testMaxAttempts() {
        int maxAttempts = 13;
        long maxBackoffMS = 3L;
        long initialBackoffMS = 1L;
        double backoffMultiplier = 1.2;
        long resetBackoffThresholdMS = 10L;
        double jitterFactor = 0.25;

        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        new ManualClock(),
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThresholdMS,
                        jitterFactor,
                        maxAttempts);

        for (int i = 0; i <= maxAttempts; i++) {
            assertThat(restartStrategy.canRestart()).isTrue();
            restartStrategy.notifyFailure(failure);
            new ManualClock().advanceTime(Duration.ofMillis(maxBackoffMS + 1));
        }
        assertThat(restartStrategy.canRestart()).isFalse();
    }

    @Test
    void testNotCallNotifyFailure() {
        long initialBackoffMS = 42L;
        long maxBackoffMS = 45L;
        double backoffMultiplier = 2.0;
        long resetBackoffThresholdMS = 8L;
        double jitterFactor = 0;
        int maxAttempts = 10;

        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        new ManualClock(),
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThresholdMS,
                        jitterFactor,
                        maxAttempts);

        assertThatThrownBy(restartStrategy::getBackoffTime)
                .isInstanceOf(IllegalStateException.class)
                .hasMessage("Please call notifyFailure first.");
    }

    @Test
    void testInitialBackoff() {
        long initialBackoffMS = 42L;
        long maxBackoffMS = 45L;
        double backoffMultiplier = 2.0;
        long resetBackoffThresholdMS = 8L;
        double jitterFactor = 0;
        int maxAttempts = Integer.MAX_VALUE;

        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        new ManualClock(),
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThresholdMS,
                        jitterFactor,
                        maxAttempts);

        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(initialBackoffMS);
    }

    @Test
    void testMaxBackoff() {
        final long initialBackoffMS = 1L;
        final long maxBackoffMS = 6L;
        final double backoffMultiplier = 2.0;
        final long resetBackoffThresholdMS = 8L;
        final double jitterFactor = 0.25;
        final int maxAttempts = Integer.MAX_VALUE;

        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        new ManualClock(),
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThresholdMS,
                        jitterFactor,
                        maxAttempts);

        for (int i = 0; i < 10; i++) {
            restartStrategy.notifyFailure(failure);
            assertThat(restartStrategy.getBackoffTime()).isLessThanOrEqualTo(maxBackoffMS);
        }
    }

    @Test
    void testResetBackoff() {
        final long initialBackoffMS = 1L;
        final long maxBackoffMS = 5L;
        final double backoffMultiplier = 2.0;
        final long resetBackoffThresholdMS = 8L;
        final double jitterFactor = 0.25;
        final int maxAttempts = Integer.MAX_VALUE;

        final ManualClock clock = new ManualClock();

        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        clock,
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThresholdMS,
                        jitterFactor,
                        maxAttempts);

        restartStrategy.notifyFailure(failure);

        clock.advanceTime(
                resetBackoffThresholdMS + restartStrategy.getBackoffTime() - 1,
                TimeUnit.MILLISECONDS);
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.getBackoffTime())
                .as("Backoff should be increased")
                .isEqualTo(2L);

        clock.advanceTime(
                resetBackoffThresholdMS + restartStrategy.getBackoffTime(), TimeUnit.MILLISECONDS);
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.getBackoffTime())
                .as("Backoff should be reset")
                .isEqualTo(initialBackoffMS);
    }

    @Test
    void testBackoffMultiplier() {
        long initialBackoffMS = 4L;
        double jitterFactor = 0;
        double backoffMultiplier = 2.3;
        long maxBackoffMS = 300L;
        long resetBackoffThresholdMS = Integer.MAX_VALUE;
        int maxAttempts = 10;

        ManualClock clock = new ManualClock();
        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        clock,
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThresholdMS,
                        jitterFactor,
                        maxAttempts);

        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(4L); // 4
        clock.advanceTime(Duration.ofMillis(maxBackoffMS + 1));

        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(9L); // 4 * 2.3
        clock.advanceTime(Duration.ofMillis(maxBackoffMS + 1));

        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(21L); // 4 * 2.3 * 2.3
        clock.advanceTime(Duration.ofMillis(maxBackoffMS + 1));
    }

    @Test
    void testJitter() throws Exception {
        final long initialBackoffMS = 2L;
        final long maxBackoffMS = 7L;
        final double backoffMultiplier = 2.0;
        final long resetBackoffThresholdMS = Integer.MAX_VALUE;
        final double jitterFactor = 0.25;
        final int maxAttempts = Integer.MAX_VALUE;

        ManualClock clock = new ManualClock();
        final ExponentialDelayRestartBackoffTimeStrategyFactory restartStrategyFactory =
                new ExponentialDelayRestartBackoffTimeStrategyFactory(
                        clock,
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThresholdMS,
                        jitterFactor,
                        maxAttempts);

        // Expected output values extracted as variables for clarity
        long delay = maxBackoffMS + 1;

        assertCorrectRandomRangeWithFailureCount(
                restartStrategyFactory, clock, delay, 2, 3L, 4L, 5L);

        assertCorrectRandomRangeWithFailureCount(
                restartStrategyFactory, clock, delay, 3, 6L, 7L);

        assertCorrectRandomRangeWithFailureCount(
                restartStrategyFactory, clock, delay, 4, 7L);
    }

    @Test
    void testJitterNoHigherThanMax() throws Exception {
        double jitterFactor = 1;
        long maxBackoffMS = 7L;
        double backoffMultiplier = 2.0;
        long resetBackoffThresholdMS = Integer.MAX_VALUE;
        int maxAttempts = Integer.MAX_VALUE;

        ManualClock clock = new ManualClock();
        final ExponentialDelayRestartBackoffTimeStrategyFactory restartStrategyFactory =
                new ExponentialDelayRestartBackoffTimeStrategyFactory(
                        clock,
                        1L,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThresholdMS,
                        jitterFactor,
                        maxAttempts);

        long delay = maxBackoffMS + 1;

        assertCorrectRandomRangeWithFailureCount(
                restartStrategyFactory, clock, delay, 1, 1L, 2L);

        assertCorrectRandomRangeWithFailureCount(
                restartStrategyFactory, clock, delay, 2, 1L, 2L, 3L, 4L);

        assertCorrectRandomRangeWithFailureCount(
                restartStrategyFactory, clock, delay, 3, 1L, 2L, 3L, 4L, 5L, 6L, 7L);
    }

    private void assertCorrectRandomRangeWithFailureCount(
            ExponentialDelayRestartBackoffTimeStrategyFactory factory,
            ManualClock clock,
            long advanceMsEachFailure,
            int failureCount,
            Long... expectedNumbers)
            throws Exception {
        assertCorrectRandomRange(
                () -> {
                    RestartBackoffTimeStrategy restartStrategy = factory.create();
                    for (int i = 0; i < failureCount; i++) {
                        clock.advanceTime(Duration.ofMillis(advanceMsEachFailure));
                        restartStrategy.notifyFailure(failure);
                    }
                    return restartStrategy.getBackoffTime();
                },
                expectedNumbers);
    }

    @Test
    void testMultipleSettings() {
        ManualClock clock = new ManualClock();
        final long initialBackoffMS = 1L;
        final long maxBackoffMS = 9L;
        double backoffMultiplier = 2.0;
        final long resetBackoffThresholdMS = 80L;
        double jitterFactor = 0.25;
        int maxAttempts = Integer.MAX_VALUE;

        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        clock,
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThresholdMS,
                        jitterFactor,
                        maxAttempts);

        // ensure initial data
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.canRestart()).isTrue();
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(initialBackoffMS);

        // ensure backoff time is initial after the first failure
        clock.advanceTime(resetBackoffThresholdMS + 1, TimeUnit.MILLISECONDS);
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.canRestart()).isTrue();
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(initialBackoffMS);

        // ensure backoff increases until threshold is reached
        clock.advanceTime(4, TimeUnit.MILLISECONDS);
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.canRestart()).isTrue();
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(2L);

        // ensure backoff is reset after threshold is reached
        clock.advanceTime(resetBackoffThresholdMS + 9 + 1, TimeUnit.MILLISECONDS);
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.canRestart()).isTrue();
        assertThat(restartStrategy.getBackoffTime()).isOne();
        clock.advanceTime(Duration.ofMillis(maxBackoffMS + 1));

        // ensure backoff still increases
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.canRestart()).isTrue();
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(2L);
    }

    @Test
    void testMergeMultipleExceptionsIntoOneAttempt() {
        ManualClock clock = new ManualClock();
        long initialBackoffMS = 2L;
        double backoffMultiplier = 2.0d;
        final long maxBackoffMS = 6L;
        final long resetBackoffThresholdMS = 80L;
        final int maxAttempts = 3;

        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        clock,
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThresholdMS,
                        0.d,
                        maxAttempts);

        // All exceptions merged into one attempt if the time is same.
        long currentBackOffMs = initialBackoffMS;
        checkMultipleExceptionsAreMerged(clock, currentBackOffMs, restartStrategy);

        // After advance time it's a new round, so new exception will be a new attempt.
        clock.advanceTime(1, TimeUnit.MILLISECONDS);
        currentBackOffMs *= backoffMultiplier;
        checkMultipleExceptionsAreMerged(clock, currentBackOffMs, restartStrategy);

        // After advance time it's a new round, so new exception will be a new attempt.
        clock.advanceTime(1, TimeUnit.MILLISECONDS);
        currentBackOffMs = maxBackoffMS;
        checkMultipleExceptionsAreMerged(clock, currentBackOffMs, restartStrategy);

        // After advance time it's a new round, and it reaches the maxAttempts.
        clock.advanceTime(1, TimeUnit.MILLISECONDS);
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.canRestart()).isFalse();
    }

    @Test
    void testMergingExceptionsWorksWithResetting() {
        ManualClock clock = new ManualClock();
        long initialBackoffMS = 2L;
        double backoffMultiplier = 2.0d;
        final long maxBackoffMS = 6L;
        final long resetBackoffThresholdMS = 80L;
        final int maxAttempts = 3;

        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        clock,
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThresholdMS,
                        0.d,
                        maxAttempts);

        // Test the merging logic works well after a series of resetting.
        for (int i = 0; i < 10; i++) {
            // All exceptions merged into one attempt if the time is same.
            long currentBackOffMs = initialBackoffMS;
            checkMultipleExceptionsAreMerged(clock, currentBackOffMs, restartStrategy);

            // After advance time it's a new round, so new exception will be a new attempt.
            clock.advanceTime(1, TimeUnit.MILLISECONDS);
            currentBackOffMs *= backoffMultiplier;
            checkMultipleExceptionsAreMerged(clock, currentBackOffMs, restartStrategy);

            // After advance time it's a new round, so new exception will be a new attempt.
            clock.advanceTime(1, TimeUnit.MILLISECONDS);
            currentBackOffMs = maxBackoffMS;
            checkMultipleExceptionsAreMerged(clock, currentBackOffMs, restartStrategy);

            // After resetBackoffThresholdMS, the restartStrategy should be reset.
            clock.advanceTime(resetBackoffThresholdMS, TimeUnit.MILLISECONDS);
        }
    }

    private void checkMultipleExceptionsAreMerged(
            ManualClock clock,
            long expectedBackoffMS,
            ExponentialDelayRestartBackoffTimeStrategy restartStrategy) {
        for (int advanceMs = 0; advanceMs < expectedBackoffMS; advanceMs++) {
            for (int i = 0; i < 10; i++) {
                restartStrategy.notifyFailure(failure);
                assertThat(restartStrategy.canRestart()).isTrue();
                assertThat(restartStrategy.getBackoffTime())
                        .isEqualTo(expectedBackoffMS - advanceMs);
            }
            clock.advanceTime(1, TimeUnit.MILLISECONDS);
        }
    }

    private void assertCorrectRandomRange(Callable<Long> numberGenerator, Long... expectedNumbers)
            throws Exception {
        Set<Long> generatedNumbers = new HashSet<>();
        for (int i = 0; i < 1000; i++) {
            long generatedNumber = numberGenerator.call();
            generatedNumbers.add(generatedNumber);
        }
        assertThat(generatedNumbers).isEqualTo(new HashSet<>(Arrays.asList(expectedNumbers)));
    }
}
```

**Summary:**
- Frequently repeated values are now assigned to local variables at the beginning of each test.
- Construction of the strategy/factory now uses local variables for all parameters.
- This greatly improves readability, makes test maintenance easier, and avoids errors from literal repetition.

If you need tighter refactoring (e.g., common constants as static fields), specify your requirements further!



FINISHED REFACTORING 0



There **are several opportunities** for Extract Variable refactoring in this code. Specifically, **multiple test methods repeatedly use commonly constructed objects** (e.g., `ManualClock`, `Exception failure`), and also commonly used constant values within the same method. Furthermore, some of the parameters to `ExponentialDelayRestartBackoffTimeStrategy` constructors in the tests are repeated within the same method and can be extracted for clarity and maintainability.

In the refactoring below, I've **extracted variables for repeated expressions/values** within the methods themselves (where it clarifies intent or reduces duplication), while leaving method-scope variables local (not using fields across test cases unless necessary, to preserve test isolation). I've also slightly reordered some local variable declarations for better readability.

Hereâ€™s the full refactored code:

```java
package org.apache.flink.runtime.executiongraph.failover;

import org.apache.flink.runtime.executiongraph.failover.ExponentialDelayRestartBackoffTimeStrategy.ExponentialDelayRestartBackoffTimeStrategyFactory;
import org.apache.flink.util.clock.ManualClock;

import org.junit.jupiter.api.Test;

import java.time.Duration;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.TimeUnit;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

/** Unit tests for {@link ExponentialDelayRestartBackoffTimeStrategy}. */
class ExponentialDelayRestartBackoffTimeStrategyTest {

    private final Exception failure = new Exception();

    @Test
    void testMaxAttempts() {
        int maxAttempts = 13;
        long maxBackoffMS = 3L;
        ManualClock clock = new ManualClock();
        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        clock, 1L, maxBackoffMS, 1.2, 10L, 0.25, maxAttempts);

        for (int i = 0; i <= maxAttempts; i++) {
            assertThat(restartStrategy.canRestart()).isTrue();
            restartStrategy.notifyFailure(failure);
            clock.advanceTime(Duration.ofMillis(maxBackoffMS + 1));
        }
        assertThat(restartStrategy.canRestart()).isFalse();
    }

    @Test
    void testNotCallNotifyFailure() {
        long initialBackoffMS = 42L;
        ManualClock clock = new ManualClock();
        long maxBackoffMS = 45L;
        double backoffMultiplier = 2.0;
        long resetBackoffThresholdMS = 8L;
        double jitterFactor = 0;
        int maxAttempts = 10;
        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        clock, initialBackoffMS, maxBackoffMS, backoffMultiplier, resetBackoffThresholdMS, jitterFactor, maxAttempts);

        assertThatThrownBy(restartStrategy::getBackoffTime)
                .isInstanceOf(IllegalStateException.class)
                .hasMessage("Please call notifyFailure first.");
    }

    @Test
    void testInitialBackoff() {
        long initialBackoffMS = 42L;
        ManualClock clock = new ManualClock();
        long maxBackoffMS = 45L;
        double backoffMultiplier = 2.0;
        long resetBackoffThresholdMS = 8L;
        double jitterFactor = 0;
        int maxAttempts = Integer.MAX_VALUE;
        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        clock, initialBackoffMS, maxBackoffMS, backoffMultiplier, resetBackoffThresholdMS, jitterFactor, maxAttempts);

        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(initialBackoffMS);
    }

    @Test
    void testMaxBackoff() {
        final long maxBackoffMS = 6L;
        ManualClock clock = new ManualClock();
        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        clock, 1L, maxBackoffMS, 2.0, 8L, 0.25, Integer.MAX_VALUE);

        for (int i = 0; i < 10; i++) {
            restartStrategy.notifyFailure(failure);
            assertThat(restartStrategy.getBackoffTime()).isLessThanOrEqualTo(maxBackoffMS);
        }
    }

    @Test
    void testResetBackoff() {
        final long initialBackoffMS = 1L;
        final long resetBackoffThresholdMS = 8L;
        final long maxBackoffMS = 5L;
        final double backoffMultiplier = 2.0;
        final double jitterFactor = 0.25;
        final int maxAttempts = Integer.MAX_VALUE;
        final ManualClock clock = new ManualClock();

        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        clock,
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThresholdMS,
                        jitterFactor,
                        maxAttempts);

        restartStrategy.notifyFailure(failure);

        clock.advanceTime(
                resetBackoffThresholdMS + restartStrategy.getBackoffTime() - 1,
                TimeUnit.MILLISECONDS);
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.getBackoffTime())
                .as("Backoff should be increased")
                .isEqualTo(2L);

        clock.advanceTime(
                resetBackoffThresholdMS + restartStrategy.getBackoffTime(), TimeUnit.MILLISECONDS);
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.getBackoffTime())
                .as("Backoff should be reset")
                .isEqualTo(initialBackoffMS);
    }

    @Test
    void testBackoffMultiplier() {
        long initialBackoffMS = 4L;
        double jitterFactor = 0;
        double backoffMultiplier = 2.3;
        long maxBackoffMS = 300L;

        ManualClock clock = new ManualClock();
        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        clock,
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        Integer.MAX_VALUE,
                        jitterFactor,
                        10);

        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(4L); // 4
        clock.advanceTime(Duration.ofMillis(maxBackoffMS + 1));

        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(9L); // 4 * 2.3
        clock.advanceTime(Duration.ofMillis(maxBackoffMS + 1));

        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(21L); // 4 * 2.3 * 2.3
        clock.advanceTime(Duration.ofMillis(maxBackoffMS + 1));
    }

    @Test
    void testJitter() throws Exception {
        final long initialBackoffMS = 2L;
        final long maxBackoffMS = 7L;
        final double backoffMultiplier = 2.0;
        final int resetBackoffThreshold = Integer.MAX_VALUE;
        final double jitterFactor = 0.25;
        final int maxAttempts = Integer.MAX_VALUE;

        ManualClock clock = new ManualClock();
        final ExponentialDelayRestartBackoffTimeStrategyFactory restartStrategyFactory =
                new ExponentialDelayRestartBackoffTimeStrategyFactory(
                        clock,
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThreshold,
                        jitterFactor,
                        maxAttempts);

        assertCorrectRandomRangeWithFailureCount(
                restartStrategyFactory, clock, maxBackoffMS + 1, 2, 3L, 4L, 5L);

        assertCorrectRandomRangeWithFailureCount(
                restartStrategyFactory, clock, maxBackoffMS + 1, 3, 6L, 7L);

        assertCorrectRandomRangeWithFailureCount(
                restartStrategyFactory, clock, maxBackoffMS + 1, 4, 7L);
    }

    @Test
    void testJitterNoHigherThanMax() throws Exception {
        double jitterFactor = 1;
        long maxBackoffMS = 7L;
        ManualClock clock = new ManualClock();
        final ExponentialDelayRestartBackoffTimeStrategyFactory restartStrategyFactory =
                new ExponentialDelayRestartBackoffTimeStrategyFactory(
                        clock,
                        1L,
                        maxBackoffMS,
                        2.0,
                        Integer.MAX_VALUE,
                        jitterFactor,
                        Integer.MAX_VALUE);

        assertCorrectRandomRangeWithFailureCount(
                restartStrategyFactory, clock, maxBackoffMS + 1, 1, 1L, 2L);

        assertCorrectRandomRangeWithFailureCount(
                restartStrategyFactory, clock, maxBackoffMS + 1, 2, 1L, 2L, 3L, 4L);

        assertCorrectRandomRangeWithFailureCount(
                restartStrategyFactory, clock, maxBackoffMS + 1, 3, 1L, 2L, 3L, 4L, 5L, 6L, 7L);
    }

    private void assertCorrectRandomRangeWithFailureCount(
            ExponentialDelayRestartBackoffTimeStrategyFactory factory,
            ManualClock clock,
            long advanceMsEachFailure,
            int failureCount,
            Long... expectedNumbers)
            throws Exception {
        assertCorrectRandomRange(
                () -> {
                    RestartBackoffTimeStrategy restartStrategy = factory.create();
                    for (int i = 0; i < failureCount; i++) {
                        clock.advanceTime(Duration.ofMillis(advanceMsEachFailure));
                        restartStrategy.notifyFailure(failure);
                    }
                    return restartStrategy.getBackoffTime();
                },
                expectedNumbers);
    }

    @Test
    void testMultipleSettings() {
        final ManualClock clock = new ManualClock();
        final long initialBackoffMS = 1L;
        final long maxBackoffMS = 9L;
        final double backoffMultiplier = 2.0;
        final long resetBackoffThresholdMS = 80L;
        final double jitterFactor = 0.25;
        final int maxAttempts = Integer.MAX_VALUE;

        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        clock,
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThresholdMS,
                        jitterFactor,
                        maxAttempts);

        // ensure initial data
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.canRestart()).isTrue();
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(initialBackoffMS);

        // ensure backoff time is initial after the first failure
        clock.advanceTime(resetBackoffThresholdMS + 1, TimeUnit.MILLISECONDS);
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.canRestart()).isTrue();
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(initialBackoffMS);

        // ensure backoff increases until threshold is reached
        clock.advanceTime(4, TimeUnit.MILLISECONDS);
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.canRestart()).isTrue();
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(2L);

        // ensure backoff is reset after threshold is reached
        clock.advanceTime(resetBackoffThresholdMS + 9 + 1, TimeUnit.MILLISECONDS);
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.canRestart()).isTrue();
        assertThat(restartStrategy.getBackoffTime()).isOne();
        clock.advanceTime(Duration.ofMillis(maxBackoffMS + 1));

        // ensure backoff still increases
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.canRestart()).isTrue();
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(2L);
    }

    @Test
    void testMergeMultipleExceptionsIntoOneAttempt() {
        ManualClock clock = new ManualClock();
        long initialBackoffMS = 2L;
        double backoffMultiplier = 2.0d;
        final long maxBackoffMS = 6L;
        final long resetBackoffThresholdMS = 80L;
        final int maxAttempts = 3;

        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        clock,
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThresholdMS,
                        0.d,
                        maxAttempts);

        // All exceptions merged into one attempt if the time is same.
        long currentBackOffMs = initialBackoffMS;
        checkMultipleExceptionsAreMerged(clock, currentBackOffMs, restartStrategy);

        // After advance time it's a new round, so new exception will be a new attempt.
        clock.advanceTime(1, TimeUnit.MILLISECONDS);
        currentBackOffMs *= backoffMultiplier;
        checkMultipleExceptionsAreMerged(clock, currentBackOffMs, restartStrategy);

        // After advance time it's a new round, so new exception will be a new attempt.
        clock.advanceTime(1, TimeUnit.MILLISECONDS);
        currentBackOffMs = maxBackoffMS;
        checkMultipleExceptionsAreMerged(clock, currentBackOffMs, restartStrategy);

        // After advance time it's a new round, and it reaches the maxAttempts.
        clock.advanceTime(1, TimeUnit.MILLISECONDS);
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.canRestart()).isFalse();
    }

    @Test
    void testMergingExceptionsWorksWithResetting() {
        ManualClock clock = new ManualClock();
        long initialBackoffMS = 2L;
        double backoffMultiplier = 2.0d;
        final long maxBackoffMS = 6L;
        final long resetBackoffThresholdMS = 80L;
        final int maxAttempts = 3;

        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        clock,
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThresholdMS,
                        0.d,
                        maxAttempts);

        // Test the merging logic works well after a series of resetting.
        for (int i = 0; i < 10; i++) {
            // All exceptions merged into one attempt if the time is same.
            long currentBackOffMs = initialBackoffMS;
            checkMultipleExceptionsAreMerged(clock, currentBackOffMs, restartStrategy);

            // After advance time it's a new round, so new exception will be a new attempt.
            clock.advanceTime(1, TimeUnit.MILLISECONDS);
            currentBackOffMs *= backoffMultiplier;
            checkMultipleExceptionsAreMerged(clock, currentBackOffMs, restartStrategy);

            // After advance time it's a new round, so new exception will be a new attempt.
            clock.advanceTime(1, TimeUnit.MILLISECONDS);
            currentBackOffMs = maxBackoffMS;
            checkMultipleExceptionsAreMerged(clock, currentBackOffMs, restartStrategy);

            // After resetBackoffThresholdMS, the restartStrategy should be reset.
            clock.advanceTime(resetBackoffThresholdMS, TimeUnit.MILLISECONDS);
        }
    }

    private void checkMultipleExceptionsAreMerged(
            ManualClock clock,
            long expectedBackoffMS,
            ExponentialDelayRestartBackoffTimeStrategy restartStrategy) {
        for (int advanceMs = 0; advanceMs < expectedBackoffMS; advanceMs++) {
            for (int i = 0; i < 10; i++) {
                restartStrategy.notifyFailure(failure);
                assertThat(restartStrategy.canRestart()).isTrue();
                assertThat(restartStrategy.getBackoffTime())
                        .isEqualTo(expectedBackoffMS - advanceMs);
            }
            clock.advanceTime(1, TimeUnit.MILLISECONDS);
        }
    }

    private void assertCorrectRandomRange(Callable<Long> numberGenerator, Long... expectedNumbers)
            throws Exception {
        Set<Long> generatedNumbers = new HashSet<>();
        for (int i = 0; i < 1000; i++) {
            long generatedNumber = numberGenerator.call();
            generatedNumbers.add(generatedNumber);
        }
        assertThat(generatedNumbers).isEqualTo(new HashSet<>(Arrays.asList(expectedNumbers)));
    }
}
```

**Summary of refactorings:**

- Extracted constants for repeated parameters/values within each test method.
- Extracted `ManualClock` creation to a variable where it is referenced multiple times in a method.
- Retained the structure and clarity per individual test.
- Improved maintainability and readability by removing repeated "magic numbers" and improving naming.
- Test field `failure` was already extracted at the class level.

If more aggressive refactoring (e.g., creating helper methods for repeated strategy instantiations) is desired, let me know. For now, the code is clearer, more maintainable, and less error-prone.
