29-04-2025, 21:31

### Refactoring Opportunities

Upon reviewing your code, there **are** opportunities for **extract variable** refactoring to improve readability and reusability, particularly for:

- Repeated calls with the *same constructor argument lists*.
- Magic numbers or arguments occurring frequently in several places within a test.

However, since these are *unit tests*, the methods are independent and readability is also a concern, so care must be taken not to overdo extraction: over-refactoring of test code can reduce readability. Below is a refactored version focusing only on the most obvious (not every possible) opportunities.

#### Opportunities Applied

- In every test that creates an `ExponentialDelayRestartBackoffTimeStrategy` (or its Factory) with several constant parameters, **extract variables for parameters that are repeated** or complex.
- Avoid magic numbers by assigning them to descriptively-named variables.
- Where there's a repeated pattern for clocks or strategies, extract them as local variables.
- No refactoring is made to methods (like `assertCorrectRandomRangeWithFailureCount`, `checkMultipleExceptionsAreMerged`, etc.) as they already provide abstraction.

---

Here is the **refactored code** (comments mark changes):

```java
package org.apache.flink.runtime.executiongraph.failover;

import org.apache.flink.runtime.executiongraph.failover.ExponentialDelayRestartBackoffTimeStrategy.ExponentialDelayRestartBackoffTimeStrategyFactory;
import org.apache.flink.util.clock.ManualClock;

import org.junit.jupiter.api.Test;

import java.time.Duration;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.TimeUnit;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

/** Unit tests for {@link ExponentialDelayRestartBackoffTimeStrategy}. */
class ExponentialDelayRestartBackoffTimeStrategyTest {

    private final Exception failure = new Exception();

    @Test
    void testMaxAttempts() {
        int maxAttempts = 13;
        long maxBackoffMS = 3L;
        long initialBackoffMS = 1L;
        double backoffMultiplier = 1.2;
        long resetBackoffThresholdMS = 10L;
        double jitterFactor = 0.25;

        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        new ManualClock(), initialBackoffMS, maxBackoffMS, backoffMultiplier, resetBackoffThresholdMS, jitterFactor, maxAttempts);

        for (int i = 0; i <= maxAttempts; i++) {
            assertThat(restartStrategy.canRestart()).isTrue();
            restartStrategy.notifyFailure(failure);
            new ManualClock().advanceTime(Duration.ofMillis(maxBackoffMS + 1));
        }
        assertThat(restartStrategy.canRestart()).isFalse();
    }

    @Test
    void testNotCallNotifyFailure() {
        long initialBackoffMS = 42L;
        long maxBackoffMS = 45L;
        double backoffMultiplier = 2.0;
        long resetBackoffThresholdMS = 8L;
        double jitterFactor = 0;
        int maxAttempts = 10;

        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        new ManualClock(), initialBackoffMS, maxBackoffMS, backoffMultiplier, resetBackoffThresholdMS, jitterFactor, maxAttempts);

        assertThatThrownBy(restartStrategy::getBackoffTime)
                .isInstanceOf(IllegalStateException.class)
                .hasMessage("Please call notifyFailure first.");
    }

    @Test
    void testInitialBackoff() {
        long initialBackoffMS = 42L;
        long maxBackoffMS = 45L;
        double backoffMultiplier = 2.0;
        long resetBackoffThresholdMS = 8L;
        double jitterFactor = 0;
        int maxAttempts = Integer.MAX_VALUE;

        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        new ManualClock(), initialBackoffMS, maxBackoffMS, backoffMultiplier, resetBackoffThresholdMS, jitterFactor, maxAttempts);

        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(initialBackoffMS);
    }

    @Test
    void testMaxBackoff() {
        final long maxBackoffMS = 6L;
        long initialBackoffMS = 1L;
        double backoffMultiplier = 2.0;
        long resetBackoffThresholdMS = 8L;
        double jitterFactor = 0.25;
        int maxAttempts = Integer.MAX_VALUE;

        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        new ManualClock(), initialBackoffMS, maxBackoffMS, backoffMultiplier, resetBackoffThresholdMS, jitterFactor, maxAttempts);

        for (int i = 0; i < 10; i++) {
            restartStrategy.notifyFailure(failure);
            assertThat(restartStrategy.getBackoffTime()).isLessThanOrEqualTo(maxBackoffMS);
        }
    }

    @Test
    void testResetBackoff() {
        final long initialBackoffMS = 1L;
        final long maxBackoffMS = 5L;
        final double backoffMultiplier = 2.0;
        final long resetBackoffThresholdMS = 8L;
        final double jitterFactor = 0.25;
        final int maxAttempts = Integer.MAX_VALUE;
        final ManualClock clock = new ManualClock();

        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        clock,
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThresholdMS,
                        jitterFactor,
                        maxAttempts);

        restartStrategy.notifyFailure(failure);

        clock.advanceTime(
                resetBackoffThresholdMS + restartStrategy.getBackoffTime() - 1,
                TimeUnit.MILLISECONDS);
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.getBackoffTime())
                .as("Backoff should be increased")
                .isEqualTo(2L);

        clock.advanceTime(
                resetBackoffThresholdMS + restartStrategy.getBackoffTime(), TimeUnit.MILLISECONDS);
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.getBackoffTime())
                .as("Backoff should be reset")
                .isEqualTo(initialBackoffMS);
    }

    @Test
    void testBackoffMultiplier() {
        long initialBackoffMS = 4L;
        double jitterFactor = 0;
        double backoffMultiplier = 2.3;
        long maxBackoffMS = 300L;
        long resetBackoffThresholdMS = Integer.MAX_VALUE;
        int maxAttempts = 10;

        ManualClock clock = new ManualClock();
        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        clock,
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThresholdMS,
                        jitterFactor,
                        maxAttempts);

        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(4L); // 4
        clock.advanceTime(Duration.ofMillis(maxBackoffMS + 1));

        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(9L); // 4 * 2.3
        clock.advanceTime(Duration.ofMillis(maxBackoffMS + 1));

        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(21L); // 4 * 2.3 * 2.3
        clock.advanceTime(Duration.ofMillis(maxBackoffMS + 1));
    }

    @Test
    void testJitter() throws Exception {
        final long initialBackoffMS = 2L;
        final long maxBackoffMS = 7L;
        final double backoffMultiplier = 2.0;
        final long resetBackoffThresholdMS = Integer.MAX_VALUE;
        final double jitterFactor = 0.25;
        final int maxAttempts = Integer.MAX_VALUE;

        ManualClock clock = new ManualClock();
        final ExponentialDelayRestartBackoffTimeStrategyFactory restartStrategyFactory =
                new ExponentialDelayRestartBackoffTimeStrategyFactory(
                        clock,
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThresholdMS,
                        jitterFactor,
                        maxAttempts);

        // Unchanged: method calls for test
        assertCorrectRandomRangeWithFailureCount(
                restartStrategyFactory, clock, maxBackoffMS + 1, 2, 3L, 4L, 5L);

        assertCorrectRandomRangeWithFailureCount(
                restartStrategyFactory, clock, maxBackoffMS + 1, 3, 6L, 7L);

        assertCorrectRandomRangeWithFailureCount(
                restartStrategyFactory, clock, maxBackoffMS + 1, 4, 7L);
    }

    @Test
    void testJitterNoHigherThanMax() throws Exception {
        double jitterFactor = 1;
        long initialBackoffMS = 1L;
        long maxBackoffMS = 7L;
        double backoffMultiplier = 2.0;
        long resetBackoffThresholdMS = Integer.MAX_VALUE;
        int maxAttempts = Integer.MAX_VALUE;

        ManualClock clock = new ManualClock();
        final ExponentialDelayRestartBackoffTimeStrategyFactory restartStrategyFactory =
                new ExponentialDelayRestartBackoffTimeStrategyFactory(
                        clock,
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThresholdMS,
                        jitterFactor,
                        maxAttempts);

        assertCorrectRandomRangeWithFailureCount(
                restartStrategyFactory, clock, maxBackoffMS + 1, 1, 1L, 2L);

        assertCorrectRandomRangeWithFailureCount(
                restartStrategyFactory, clock, maxBackoffMS + 1, 2, 1L, 2L, 3L, 4L);

        assertCorrectRandomRangeWithFailureCount(
                restartStrategyFactory, clock, maxBackoffMS + 1, 3, 1L, 2L, 3L, 4L, 5L, 6L, 7L);
    }

    private void assertCorrectRandomRangeWithFailureCount(
            ExponentialDelayRestartBackoffTimeStrategyFactory factory,
            ManualClock clock,
            long advanceMsEachFailure,
            int failureCount,
            Long... expectedNumbers)
            throws Exception {
        assertCorrectRandomRange(
                () -> {
                    RestartBackoffTimeStrategy restartStrategy = factory.create();
                    for (int i = 0; i < failureCount; i++) {
                        clock.advanceTime(Duration.ofMillis(advanceMsEachFailure));
                        restartStrategy.notifyFailure(failure);
                    }
                    return restartStrategy.getBackoffTime();
                },
                expectedNumbers);
    }

    @Test
    void testMultipleSettings() {
        ManualClock clock = new ManualClock();
        final long initialBackoffMS = 1L;
        final long maxBackoffMS = 9L;
        double backoffMultiplier = 2.0;
        final long resetBackoffThresholdMS = 80L;
        double jitterFactor = 0.25;
        int maxAttempts = Integer.MAX_VALUE;

        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        clock,
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThresholdMS,
                        jitterFactor,
                        maxAttempts);

        // ensure initial data
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.canRestart()).isTrue();
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(initialBackoffMS);

        // ensure backoff time is initial after the first failure
        clock.advanceTime(resetBackoffThresholdMS + 1, TimeUnit.MILLISECONDS);
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.canRestart()).isTrue();
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(initialBackoffMS);

        // ensure backoff increases until threshold is reached
        clock.advanceTime(4, TimeUnit.MILLISECONDS);
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.canRestart()).isTrue();
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(2L);

        // ensure backoff is reset after threshold is reached
        clock.advanceTime(resetBackoffThresholdMS + 9 + 1, TimeUnit.MILLISECONDS);
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.canRestart()).isTrue();
        assertThat(restartStrategy.getBackoffTime()).isOne();
        clock.advanceTime(Duration.ofMillis(maxBackoffMS + 1));

        // ensure backoff still increases
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.canRestart()).isTrue();
        assertThat(restartStrategy.getBackoffTime()).isEqualTo(2L);
    }

    @Test
    void testMergeMultipleExceptionsIntoOneAttempt() {
        ManualClock clock = new ManualClock();
        long initialBackoffMS = 2L;
        double backoffMultiplier = 2.0d;
        final long maxBackoffMS = 6L;
        final long resetBackoffThresholdMS = 80L;
        final double jitterFactor = 0.d;
        final int maxAttempts = 3;

        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        clock,
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThresholdMS,
                        jitterFactor,
                        maxAttempts);

        // All exceptions merged into one attempt if the time is same.
        long currentBackOffMs = initialBackoffMS;
        checkMultipleExceptionsAreMerged(clock, currentBackOffMs, restartStrategy);

        // After advance time it's a new round, so new exception will be a new attempt.
        clock.advanceTime(1, TimeUnit.MILLISECONDS);
        currentBackOffMs *= backoffMultiplier;
        checkMultipleExceptionsAreMerged(clock, currentBackOffMs, restartStrategy);

        // After advance time it's a new round, so new exception will be a new attempt.
        clock.advanceTime(1, TimeUnit.MILLISECONDS);
        currentBackOffMs = maxBackoffMS;
        checkMultipleExceptionsAreMerged(clock, currentBackOffMs, restartStrategy);

        // After advance time it's a new round, and it reaches the maxAttempts.
        clock.advanceTime(1, TimeUnit.MILLISECONDS);
        restartStrategy.notifyFailure(failure);
        assertThat(restartStrategy.canRestart()).isFalse();
    }

    @Test
    void testMergingExceptionsWorksWithResetting() {
        ManualClock clock = new ManualClock();
        long initialBackoffMS = 2L;
        double backoffMultiplier = 2.0d;
        final long maxBackoffMS = 6L;
        final long resetBackoffThresholdMS = 80L;
        final double jitterFactor = 0.d;
        final int maxAttempts = 3;

        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =
                new ExponentialDelayRestartBackoffTimeStrategy(
                        clock,
                        initialBackoffMS,
                        maxBackoffMS,
                        backoffMultiplier,
                        resetBackoffThresholdMS,
                        jitterFactor,
                        maxAttempts);

        // Test the merging logic works well after a series of resetting.
        for (int i = 0; i < 10; i++) {
            // All exceptions merged into one attempt if the time is same.
            long currentBackOffMs = initialBackoffMS;
            checkMultipleExceptionsAreMerged(clock, currentBackOffMs, restartStrategy);

            // After advance time it's a new round, so new exception will be a new attempt.
            clock.advanceTime(1, TimeUnit.MILLISECONDS);
            currentBackOffMs *= backoffMultiplier;
            checkMultipleExceptionsAreMerged(clock, currentBackOffMs, restartStrategy);

            // After advance time it's a new round, so new exception will be a new attempt.
            clock.advanceTime(1, TimeUnit.MILLISECONDS);
            currentBackOffMs = maxBackoffMS;
            checkMultipleExceptionsAreMerged(clock, currentBackOffMs, restartStrategy);

            // After resetBackoffThresholdMS, the restartStrategy should be reset.
            clock.advanceTime(resetBackoffThresholdMS, TimeUnit.MILLISECONDS);
        }
    }

    private void checkMultipleExceptionsAreMerged(
            ManualClock clock,
            long expectedBackoffMS,
            ExponentialDelayRestartBackoffTimeStrategy restartStrategy) {
        for (int advanceMs = 0; advanceMs < expectedBackoffMS; advanceMs++) {
            for (int i = 0; i < 10; i++) {
                restartStrategy.notifyFailure(failure);
                assertThat(restartStrategy.canRestart()).isTrue();
                assertThat(restartStrategy.getBackoffTime())
                        .isEqualTo(expectedBackoffMS - advanceMs);
            }
            clock.advanceTime(1, TimeUnit.MILLISECONDS);
        }
    }

    private void assertCorrectRandomRange(Callable<Long> numberGenerator, Long... expectedNumbers)
            throws Exception {
        Set<Long> generatedNumbers = new HashSet<>();
        for (int i = 0; i < 1000; i++) {
            long generatedNumber = numberGenerator.call();
            generatedNumbers.add(generatedNumber);
        }
        assertThat(generatedNumbers).isEqualTo(new HashSet<>(Arrays.asList(expectedNumbers)));
    }
}
```

---

**Summary of changes**:

- Introduced local variables for repeated parameters and magic numbers in most test methods, following extract variable refactoring.
- No changes to method signatures or test structure, only improved readability and reduced risk of errors when arguments need to change.

Let me know if you want more aggressive consolidation into helper methods or fields!
