02-05-2025, 08:41

There **are** rename attribute refactoring opportunities in this code. The class currently has several attribute (field) names that are a bit ambiguous or fail to adhere to common Java naming conventions for clarity and intent. I’ll point out and refactor key attribute opportunities:

### Summary of Refactoring Opportunities

#### 1. **customImportOrderRules (static) & customOrderRules (instance)**
- **Reason**: Their names are too similar, which may cause confusion. `customImportOrderRules` is only the raw input from the user, while `customOrderRules` is the processed, parsed set.
- **Suggestion**:
  - `customImportOrderRules` → `customImportOrderRulesInput`
  - `customOrderRules` → `parsedImportOrderRules`

#### 2. **importToGroupList**
- **Reason**: This name is non-idiomatic and unclear. It's a `List<ImportDetails>` holding processed imports.
- **Suggestion**: `importToGroupList` → `imports`

#### 3. **samePackageDomainsRegExp**
- **Reason**: This is a String, not a RegExp or Pattern. The name is misleading; it's more of a "matching domain string" than a RegExp.
- **Suggestion**: `samePackageDomainsRegExp` → `samePackageDomainString`

#### 4. **standardPackageRegExp, thirdPartyPackageRegExp, specialImportsRegExp**
- **Reason**: "RegExp" should be "Pattern" for idiomatic Java, matching the type.
- **Suggestion**:
  - `standardPackageRegExp` → `standardPackagePattern`
  - `thirdPartyPackageRegExp` → `thirdPartyPackagePattern`
  - `specialImportsRegExp` → `specialImportsPattern`

#### 5. **separateLineBetweenGroups**
- **Reason**: Should be a verb phrase for a boolean.
- **Suggestion**: `separateLineBetweenGroups` → `isSeparateLineBetweenGroups`

#### 6. **sortImportsInGroupAlphabetically**
- **Reason**: For boolean, "is" or "should" prefix.
- **Suggestion**: `sortImportsInGroupAlphabetically` → `shouldSortImportsInGroupAlphabetically`

#### 7. **samePackageMatchingDepth**
- **Reason**: Acceptable, but maybe `samePackageDomainDepth` is clearer.
- **Suggestion**: `samePackageMatchingDepth` → `samePackageDomainDepth`

Other names are clear or follow a known pattern.

---

## **Refactored Class**

```java
package com.puppycrawl.tools.checkstyle.checks.imports;

import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.puppycrawl.tools.checkstyle.FileStatefulCheck;
import com.puppycrawl.tools.checkstyle.api.AbstractCheck;
import com.puppycrawl.tools.checkstyle.api.DetailAST;
import com.puppycrawl.tools.checkstyle.api.FullIdent;
import com.puppycrawl.tools.checkstyle.api.TokenTypes;
import com.puppycrawl.tools.checkstyle.utils.CommonUtil;

@FileStatefulCheck
public class CustomImportOrderCheck extends AbstractCheck {

    public static final String MSG_LINE_SEPARATOR = "custom.import.order.line.separator";
    public static final String MSG_SEPARATED_IN_GROUP = "custom.import.order.separated.internally";
    public static final String MSG_LEX = "custom.import.order.lex";
    public static final String MSG_NONGROUP_IMPORT = "custom.import.order.nonGroup.import";
    public static final String MSG_NONGROUP_EXPECTED = "custom.import.order.nonGroup.expected";
    public static final String MSG_ORDER = "custom.import.order";

    public static final String STATIC_RULE_GROUP = "STATIC";
    public static final String SAME_PACKAGE_RULE_GROUP = "SAME_PACKAGE";
    public static final String THIRD_PARTY_PACKAGE_RULE_GROUP = "THIRD_PARTY_PACKAGE";
    public static final String STANDARD_JAVA_PACKAGE_RULE_GROUP = "STANDARD_JAVA_PACKAGE";
    public static final String SPECIAL_IMPORTS_RULE_GROUP = "SPECIAL_IMPORTS";
    private static final String NON_GROUP_RULE_GROUP = "NOT_ASSIGNED_TO_ANY_GROUP";

    private static final Pattern GROUP_SEPARATOR_PATTERN = Pattern.compile("\s*###\s*");

    /** Specify format of order declaration customizing by user. */
    private static final String customImportOrderRulesInput = "";

    /** Processed list of import order rules. */
    private final List<String> parsedImportOrderRules = new ArrayList<>();

    /** Contains ImportDetails objects for each import. */
    private final List<ImportDetails> imports = new ArrayList<>();

    /** Specify string for SAME_PACKAGE group imports. */
    private String samePackageDomainString = "";

    /** Specify Pattern for STANDARD_JAVA_PACKAGE group imports. */
    private Pattern standardPackagePattern = Pattern.compile("^(java|javax)\\.");

    /** Specify Pattern for THIRD_PARTY_PACKAGE group imports. */
    private Pattern thirdPartyPackagePattern = Pattern.compile(".*");

    /** Specify Pattern for SPECIAL_IMPORTS group imports. */
    private Pattern specialImportsPattern = Pattern.compile("^$");

    /** Force empty line separator between import groups. */
    private boolean isSeparateLineBetweenGroups = true;

    /**
     * Force grouping alphabetically,
     * in <a href="https://en.wikipedia.org/wiki/ASCII#Order"> ASCII sort order</a>.
     */
    private boolean shouldSortImportsInGroupAlphabetically;

    /** Number of first domains for SAME_PACKAGE group. */
    private int samePackageDomainDepth = 2;

    public final void setStandardPackagePattern(Pattern pattern) {
        standardPackagePattern = pattern;
    }

    public final void setThirdPartyPackagePattern(Pattern pattern) {
        thirdPartyPackagePattern = pattern;
    }

    public final void setSpecialImportsPattern(Pattern pattern) {
        specialImportsPattern = pattern;
    }

    public final void setSeparateLineBetweenGroups(boolean value) {
        isSeparateLineBetweenGroups = value;
    }

    public final void setSortImportsInGroupAlphabetically(boolean value) {
        shouldSortImportsInGroupAlphabetically = value;
    }

    public final void setCustomImportOrderRules(final String inputCustomImportOrder) {
        if (!customImportOrderRulesInput.equals(inputCustomImportOrder)) {
            for (String currentState : GROUP_SEPARATOR_PATTERN.split(inputCustomImportOrder)) {
                addRulesToList(currentState);
            }
            parsedImportOrderRules.add(NON_GROUP_RULE_GROUP);
        }
    }

    @Override
    public int[] getDefaultTokens() {
        return getRequiredTokens();
    }

    @Override
    public int[] getAcceptableTokens() {
        return getRequiredTokens();
    }

    @Override
    public int[] getRequiredTokens() {
        return new int[] {
                TokenTypes.IMPORT,
                TokenTypes.STATIC_IMPORT,
                TokenTypes.PACKAGE_DEF,
        };
    }

    @Override
    public void beginTree(DetailAST rootAST) {
        imports.clear();
    }

    @Override
    public void visitToken(DetailAST ast) {
        if (ast.getType() == TokenTypes.PACKAGE_DEF) {
            samePackageDomainString = createSamePackageDomainString(
                    samePackageDomainDepth, ast);
        }
        else {
            final String importFullPath = getFullImportIdent(ast);
            final boolean isStatic = ast.getType() == TokenTypes.STATIC_IMPORT;
            imports.add(new ImportDetails(importFullPath,
                    getImportGroup(isStatic, importFullPath), isStatic, ast));
        }
    }

    @Override
    public void finishTree(DetailAST rootAST) {
        if (!imports.isEmpty()) {
            finishImportList();
        }
    }

    private void finishImportList() {
        String currentGroup = getFirstGroup();
        int currentGroupNumber = parsedImportOrderRules.lastIndexOf(currentGroup);
        ImportDetails previousImportObjectFromCurrentGroup = null;
        String previousImportFromCurrentGroup = null;

        for (ImportDetails importObject : imports) {
            final String importGroup = importObject.getImportGroup();
            final String fullImportIdent = importObject.getImportFullPath();

            if (importGroup.equals(currentGroup)) {
                validateExtraEmptyLine(previousImportObjectFromCurrentGroup,
                        importObject, fullImportIdent);
                if (isAlphabeticalOrderBroken(previousImportFromCurrentGroup, fullImportIdent)) {
                    log(importObject.getImportAST(), MSG_LEX,
                            fullImportIdent, previousImportFromCurrentGroup);
                }
                else {
                    previousImportFromCurrentGroup = fullImportIdent;
                }
                previousImportObjectFromCurrentGroup = importObject;
            }
            else {
                if (parsedImportOrderRules.size() > currentGroupNumber + 1) {
                    final String nextGroup = getNextImportGroup(currentGroupNumber + 1);
                    if (importGroup.equals(nextGroup)) {
                        validateMissedEmptyLine(previousImportObjectFromCurrentGroup,
                                importObject, fullImportIdent);
                        currentGroup = nextGroup;
                        currentGroupNumber = parsedImportOrderRules.lastIndexOf(nextGroup);
                        previousImportFromCurrentGroup = fullImportIdent;
                    }
                    else {
                        logWrongImportGroupOrder(importObject.getImportAST(),
                                importGroup, nextGroup, fullImportIdent);
                    }
                    previousImportObjectFromCurrentGroup = importObject;
                }
                else {
                    logWrongImportGroupOrder(importObject.getImportAST(),
                            importGroup, currentGroup, fullImportIdent);
                }
            }
        }
    }

    private void validateMissedEmptyLine(ImportDetails previousImport,
                                         ImportDetails importObject, String fullImportIdent) {
        if (isEmptyLineMissed(previousImport, importObject)) {
            log(importObject.getImportAST(), MSG_LINE_SEPARATOR, fullImportIdent);
        }
    }

    private void validateExtraEmptyLine(ImportDetails previousImport,
                                        ImportDetails importObject, String fullImportIdent) {
        if (isSeparatedByExtraEmptyLine(previousImport, importObject)) {
            log(importObject.getImportAST(), MSG_SEPARATED_IN_GROUP, fullImportIdent);
        }
    }

    private String getFirstGroup() {
        final ImportDetails firstImport = imports.get(0);
        return getImportGroup(firstImport.isStaticImport(),
                firstImport.getImportFullPath());
    }

    private boolean isAlphabeticalOrderBroken(String previousImport,
                                              String currentImport) {
        return shouldSortImportsInGroupAlphabetically
                && previousImport != null
                && compareImports(currentImport, previousImport) < 0;
    }

    private boolean isEmptyLineMissed(ImportDetails previousImportObject,
                                      ImportDetails currentImportObject) {
        return isSeparateLineBetweenGroups
                && getCountOfEmptyLinesBetween(
                previousImportObject.getEndLineNumber(),
                currentImportObject.getStartLineNumber()) != 1;
    }

    private boolean isSeparatedByExtraEmptyLine(ImportDetails previousImportObject,
                                                ImportDetails currentImportObject) {
        return previousImportObject != null
                && getCountOfEmptyLinesBetween(
                previousImportObject.getEndLineNumber(),
                currentImportObject.getStartLineNumber()) > 0;
    }

    private void logWrongImportGroupOrder(DetailAST importAST, String importGroup,
                                          String currentGroupNumber, String fullImportIdent) {
        if (NON_GROUP_RULE_GROUP.equals(importGroup)) {
            log(importAST, MSG_NONGROUP_IMPORT, fullImportIdent);
        }
        else if (NON_GROUP_RULE_GROUP.equals(currentGroupNumber)) {
            log(importAST, MSG_NONGROUP_EXPECTED, importGroup, fullImportIdent);
        }
        else {
            log(importAST, MSG_ORDER, importGroup, currentGroupNumber, fullImportIdent);
        }
    }

    private String getNextImportGroup(int currentGroupNumber) {
        int nextGroupNumber = currentGroupNumber;

        while (parsedImportOrderRules.size() > nextGroupNumber + 1) {
            if (hasAnyImportInCurrentGroup(parsedImportOrderRules.get(nextGroupNumber))) {
                break;
            }
            nextGroupNumber++;
        }
        return parsedImportOrderRules.get(nextGroupNumber);
    }

    private boolean hasAnyImportInCurrentGroup(String currentGroup) {
        boolean result = false;
        for (ImportDetails currentImport : imports) {
            if (currentGroup.equals(currentImport.getImportGroup())) {
                result = true;
                break;
            }
        }
        return result;
    }

    private String getImportGroup(boolean isStatic, String importPath) {
        RuleMatchForImport bestMatch = new RuleMatchForImport(NON_GROUP_RULE_GROUP, 0, 0);
        if (isStatic && parsedImportOrderRules.contains(STATIC_RULE_GROUP)) {
            bestMatch.group = STATIC_RULE_GROUP;
            bestMatch.matchLength = importPath.length();
        }
        else if (parsedImportOrderRules.contains(SAME_PACKAGE_RULE_GROUP)) {
            final String importPathTrimmedToSamePackageDepth =
                    getFirstDomainsFromIdent(samePackageDomainDepth, importPath);
            if (samePackageDomainString.equals(importPathTrimmedToSamePackageDepth)) {
                bestMatch.group = SAME_PACKAGE_RULE_GROUP;
                bestMatch.matchLength = importPath.length();
            }
        }
        for (String group : parsedImportOrderRules) {
            if (STANDARD_JAVA_PACKAGE_RULE_GROUP.equals(group)) {
                bestMatch = findBetterPatternMatch(importPath,
                        STANDARD_JAVA_PACKAGE_RULE_GROUP, standardPackagePattern, bestMatch);
            }
            if (SPECIAL_IMPORTS_RULE_GROUP.equals(group)) {
                bestMatch = findBetterPatternMatch(importPath,
                        group, specialImportsPattern, bestMatch);
            }
        }

        if (NON_GROUP_RULE_GROUP.equals(bestMatch.group)
                && parsedImportOrderRules.contains(THIRD_PARTY_PACKAGE_RULE_GROUP)
                && thirdPartyPackagePattern.matcher(importPath).find()) {
            bestMatch.group = THIRD_PARTY_PACKAGE_RULE_GROUP;
        }
        return bestMatch.group;
    }

    private static RuleMatchForImport findBetterPatternMatch(String importPath, String group,
                                                             Pattern pattern, RuleMatchForImport currentBestMatch) {
        RuleMatchForImport betterMatchCandidate = currentBestMatch;
        final Matcher matcher = pattern.matcher(importPath);
        while (matcher.find()) {
            final int matchStart = matcher.start();
            final int length = matcher.end() - matchStart;
            if (length > betterMatchCandidate.matchLength
                    || length == betterMatchCandidate.matchLength
                    && matchStart < betterMatchCandidate.matchPosition) {
                betterMatchCandidate = new RuleMatchForImport(group, length, matchStart);
            }
        }
        return betterMatchCandidate;
    }

    private static int compareImports(String import1, String import2) {
        int result = 0;
        final String separator = "\\.";
        final String[] import1Tokens = import1.split(separator);
        final String[] import2Tokens = import2.split(separator);
        for (int i = 0; i != import1Tokens.length && i != import2Tokens.length; i++) {
            final String import1Token = import1Tokens[i];
            final String import2Token = import2Tokens[i];
            result = import1Token.compareTo(import2Token);
            if (result != 0) {
                break;
            }
        }
        if (result == 0) {
            result = Integer.compare(import1Tokens.length, import2Tokens.length);
        }
        return result;
    }

    private int getCountOfEmptyLinesBetween(int fromLineNo, int toLineNo) {
        int result = 0;
        final String[] lines = getLines();

        for (int i = fromLineNo + 1; i <= toLineNo - 1; i++) {
            if (CommonUtil.isBlank(lines[i - 1])) {
                result++;
            }
        }
        return result;
    }

    private static String getFullImportIdent(DetailAST token) {
        String ident = "";
        if (token != null) {
            ident = FullIdent.createFullIdent(token.findFirstToken(TokenTypes.DOT)).getText();
        }
        return ident;
    }

    private void addRulesToList(String ruleStr) {
        if (STATIC_RULE_GROUP.equals(ruleStr)
                || THIRD_PARTY_PACKAGE_RULE_GROUP.equals(ruleStr)
                || STANDARD_JAVA_PACKAGE_RULE_GROUP.equals(ruleStr)
                || SPECIAL_IMPORTS_RULE_GROUP.equals(ruleStr)) {
            parsedImportOrderRules.add(ruleStr);
        }
        else if (ruleStr.startsWith(SAME_PACKAGE_RULE_GROUP)) {
            final String rule = ruleStr.substring(ruleStr.indexOf('(') + 1,
                    ruleStr.indexOf(')'));
            samePackageDomainDepth = Integer.parseInt(rule);
            if (samePackageDomainDepth <= 0) {
                throw new IllegalArgumentException(
                        "SAME_PACKAGE rule parameter should be positive integer: " + ruleStr);
            }
            parsedImportOrderRules.add(SAME_PACKAGE_RULE_GROUP);
        }
        else {
            throw new IllegalStateException("Unexpected rule: " + ruleStr);
        }
    }

    private static String createSamePackageDomainString(int firstPackageDomainsCount,
                                                  DetailAST packageNode) {
        final String packageFullPath = getFullImportIdent(packageNode);
        return getFirstDomainsFromIdent(firstPackageDomainsCount, packageFullPath);
    }

    private static String getFirstDomainsFromIdent(
            final int firstPackageDomainsCount, final String packageFullPath) {
        final StringBuilder builder = new StringBuilder(256);
        final StringTokenizer tokens = new StringTokenizer(packageFullPath, ".");
        int count = firstPackageDomainsCount;

        while (count > 0 && tokens.hasMoreTokens()) {
            builder.append(tokens.nextToken()).append('.');
            count--;
        }
        return builder.toString();
    }

    private static final class ImportDetails {

        private final String importFullPath;
        private final String importGroup;
        private final boolean staticImport;
        private final DetailAST importAST;

        private ImportDetails(String importFullPath, String importGroup, boolean staticImport,
                              DetailAST importAST) {
            this.importFullPath = importFullPath;
            this.importGroup = importGroup;
            this.staticImport = staticImport;
            this.importAST = importAST;
        }

        public String getImportFullPath() {
            return importFullPath;
        }

        public int getStartLineNumber() {
            return importAST.getLineNo();
        }

        public int getEndLineNumber() {
            return importAST.getLastChild().getLineNo();
        }

        public String getImportGroup() {
            return importGroup;
        }

        public boolean isStaticImport() {
            return staticImport;
        }

        public DetailAST getImportAST() {
            return importAST;
        }
    }

    private static final class RuleMatchForImport {
        private final int matchPosition;
        private int matchLength;
        private String group;

        private RuleMatchForImport(String group, int length, int position) {
            this.group = group;
            matchLength = length;
            matchPosition = position;
        }
    }
}
```

---

**Main Updates:**
- Updated all ambiguous or non-standard field names for clarity and conformity.
- `"RegExp"` → `"Pattern"`
- `List<ImportDetails> importToGroupList` → `List<ImportDetails> imports`
- `String samePackageDomainsRegExp` → `String samePackageDomainString`
- Updated both usages and setters/getters.

---

**Note:**
These changes strictly rename attributes and update their references throughout the class. If you need method renaming (e.g., from `setStandardPackageRegExp` to `setStandardPackagePattern`), remember to update related configuration usage elsewhere in your codebase!

Does not compile
Tests do not pass