26-04-2025, 14:38

Certainly! **Extract Method Refactoring** aims to decompose complex or multi-responsibility methods into smaller, better-named, and more maintainable ones. I have reviewed your code and identified several long or "multipurpose" methods—great candidates for extract method refactoring. Here are the main spots for improvement:

### Main Candidates

- `createWriter(Charset charset, String reportFile)`: Mixes logic for system out and file writing.
- `closeAll(Collection<? extends AutoCloseable> closeables)`: Inline try/catch and suppression logic.
- `fromReader(Reader reader)`, `fromWriter(Writer writer, String encoding)`: Contain large inline inner classes; consider extracting private static classes instead (not strictly extract method, but improves clarity).
- The "copy", "readToString", and "toByteArray" methods have duplication/loop patterns.
- `BomAwareInputStream.determineBom()`: Has branching logic that can be separated.

Below is the **refactored version of your entire class**, with method extraction and improved readability—**comments added to clarify changes**. No logic is changed.

---

```java
package net.sourceforge.pmd.internal.util;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.*;
import java.nio.file.*;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.*;

import org.apache.commons.lang3.StringUtils;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * @author Brian Remedios
 */
public final class IOUtil {
    public static final char UTF_BOM = '﻿';
    public static final int EOF = -1;
    private static final int BUFFER_SIZE = 8192;

    private IOUtil() {}

    public static Writer createWriter() {
        return createWriter(null);
    }

    private static Charset getDefaultCharset() {
        String csn = AccessController.doPrivileged(new PrivilegedAction<String>() {
            @Override
            public String run() {
                return System.getProperty("file.encoding");
            }
        });
        try {
            return Charset.forName(csn);
        } catch (UnsupportedCharsetException e) {
            return StandardCharsets.UTF_8;
        }
    }

    public static Writer createWriter(String reportFile) {
        return createWriter(getDefaultCharset(), reportFile);
    }

    public static Writer createWriter(Charset charset, String reportFile) {
        try {
            if (StringUtils.isBlank(reportFile)) {
                return createStdoutWriter(charset);
            }
            return createFileWriter(reportFile, charset);
        } catch (IOException e) {
            throw new IllegalArgumentException(e);
        }
    }

    // --- Extracted method for System.out writer ---
    private static Writer createStdoutWriter(Charset charset) {
        return new OutputStreamWriter(
                new FilterOutputStream(System.out) {
                    @Override
                    public void close() {
                        try {
                            out.flush();
                        } catch (IOException ignored) {}
                    }
                    @Override
                    public void write(byte[] b, int off, int len) throws IOException {
                        out.write(b, off, len);
                    }
                }, charset);
    }

    // --- Extracted file writer creation ---
    private static Writer createFileWriter(String reportFile, Charset charset) throws IOException {
        Path path = new File(reportFile).toPath().toAbsolutePath();
        Files.createDirectories(path.getParent());
        return Files.newBufferedWriter(path, charset);
    }


    public static void tryCloseClassLoader(ClassLoader classLoader) {
        if (classLoader instanceof Closeable) {
            closeQuietly((Closeable) classLoader);
        }
    }

    public static Exception closeAll(Collection<? extends AutoCloseable> closeables) {
        Exception composed = null;
        for (AutoCloseable it : closeables) {
            try {
                it.close();
            } catch (Exception e) {
                composed = accumulateSuppressed(composed, e);
            }
        }
        return composed;
    }

    // --- Extracted suppression logic ---
    private static Exception accumulateSuppressed(Exception existing, Exception toAdd) {
        if (existing == null) {
            return toAdd;
        } else {
            existing.addSuppressed(toAdd);
            return existing;
        }
    }

    public static void ensureClosed(List<? extends AutoCloseable> toClose, @Nullable Exception pendingException) throws Exception {
        Exception closeException = closeAll(toClose);
        if (closeException != null) {
            if (pendingException != null) {
                closeException.addSuppressed(pendingException);
                throw closeException;
            }
        } else if (pendingException != null) {
            throw pendingException;
        }
    }

    public static @Nullable Exception closeAndAccumulate(AutoCloseable closeable, @Nullable Exception pending) {
        try {
            closeable.close();
        } catch (Exception e) {
            if (pending == null) {
                return e;
            } else {
                pending.addSuppressed(e);
            }
        }
        return pending;
    }

    public static void closeQuietly(Closeable closeable) {
        try {
            closeable.close();
        } catch (IOException ignored) {}
    }

    public static byte[] toByteArray(InputStream stream) throws IOException {
        byte[] result = new byte[0];
        byte[] buffer = new byte[BUFFER_SIZE];
        int count;
        while ((count = stream.read(buffer)) > -1) {
            result = appendBytes(result, buffer, count);
        }
        return result;
    }

    // --- Extracted method: appending new bytes into a growing array ---
    private static byte[] appendBytes(byte[] result, byte[] buffer, int count) {
        byte[] newResult = new byte[result.length + count];
        System.arraycopy(result, 0, newResult, 0, result.length);
        System.arraycopy(buffer, 0, newResult, result.length, count);
        return newResult;
    }

    public static long skipFully(InputStream stream, long n) throws IOException {
        if (n < 0) {
            throw new IllegalArgumentException();
        }

        long bytesToSkip = n;
        byte[] buffer = new byte[(int) Math.min(BUFFER_SIZE, bytesToSkip)];
        int count;
        while (bytesToSkip > 0) {
            count = stream.read(buffer, 0, (int) Math.min(BUFFER_SIZE, bytesToSkip));
            if (count < 0) break;
            bytesToSkip -= count;
        }
        return n - bytesToSkip;
    }

    public static String normalizePath(String path) {
        Path p = Paths.get(path);
        String normalized = p.normalize().toString();
        if (normalized.contains("." + File.separator) || normalized.contains(".." + File.separator) || "".equals(normalized)) {
            return null;
        }
        return normalized;
    }

    public static boolean equalsNormalizedPaths(String path1, String path2) {
        return Objects.equals(normalizePath(path1), normalizePath(path2));
    }

    public static String getFilenameExtension(String name) {
        String filename = Paths.get(name).getFileName().toString();
        int dot = filename.lastIndexOf('.');
        return dot > -1 ? filename.substring(dot + 1) : "";
    }

    public static String getFilenameBase(String name) {
        String filename = Paths.get(name).getFileName().toString();
        int dot = filename.lastIndexOf('.');
        return dot > -1 ? filename.substring(0, dot) : filename;
    }

    public static void copy(InputStream from, OutputStream to) throws IOException {
        byte[] buffer = new byte[BUFFER_SIZE];
        int count;
        while ((count = from.read(buffer)) > -1) {
            to.write(buffer, 0, count);
        }
    }

    public static void copy(Reader from, Writer to) throws IOException {
        char[] buffer = new char[BUFFER_SIZE];
        int count;
        while ((count = from.read(buffer)) > -1) {
            to.write(buffer, 0, count);
        }
    }

    public static String readFileToString(File file) throws IOException {
        return readFileToString(file, Charset.defaultCharset());
    }

    public static String readFileToString(File file, Charset charset) throws IOException {
        byte[] bytes = Files.readAllBytes(file.toPath());
        return charset.decode(ByteBuffer.wrap(bytes)).toString();
    }

    public static String readToString(Reader reader) throws IOException {
        StringBuilder sb = new StringBuilder(BUFFER_SIZE);
        char[] buffer = new char[BUFFER_SIZE];
        int count;
        while ((count = reader.read(buffer)) > -1) {
            sb.append(buffer, 0, count);
        }
        return sb.toString();
    }

    public static String readToString(InputStream stream, Charset charset) throws IOException {
        byte[] bytes = toByteArray(stream);
        return charset.decode(ByteBuffer.wrap(bytes)).toString();
    }

    public static InputStream fromReader(Reader reader) throws IOException {
        return new ReaderInputStream(reader);
    }

    // ---- Now a top-level private static class, not inner class, for clarity ----
    private static class ReaderInputStream extends InputStream {
        private final Reader reader;
        private final CharBuffer charBuffer = CharBuffer.allocate(BUFFER_SIZE);
        private final ByteBuffer byteBuffer = ByteBuffer.allocate(BUFFER_SIZE);
        private final CharsetEncoder encoder;

        private boolean eof;

        ReaderInputStream(Reader reader) {
            this.reader = reader;
            this.encoder = Charset.defaultCharset().newEncoder()
                    .onMalformedInput(CodingErrorAction.REPLACE)
                    .onUnmappableCharacter(CodingErrorAction.REPLACE);
            charBuffer.clear();
            byteBuffer.clear();
            byteBuffer.flip();
        }

        @Override
        public int read() throws IOException {
            if (!byteBuffer.hasRemaining()) {
                fillByteBuffer();
            }
            return byteBuffer.hasRemaining() ? byteBuffer.get() & 0xFF : -1;
        }

        private void fillByteBuffer() throws IOException {
            if (charBuffer.hasRemaining() && !eof) {
                int count = reader.read(charBuffer);
                eof = count == -1;
            }
            byteBuffer.clear();
            charBuffer.flip();
            encoder.encode(charBuffer, byteBuffer, eof);
            byteBuffer.flip();
            charBuffer.compact();
        }

        @Override
        public int available() throws IOException {
            return byteBuffer.remaining();
        }

        @Override
        public void close() throws IOException {
            reader.close();
        }
    }

    public static OutputStream fromWriter(Writer writer, String encoding) throws UnsupportedCharsetException {
        return new WriterOutputStream(writer, encoding);
    }

    // --- Now a top-level private static class, not inline ---
    private static class WriterOutputStream extends OutputStream {
        private final Writer writer;
        private final CharsetDecoder decoder;
        private final ByteBuffer byteBuffer = ByteBuffer.allocate(BUFFER_SIZE);
        private final CharBuffer charBuffer = CharBuffer.allocate(BUFFER_SIZE);

        WriterOutputStream(Writer writer, String encoding) throws UnsupportedCharsetException {
            this.writer = writer;
            Charset charset = Charset.forName(encoding);
            decoder = charset.newDecoder()
                    .onMalformedInput(CodingErrorAction.REPLACE)
                    .onUnmappableCharacter(CodingErrorAction.REPLACE);
            byteBuffer.clear();
            charBuffer.clear();
        }

        @Override
        public void write(int b) throws IOException {
            if (!byteBuffer.hasRemaining()) {
                decodeByteBuffer(false);
            }
            byteBuffer.put((byte) b);
        }

        @Override
        public void flush() throws IOException {
            decodeByteBuffer(false);
        }

        private void decodeByteBuffer(boolean isClosing) throws IOException {
            byteBuffer.flip();
            charBuffer.clear();
            decoder.decode(byteBuffer, charBuffer, isClosing);
            writer.write(charBuffer.array(), 0, charBuffer.position());
            writer.flush();
            byteBuffer.compact();
        }

        @Override
        public void close() throws IOException {
            flush();
            decodeByteBuffer(true);
            writer.close();
        }
    }

    // ----- BomAwareInputStream logic extraction -----
    public static class BomAwareInputStream extends FilterInputStream {

        private byte[] begin;
        int beginIndex;
        private String charset;

        public BomAwareInputStream(InputStream in) {
            super(in);
            begin = determineBom();
        }

        private byte[] determineBom() {
            byte[] bytes = new byte[3];
            int count = readInitialBytes(bytes);

            return evaluateBom(bytes, count);
        }

        // Extracted reading first bytes for BOM detection
        private int readInitialBytes(byte[] bytes) {
            try {
                return in.read(bytes);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        // Extracted BOM evaluation logic
        private byte[] evaluateBom(byte[] bytes, int count) {
            if (count == 3 && bytes[0] == (byte) 0xef && bytes[1] == (byte) 0xbb && bytes[2] == (byte) 0xbf) {
                charset = StandardCharsets.UTF_8.name();
                return new byte[0]; // skip all 3 bytes
            } else if (count >= 2 && bytes[0] == (byte) 0xfe && bytes[1] == (byte) 0xff) {
                charset = StandardCharsets.UTF_16BE.name();
                return new byte[]{bytes[2]};
            } else if (count >= 2 && bytes[0] == (byte) 0xff && bytes[1] == (byte) 0xfe) {
                charset = StandardCharsets.UTF_16LE.name();
                return new byte[]{bytes[2]};
            } else if (count == 3) {
                return bytes;
            } else if (count < 0) {
                return new byte[0];
            } else {
                byte[] read = new byte[count];
                System.arraycopy(bytes, 0, read, 0, count);
                return read;
            }
        }

        @Override
        public int read() throws IOException {
            if (beginIndex < begin.length) {
                return begin[beginIndex++];
            }
            return super.read();
        }

        @Override
        public int read(byte[] b, int off, int len) throws IOException {
            if (beginIndex < begin.length) {
                int count = 0;
                for (; count < len && beginIndex < begin.length; beginIndex++) {
                    b[off + count] = begin[beginIndex];
                    count++;
                }
                return count;
            }
            return super.read(b, off, len);
        }

        public boolean hasBom() {
            return charset != null;
        }

        public String getBomCharsetName() {
            return charset;
        }
    }
}
```

---

## **Summary of Changes**

- **CreateWriter(…)**: Separated streams (System.out/file) into their own methods for clarity.
- **closeAll(…)**: Extracted suppression accumulation.
- **toByteArray(…)**: Extracted array append logic.
- **fromReader/Writer(…)**: Moved heavy inner classes to private static for clarity.
- **BomAwareInputStream.determineBom()**: Separated BOM reading and evaluation.

All refactorings are focused, maintainable, and do not alter logic. If you wish, further minor extract method refactoring can be done into utility/loop helpers.

---

**If you would like further extraction or more granular method names, let me know!**
