01-05-2025, 09:52

There **are** some opportunities for extract variable refactorings in this code. The main patterns are:

- The expression `inputStream.readAllBytes()` is called twice (one in the “forbidden” type check, another in the actual upload).
- The expression `"The file path provided for upload, '" + singleFilePath + "', is not valid."` is only used once, but could be extracted for readability.
- Similarly, some error message constructions can be extracted, but the most impactful refactoring is for `inputStream.readAllBytes()`.

However, we must be **careful**: calling `inputStream.readAllBytes()` more than once will exhaust the stream the first time, so if the code reads bytes for forbidden check and then wants to read them again for upload, it will fail. Therefore, it is both a correctness issue and a refactoring opportunity to read the bytes **once** and then use the variable in both places.

Below is the **refactored class**, improving both performance and clarity:

```java
package org.apache.solr.handler.configsets;

import static org.apache.solr.client.solrj.SolrRequest.METHOD.PUT;
import static org.apache.solr.security.PermissionNameProvider.Name.CONFIG_EDIT_PERM;

import java.io.InputStream;
import org.apache.solr.api.EndPoint;
import org.apache.solr.common.SolrException;
import org.apache.solr.common.cloud.ZkMaintenanceUtils;
import org.apache.solr.common.params.ConfigSetParams;
import org.apache.solr.core.CoreContainer;
import org.apache.solr.request.SolrQueryRequest;
import org.apache.solr.response.SolrQueryResponse;
import org.apache.solr.util.FileTypeMagicUtil;

/**
 * V2 API for adding or updating a single file within a configset.
 *
 * <p>This API (PUT /v2/cluster/configs/configsetName/someFilePath) is analogous to the v1
 * /admin/configs?action=UPLOAD&amp;filePath=someFilePath command.
 */
public class UploadConfigSetFileAPI extends ConfigSetAPIBase {

    public static final String CONFIGSET_NAME_PLACEHOLDER =
            UploadConfigSetAPI.CONFIGSET_NAME_PLACEHOLDER;
    public static final String FILEPATH_PLACEHOLDER = "*";

    private static final String API_PATH =
            "/cluster/configs/{" + CONFIGSET_NAME_PLACEHOLDER + "}/" + FILEPATH_PLACEHOLDER;

    public UploadConfigSetFileAPI(CoreContainer coreContainer) {
        super(coreContainer);
    }

    @EndPoint(method = PUT, path = API_PATH, permission = CONFIG_EDIT_PERM)
    public void updateConfigSetFile(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {
        ensureConfigSetUploadEnabled();

        final String configSetName = req.getPathTemplateValues().get("name");
        boolean overwritesExisting = configSetService.checkConfigExists(configSetName);
        boolean requestIsTrusted =
                isTrusted(req.getUserPrincipal(), coreContainer.getAuthenticationPlugin());

        // Get upload parameters

        String singleFilePath = req.getPathTemplateValues().getOrDefault(FILEPATH_PLACEHOLDER, "");
        boolean allowOverwrite = req.getParams().getBool(ConfigSetParams.OVERWRITE, true);
        boolean cleanup = req.getParams().getBool(ConfigSetParams.CLEANUP, false);
        final InputStream inputStream = ensureNonEmptyInputStream(req);

        String fixedSingleFilePath = singleFilePath;
        if (fixedSingleFilePath.charAt(0) == '/') {
            fixedSingleFilePath = fixedSingleFilePath.substring(1);
        }
        if (fixedSingleFilePath.isEmpty()) {
            String invalidFilePathMsg =
                    "The file path provided for upload, '" + singleFilePath + "', is not valid.";
            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, invalidFilePathMsg);
        }

        final byte[] fileBytes = inputStream.readAllBytes();

        if (ZkMaintenanceUtils.isFileForbiddenInConfigSets(fixedSingleFilePath)
                || FileTypeMagicUtil.isFileForbiddenInConfigset(fileBytes)) {
            String forbiddenFileTypeMsg =
                    "The file type provided for upload, '"
                            + singleFilePath
                            + "', is forbidden for use in configSets.";
            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, forbiddenFileTypeMsg);
        } else if (cleanup) {
            // Cleanup is not allowed while using singleFilePath upload
            String cleanupNotAllowedMsg =
                    "ConfigSet uploads do not allow cleanup=true when file path is used.";
            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, cleanupNotAllowedMsg);
        } else {
            // Create a node for the configuration in config
            // For creating the baseNode, the cleanup parameter is only allowed to be true when
            // singleFilePath is not passed.
            createBaseNode(configSetService, overwritesExisting, requestIsTrusted, configSetName);
            configSetService.uploadFileToConfig(configSetName, fixedSingleFilePath, fileBytes, allowOverwrite);
        }
    }
}
```

**Summary of key improvements:**
- `final byte[] fileBytes = inputStream.readAllBytes();` ensures that the file is read only once and prevents input stream exhaustion issues, increasing efficiency.
- Extracted repeated string constructions into variables for clarity and potential reuse.
- The rest of the code logic remains unaltered.

This style improves code **readability** and **reusability** while also fixing a likely bug concerning the reuse of input streams.

Levenshtein edit-distance: 483
Compiles