29-04-2025, 21:46

**Analysis for Extract Variable Refactoring:**

The _extract variable_ refactoring is used to assign complex expressions or method calls to a local variable to improve readability, reduce duplication, and aid debugging. I'll highlight and refactor the code where appropriate, with a focus on significant expressions that may benefit clarity when named.

### Key Spots for Extract Variable Refactoring

- **Complex method/constructor calls** with multiple nested accesses.
- **Complex conditions** in `if` or similar statements.
- **Repeated expressions** in the same scope.

I'll walk through the code and **apply extract variable refactoring** where it meaningfully improves readability, then print the full refactored class.

---

## Refactored Code: `DefaultRefreshEventListener`

```java
package org.hibernate.event.internal;

import org.hibernate.HibernateException;
import org.hibernate.LockMode;
import org.hibernate.LockOptions;
import org.hibernate.NonUniqueObjectException;
import org.hibernate.TransientObjectException;
import org.hibernate.UnresolvableObjectException;
import org.hibernate.cache.spi.access.CollectionDataAccess;
import org.hibernate.cache.spi.access.EntityDataAccess;
import org.hibernate.cache.spi.access.SoftLock;
import org.hibernate.engine.internal.Cascade;
import org.hibernate.engine.internal.CascadePoint;
import org.hibernate.engine.spi.ActionQueue;
import org.hibernate.engine.spi.CascadingActions;
import org.hibernate.engine.spi.EntityEntry;
import org.hibernate.engine.spi.EntityKey;
import org.hibernate.engine.spi.PersistenceContext;
import org.hibernate.engine.spi.SessionFactoryImplementor;
import org.hibernate.event.spi.EventSource;
import org.hibernate.event.spi.RefreshContext;
import org.hibernate.event.spi.RefreshEvent;
import org.hibernate.event.spi.RefreshEventListener;
import org.hibernate.internal.CoreLogging;
import org.hibernate.internal.CoreMessageLogger;
import org.hibernate.loader.ast.spi.CascadingFetchProfile;
import org.hibernate.metamodel.spi.MappingMetamodelImplementor;
import org.hibernate.persister.collection.CollectionPersister;
import org.hibernate.persister.entity.EntityPersister;
import org.hibernate.proxy.HibernateProxy;
import org.hibernate.proxy.LazyInitializer;
import org.hibernate.type.CollectionType;
import org.hibernate.type.CompositeType;
import org.hibernate.type.Type;

import static org.hibernate.pretty.MessageHelper.infoString;

public class DefaultRefreshEventListener implements RefreshEventListener {
    private static final CoreMessageLogger LOG = CoreLogging.messageLogger( DefaultRefreshEventListener.class );

    public void onRefresh(RefreshEvent event) throws HibernateException {
        onRefresh( event, RefreshContext.create() );
    }

    public void onRefresh(RefreshEvent event, RefreshContext refreshedAlready) {
        final EventSource source = event.getSession();
        final PersistenceContext persistenceContext = source.getPersistenceContextInternal();
        final Object object = event.getObject();

        if ( persistenceContext.reassociateIfUninitializedProxy( object ) ) {

            final LazyInitializer lazyInitializer = HibernateProxy.extractLazyInitializer( object );
            final String entityName = lazyInitializer.getEntityName();
            final EntityPersister persister = source.getEntityPersister( entityName, object );
            final Object identifier = persister.getIdentifier( object, event.getSession() );
            refresh(
                    event,
                    null,
                    source,
                    persister,
                    lazyInitializer,
                    null,
                    identifier,
                    persistenceContext
            );

            if ( isTransient( event, source, object )  ) {
                final boolean defaultReadOnly = source.isDefaultReadOnly();
                source.setReadOnly( object, defaultReadOnly );
            }
        }
        else {
            final Object entity = persistenceContext.unproxyAndReassociate( object );
            if ( refreshedAlready.add( entity ) ) {
                refresh( event, refreshedAlready, entity );
            }
            else {
                LOG.trace( "Already refreshed" );
            }
        }
    }

    private static boolean isTransient(RefreshEvent event, EventSource source, Object object) {
        final String entityName = event.getEntityName();
        return entityName != null ? !source.contains( entityName, object) : !source.contains(object);
    }

    private static void refresh(RefreshEvent event, RefreshContext refreshedAlready, Object object) {
        final EventSource source = event.getSession();
        final PersistenceContext persistenceContext = source.getPersistenceContextInternal();
        final EntityEntry entry = persistenceContext.getEntry( object );

        final EntityPersister persister;
        final Object id;
        if ( entry == null ) {
            persister = source.getEntityPersister( event.getEntityName(), object );
            id = persister.getIdentifier( object, event.getSession() );
            if ( id == null ) {
                throw new TransientObjectException( "transient instance passed to refresh");
            }
            if ( LOG.isTraceEnabled() ) {
                final String info = infoString( persister, id, source.getFactory() );
                LOG.tracev(
                        "Refreshing transient {0}",
                        info
                );
            }
            final EntityKey entityKey = source.generateEntityKey( id, persister );
            if ( persistenceContext.getEntry( entityKey ) != null ) {
                throw new NonUniqueObjectException( id, persister.getEntityName() );
            }
        }
        else {
            if ( LOG.isTraceEnabled() ) {
                final String info = infoString( entry.getPersister(), entry.getId(), source.getFactory() );
                LOG.tracev(
                        "Refreshing ",
                        info
                );
            }
            if ( !entry.isExistsInDatabase() ) {
                throw new UnresolvableObjectException(
                        entry.getId(),
                        "this instance does not yet exist as a row in the database"
                );
            }
            persister = entry.getPersister();
            id = entry.getId();
        }

        // cascade the refresh prior to refreshing this entity
        Cascade.cascade(
                CascadingActions.REFRESH,
                CascadePoint.BEFORE_REFRESH,
                source,
                persister,
                object,
                refreshedAlready
        );

        if ( entry != null ) {
            final EntityKey key = source.generateEntityKey( id, persister );
            persistenceContext.removeEntity( key );
            if ( persister.hasCollections() ) {
                final EvictVisitor evictVisitor = new EvictVisitor( source, object );
                evictVisitor.process( object, persister );
            }
        }

        evictEntity( object, persister, id, source );
        evictCachedCollections( persister, id, source );

        refresh( event, object, source, persister, null, entry, id, persistenceContext );
    }

    private static void refresh(
            RefreshEvent event,
            Object object,
            EventSource source,
            EntityPersister persister,
            LazyInitializer lazyInitializer,
            EntityEntry entry,
            Object id,
            PersistenceContext persistenceContext) {

        final Object result = source.getLoadQueryInfluencers().fromInternalFetchProfile(
                CascadingFetchProfile.REFRESH,
                () -> doRefresh( event, source, object, entry, persister, lazyInitializer, id, persistenceContext )
        );
        final String entityName = persister.getEntityName();
        UnresolvableObjectException.throwIfNull( result, id, entityName );
    }

    private static void evictEntity(Object object, EntityPersister persister, Object id, EventSource source) {
        if ( persister.canWriteToCache() ) {
            Object previousVersion = null;
            if ( persister.isVersionPropertyGenerated() ) {
                previousVersion = persister.getVersion( object );
            }
            final EntityDataAccess cache = persister.getCacheAccessStrategy();
            final Object ck = cache.generateCacheKey(
                    id,
                    persister,
                    source.getFactory(),
                    source.getTenantIdentifier()
            );
            final SoftLock lock = cache.lockItem( source, ck, previousVersion );
            cache.remove( source, ck );
            source.getActionQueue().registerProcess( (success, session) -> cache.unlockItem( session, ck, lock ) );
        }
    }

    private static Object doRefresh(
            RefreshEvent event,
            EventSource source,
            Object object,
            EntityEntry entry,
            EntityPersister persister,
            LazyInitializer lazyInitializer,
            Object id,
            PersistenceContext persistenceContext) {
        // Handle the requested lock-mode (if one) in relation to the entry's (if one) current lock-mode
        LockOptions lockOptionsToUse = event.getLockOptions();
        final LockMode requestedLockMode = lockOptionsToUse.getLockMode();
        final LockMode postRefreshLockMode;
        if ( entry != null ) {
            final LockMode currentLockMode = entry.getLockMode();
            final boolean needsLessRestrictiveLock = currentLockMode.greaterThan( requestedLockMode );
            if ( needsLessRestrictiveLock ) {
                lockOptionsToUse = event.getLockOptions().makeCopy();
                final boolean isExclusiveLock =
                        currentLockMode == LockMode.WRITE
                        || currentLockMode == LockMode.PESSIMISTIC_WRITE
                        || currentLockMode == LockMode.PESSIMISTIC_READ;
                if ( isExclusiveLock ) {
                    // our transaction should already hold the exclusive lock on the underlying row - so READ should be sufficient.
                    lockOptionsToUse.setLockMode( LockMode.READ );
                    // and prepare to reset the entry lock-mode to the previous lock mode after the refresh completes
                    postRefreshLockMode = currentLockMode;
                }
                else {
                    lockOptionsToUse.setLockMode( currentLockMode );
                    postRefreshLockMode = null;
                }
            }
            else {
                postRefreshLockMode = null;
            }
        }
        else {
            postRefreshLockMode = null;
        }

        final Object result = persister.load( id, object, lockOptionsToUse, source );
        if ( result != null ) {
            if ( postRefreshLockMode != null ) {
                final EntityEntry refreshedEntry = persistenceContext.getEntry( result );
                refreshedEntry.setLockMode( postRefreshLockMode );
            }

            final boolean readOnly = isReadOnly( entry, persister, lazyInitializer, source );
            source.setReadOnly( result, readOnly );
        }
        return result;
    }

    private static boolean isReadOnly(
            EntityEntry entry,
            EntityPersister persister,
            LazyInitializer lazyInitializer,
            EventSource source) {
        // Keep the same read-only/modifiable setting for the entity that it had before refreshing;
        // If it was transient, then set it to the default for the source.
        if ( !persister.isMutable() ) {
            return true;
        }
        else if ( entry != null ) {
            return entry.isReadOnly();
        }
        else if ( lazyInitializer != null ) {
            return lazyInitializer.isReadOnly();
        }
        else {
            return source.isDefaultReadOnly();
        }
    }

    private static void evictCachedCollections(EntityPersister persister, Object id, EventSource source) {
        final Type[] propertyTypes = persister.getPropertyTypes();
        evictCachedCollections( propertyTypes, id, source );
    }

    private static void evictCachedCollections(Type[] types, Object id, EventSource source)
            throws HibernateException {
        final ActionQueue actionQueue = source.getActionQueue();
        final SessionFactoryImplementor factory = source.getFactory();
        final MappingMetamodelImplementor metamodel = factory.getRuntimeMetamodels().getMappingMetamodel();
        for ( Type type : types ) {
            if ( type.isCollectionType() ) {
                final CollectionType collectionType = (CollectionType) type;
                final String role = collectionType.getRole();
                final CollectionPersister collectionPersister = metamodel.getCollectionDescriptor( role );
                if ( collectionPersister.hasCache() ) {
                    final CollectionDataAccess cache = collectionPersister.getCacheAccessStrategy();
                    final Object ck = cache.generateCacheKey(
                            id,
                            collectionPersister,
                            factory,
                            source.getTenantIdentifier()
                    );
                    final SoftLock lock = cache.lockItem( source, ck, null );
                    cache.remove( source, ck );
                    actionQueue.registerProcess( (success, session) -> cache.unlockItem( session, ck, lock ) );
                }
            }
            else if ( type.isComponentType() ) {
                final CompositeType compositeType = (CompositeType) type;
                final Type[] subtypes = compositeType.getSubtypes();
                evictCachedCollections( subtypes, id, source );
            }
        }
    }
}
```

---

**Summary of Main Changes (Extract Variables):**
- Complex calls and parameters were extracted to local variables with clear, meaningful names, e.g.:
  - `final Object identifier`, `final String entityName`, `final EntityKey entityKey`, etc.
  - Split out sub-expressions for collection type and composite type handling.
  - Named boolean conditions, like `needsLessRestrictiveLock` and `isExclusiveLock`, to clarify the logic flow.
  - Used variables for `infoString`, `EvictVisitor`, and property type arrays.

These changes collectively improve readability and maintainability, especially for future review or debugging.

---

**If you need more aggressive or different extraction, or only want the specific locations with "before/after" diffs, just ask.**



FINISHED REFACTORING 0



Yes, there are **multiple opportunities for Extract Variable refactoring** in this code to improve readability, especially where constructor-style or method chains are used, or complex expressions are repeatedly used as method arguments. I’ll list prominent examples, **apply the refactoring**, and generate the whole refactored class.

## Notable spots for Extract Variable

**1. Complex argument composition & nested calls**
For example, in `evictEntity`:
```java
final Object ck = cache.generateCacheKey(
    id,
    persister,
    source.getFactory(),
    source.getTenantIdentifier()
);
final SoftLock lock = cache.lockItem( source, ck, previousVersion );
cache.remove( source, ck );
source.getActionQueue().registerProcess( (success, session) -> cache.unlockItem( session, ck, lock ) );
```
Here, both the computation of `ck` and the lambda for registering the unlockItem can be much clearer with variables.

**2. Repeated fetches**
For example:
```java
final SessionFactoryImplementor factory = source.getFactory();
final MappingMetamodelImplementor metamodel = factory.getRuntimeMetamodels().getMappingMetamodel();
```
Each time we fetch these, we should extract as variable at the scope intended.

**3. Complex conditional branches & chaining**
Any complex chained expressions (such as type casts) benefit from naming.

---

## Refactored class with Extract Variable Improvements

```java
package org.hibernate.event.internal;

import org.hibernate.HibernateException;
import org.hibernate.LockMode;
import org.hibernate.LockOptions;
import org.hibernate.NonUniqueObjectException;
import org.hibernate.TransientObjectException;
import org.hibernate.UnresolvableObjectException;
import org.hibernate.cache.spi.access.CollectionDataAccess;
import org.hibernate.cache.spi.access.EntityDataAccess;
import org.hibernate.cache.spi.access.SoftLock;
import org.hibernate.engine.internal.Cascade;
import org.hibernate.engine.internal.CascadePoint;
import org.hibernate.engine.spi.ActionQueue;
import org.hibernate.engine.spi.CascadingActions;
import org.hibernate.engine.spi.EntityEntry;
import org.hibernate.engine.spi.EntityKey;
import org.hibernate.engine.spi.PersistenceContext;
import org.hibernate.engine.spi.SessionFactoryImplementor;
import org.hibernate.event.spi.EventSource;
import org.hibernate.event.spi.RefreshContext;
import org.hibernate.event.spi.RefreshEvent;
import org.hibernate.event.spi.RefreshEventListener;
import org.hibernate.internal.CoreLogging;
import org.hibernate.internal.CoreMessageLogger;
import org.hibernate.loader.ast.spi.CascadingFetchProfile;
import org.hibernate.metamodel.spi.MappingMetamodelImplementor;
import org.hibernate.persister.collection.CollectionPersister;
import org.hibernate.persister.entity.EntityPersister;
import org.hibernate.proxy.HibernateProxy;
import org.hibernate.proxy.LazyInitializer;
import org.hibernate.type.CollectionType;
import org.hibernate.type.CompositeType;
import org.hibernate.type.Type;

import static org.hibernate.pretty.MessageHelper.infoString;

public class DefaultRefreshEventListener implements RefreshEventListener {
    private static final CoreMessageLogger LOG = CoreLogging.messageLogger( DefaultRefreshEventListener.class );

    public void onRefresh(RefreshEvent event) throws HibernateException {
        onRefresh( event, RefreshContext.create() );
    }

    public void onRefresh(RefreshEvent event, RefreshContext refreshedAlready) {
        final EventSource source = event.getSession();
        final PersistenceContext persistenceContext = source.getPersistenceContextInternal();
        final Object object = event.getObject();
        if ( persistenceContext.reassociateIfUninitializedProxy( object ) ) {
            final LazyInitializer lazyInitializer = HibernateProxy.extractLazyInitializer( object );
            final String entityName = lazyInitializer.getEntityName();
            final EntityPersister persister = source.getEntityPersister( entityName, object );
            final Object identifier = persister.getIdentifier( object, event.getSession() );
            refresh(
                    event,
                    null,
                    source,
                    persister,
                    lazyInitializer,
                    null,
                    identifier,
                    persistenceContext
            );
            if ( isTransient( event, source, object )  ) {
                source.setReadOnly( object, source.isDefaultReadOnly() );
            }
        }
        else {
            final Object entity = persistenceContext.unproxyAndReassociate( object );
            if ( refreshedAlready.add( entity ) ) {
                refresh( event, refreshedAlready, entity );
            } else {
                LOG.trace( "Already refreshed" );
            }
        }
    }

    private static boolean isTransient(RefreshEvent event, EventSource source, Object object) {
        final String entityName = event.getEntityName();
        return entityName != null ? !source.contains( entityName, object ) : !source.contains(object);
    }

    private static void refresh(RefreshEvent event, RefreshContext refreshedAlready, Object object) {
        final EventSource source = event.getSession();
        final PersistenceContext persistenceContext = source.getPersistenceContextInternal();
        final EntityEntry entry = persistenceContext.getEntry( object );
        final EntityPersister persister;
        final Object id;
        if ( entry == null ) {
            persister = source.getEntityPersister( event.getEntityName(), object );
            id = persister.getIdentifier( object, event.getSession() );
            if ( id == null ) {
                throw new TransientObjectException( "transient instance passed to refresh");
            }
            if ( LOG.isTraceEnabled() ) {
                String info = infoString( persister, id, source.getFactory() );
                LOG.tracev( "Refreshing transient {0}", info );
            }
            EntityKey entityKey = source.generateEntityKey( id, persister );
            if ( persistenceContext.getEntry( entityKey ) != null ) {
                throw new NonUniqueObjectException( id, persister.getEntityName() );
            }
        }
        else {
            if ( LOG.isTraceEnabled() ) {
                String info = infoString( entry.getPersister(), entry.getId(), source.getFactory() );
                LOG.tracev( "Refreshing ", info );
            }
            if ( !entry.isExistsInDatabase() ) {
                throw new UnresolvableObjectException(
                        entry.getId(),
                        "this instance does not yet exist as a row in the database"
                );
            }
            persister = entry.getPersister();
            id = entry.getId();
        }

        // cascade the refresh prior to refreshing this entity
        Cascade.cascade(
                CascadingActions.REFRESH,
                CascadePoint.BEFORE_REFRESH,
                source,
                persister,
                object,
                refreshedAlready
        );

        if ( entry != null ) {
            final EntityKey key = source.generateEntityKey( id, persister );
            persistenceContext.removeEntity( key );
            if ( persister.hasCollections() ) {
                EvictVisitor evictVisitor = new EvictVisitor( source, object );
                evictVisitor.process( object, persister );
            }
        }

        evictEntity( object, persister, id, source );
        evictCachedCollections( persister, id, source );

        refresh( event, object, source, persister, null, entry, id, persistenceContext );
    }

    private static void refresh(
            RefreshEvent event,
            Object object,
            EventSource source,
            EntityPersister persister,
            LazyInitializer lazyInitializer,
            EntityEntry entry,
            Object id,
            PersistenceContext persistenceContext) {

        final Object result = source.getLoadQueryInfluencers().fromInternalFetchProfile(
                CascadingFetchProfile.REFRESH,
                () -> doRefresh( event, source, object, entry, persister, lazyInitializer, id, persistenceContext )
        );
        final String entityName = persister.getEntityName();
        UnresolvableObjectException.throwIfNull( result, id, entityName );
    }

    private static void evictEntity(Object object, EntityPersister persister, Object id, EventSource source) {
        if ( persister.canWriteToCache() ) {
            Object previousVersion = null;
            if ( persister.isVersionPropertyGenerated() ) {
                previousVersion = persister.getVersion( object );
            }
            final EntityDataAccess cache = persister.getCacheAccessStrategy();
            final SessionFactoryImplementor factory = source.getFactory();
            final String tenantIdentifier = source.getTenantIdentifier();
            final Object cacheKey = cache.generateCacheKey( id, persister, factory, tenantIdentifier );
            final SoftLock lock = cache.lockItem( source, cacheKey, previousVersion );
            cache.remove( source, cacheKey );
            ActionQueue actionQueue = source.getActionQueue();
            actionQueue.registerProcess(
                (success, session) -> cache.unlockItem( session, cacheKey, lock )
            );
        }
    }

    private static Object doRefresh(
            RefreshEvent event,
            EventSource source,
            Object object,
            EntityEntry entry,
            EntityPersister persister,
            LazyInitializer lazyInitializer,
            Object id,
            PersistenceContext persistenceContext) {
        // Handle the requested lock-mode (if one) in relation to the entry's (if one) current lock-mode
        LockOptions eventLockOptions = event.getLockOptions();
        final LockMode requestedLockMode = eventLockOptions.getLockMode();
        final LockMode postRefreshLockMode;
        LockOptions lockOptionsToUse = eventLockOptions;

        if ( entry != null ) {
            final LockMode currentLockMode = entry.getLockMode();
            if ( currentLockMode.greaterThan( requestedLockMode ) ) {
                // pass along the current lock-mode (after accounting for WRITE)
                lockOptionsToUse = eventLockOptions.makeCopy();
                if ( currentLockMode == LockMode.WRITE
                        || currentLockMode == LockMode.PESSIMISTIC_WRITE
                        || currentLockMode == LockMode.PESSIMISTIC_READ ) {
                    lockOptionsToUse.setLockMode( LockMode.READ );
                    postRefreshLockMode = currentLockMode;
                }
                else {
                    lockOptionsToUse.setLockMode( currentLockMode );
                    postRefreshLockMode = null;
                }
            }
            else {
                postRefreshLockMode = null;
            }
        }
        else {
            postRefreshLockMode = null;
        }

        final Object result = persister.load( id, object, lockOptionsToUse, source );
        if ( result != null ) {
            // apply postRefreshLockMode, if needed
            if ( postRefreshLockMode != null ) {
                final EntityEntry refreshedEntry = persistenceContext.getEntry( result );
                refreshedEntry.setLockMode( postRefreshLockMode );
            }
            boolean readOnly = isReadOnly( entry, persister, lazyInitializer, source );
            source.setReadOnly( result, readOnly );
        }
        return result;
    }

    private static boolean isReadOnly(
            EntityEntry entry,
            EntityPersister persister,
            LazyInitializer lazyInitializer,
            EventSource source) {
        if ( !persister.isMutable() ) {
            return true;
        }
        else if ( entry != null ) {
            return entry.isReadOnly();
        }
        else if ( lazyInitializer != null ) {
            return lazyInitializer.isReadOnly();
        }
        else {
            return source.isDefaultReadOnly();
        }
    }

    private static void evictCachedCollections(EntityPersister persister, Object id, EventSource source) {
        Type[] propertyTypes = persister.getPropertyTypes();
        evictCachedCollections( propertyTypes, id, source );
    }

    private static void evictCachedCollections(Type[] types, Object id, EventSource source)
            throws HibernateException {
        final ActionQueue actionQueue = source.getActionQueue();
        final SessionFactoryImplementor factory = source.getFactory();
        final String tenantIdentifier = source.getTenantIdentifier();
        final MappingMetamodelImplementor metamodel = factory.getRuntimeMetamodels().getMappingMetamodel();
        for ( Type type : types ) {
            if ( type.isCollectionType() ) {
                final CollectionType collectionType = (CollectionType) type;
                final String role = collectionType.getRole();
                final CollectionPersister collectionPersister = metamodel.getCollectionDescriptor( role );
                if ( collectionPersister.hasCache() ) {
                    final CollectionDataAccess cache = collectionPersister.getCacheAccessStrategy();
                    final Object cacheKey = cache.generateCacheKey( id, collectionPersister, factory, tenantIdentifier );
                    final SoftLock lock = cache.lockItem( source, cacheKey, null );
                    cache.remove( source, cacheKey );
                    actionQueue.registerProcess(
                        (success, session) -> cache.unlockItem( session, cacheKey, lock )
                    );
                }
            }
            else if ( type.isComponentType() ) {
                final CompositeType compositeType = (CompositeType) type;
                Type[] subtypes = compositeType.getSubtypes();
                evictCachedCollections( subtypes, id, source );
            }
        }
    }
}
```

---

### **Summary of the Extract Variable Refactoring**
- Named intermediate values (e.g., variables for tenant ID, cache key, factory, roles, etc.).
- Extracted result of type casts and method chains used multiple times in a block.
- Used descriptive variable names to help identify what is being constructed (e.g., `cacheKey`, `actionQueue`, `info`, etc.).
- Broke down lambdas and chained calls for cache eviction for clarity.

**This should improve readability and ease future maintenance. If you notice further complex expressions specific to your team's coding standards needing lifting, similar extraction can be done throughout.**



FINISHED REFACTORING 1



Certainly! In the given code, there **are** several expressions and method calls that are candidates for *extract variable* refactoring. The most apparent improvements are:
- Long chained method calls used as arguments.
- Duplicated or overly verbose expressions passed to multiple locations.
- Complex conditional expressions or parameter lists.

Here are a few concrete examples from your code:
1. **Repeated Calls:** For example, expressions like `source.getFactory()` or `persister.getCacheAccessStrategy()` appear multiple times in close proximity.
2. **Chained Calls as Arguments:** For example, in methods like `evictCachedCollections` or `evictEntity`, there are long method chains used as parameters.
3. **Extract Sub-expressions for Readability:** Especially in blocks where the same calculation or request is done more than once.

I will perform *extract variable* refactorings in the appropriate places.
**Below is the whole refactored class:**

---

```java
package org.hibernate.event.internal;

import org.hibernate.HibernateException;
import org.hibernate.LockMode;
import org.hibernate.LockOptions;
import org.hibernate.NonUniqueObjectException;
import org.hibernate.TransientObjectException;
import org.hibernate.UnresolvableObjectException;
import org.hibernate.cache.spi.access.CollectionDataAccess;
import org.hibernate.cache.spi.access.EntityDataAccess;
import org.hibernate.cache.spi.access.SoftLock;
import org.hibernate.engine.internal.Cascade;
import org.hibernate.engine.internal.CascadePoint;
import org.hibernate.engine.spi.ActionQueue;
import org.hibernate.engine.spi.CascadingActions;
import org.hibernate.engine.spi.EntityEntry;
import org.hibernate.engine.spi.EntityKey;
import org.hibernate.engine.spi.PersistenceContext;
import org.hibernate.engine.spi.SessionFactoryImplementor;
import org.hibernate.event.spi.EventSource;
import org.hibernate.event.spi.RefreshContext;
import org.hibernate.event.spi.RefreshEvent;
import org.hibernate.event.spi.RefreshEventListener;
import org.hibernate.internal.CoreLogging;
import org.hibernate.internal.CoreMessageLogger;
import org.hibernate.loader.ast.spi.CascadingFetchProfile;
import org.hibernate.metamodel.spi.MappingMetamodelImplementor;
import org.hibernate.persister.collection.CollectionPersister;
import org.hibernate.persister.entity.EntityPersister;
import org.hibernate.proxy.HibernateProxy;
import org.hibernate.proxy.LazyInitializer;
import org.hibernate.type.CollectionType;
import org.hibernate.type.CompositeType;
import org.hibernate.type.Type;

import static org.hibernate.pretty.MessageHelper.infoString;

/**
 * Defines the default refresh event listener used by hibernate for refreshing entities
 * in response to generated refresh events.
 *
 * @author Steve Ebersole
 */
public class DefaultRefreshEventListener implements RefreshEventListener {
    private static final CoreMessageLogger LOG = CoreLogging.messageLogger(DefaultRefreshEventListener.class);

    public void onRefresh(RefreshEvent event) throws HibernateException {
        onRefresh(event, RefreshContext.create());
    }

    /**
     * Handle the given refresh event.
     *
     * @param event The refresh event to be handled.
     */
    public void onRefresh(RefreshEvent event, RefreshContext refreshedAlready) {
        final EventSource source = event.getSession();
        final PersistenceContext persistenceContext = source.getPersistenceContextInternal();
        final Object object = event.getObject();
        if (persistenceContext.reassociateIfUninitializedProxy(object)) {

            final LazyInitializer lazyInitializer = HibernateProxy.extractLazyInitializer(object);
            final String entityName = lazyInitializer.getEntityName();
            final EntityPersister persister = source.getEntityPersister(entityName, object);
            final Object identifier = persister.getIdentifier(object, event.getSession());

            refresh(
                    event,
                    null,
                    source,
                    persister,
                    lazyInitializer,
                    null,
                    identifier,
                    persistenceContext
            );

            if (isTransient(event, source, object)) {
                source.setReadOnly(object, source.isDefaultReadOnly());
            }
        } else {
            final Object entity = persistenceContext.unproxyAndReassociate(object);
            if (refreshedAlready.add(entity)) {
                refresh(event, refreshedAlready, entity);
            } else {
                LOG.trace("Already refreshed");
            }
        }
    }

    private static boolean isTransient(RefreshEvent event, EventSource source, Object object) {
        final String entityName = event.getEntityName();
        return entityName != null ? !source.contains(entityName, object) : !source.contains(object);
    }

    private static void refresh(RefreshEvent event, RefreshContext refreshedAlready, Object object) {
        final EventSource source = event.getSession();
        final PersistenceContext persistenceContext = source.getPersistenceContextInternal();
        final EntityEntry entry = persistenceContext.getEntry(object);

        final EntityPersister persister;
        final Object id;
        if (entry == null) {
            //refresh() does not pass an entityName
            final String eventEntityName = event.getEntityName();
            persister = source.getEntityPersister(eventEntityName, object);
            id = persister.getIdentifier(object, event.getSession());

            if (id == null) {
                throw new TransientObjectException("transient instance passed to refresh");
            }
            if (LOG.isTraceEnabled()) {
                final String info = infoString(persister, id, source.getFactory());
                LOG.tracev("Refreshing transient {0}", info);
            }
            final EntityKey generatedKey = source.generateEntityKey(id, persister);
            if (persistenceContext.getEntry(generatedKey) != null) {
                throw new NonUniqueObjectException(id, persister.getEntityName());
            }
        } else {
            if (LOG.isTraceEnabled()) {
                final String info = infoString(entry.getPersister(), entry.getId(), source.getFactory());
                LOG.tracev("Refreshing ", info);
            }
            if (!entry.isExistsInDatabase()) {
                throw new UnresolvableObjectException(
                        entry.getId(),
                        "this instance does not yet exist as a row in the database"
                );
            }
            persister = entry.getPersister();
            id = entry.getId();
        }

        // cascade the refresh prior to refreshing this entity
        Cascade.cascade(
                CascadingActions.REFRESH,
                CascadePoint.BEFORE_REFRESH,
                source,
                persister,
                object,
                refreshedAlready
        );

        if (entry != null) {
            final EntityKey key = source.generateEntityKey(id, persister);
            persistenceContext.removeEntity(key);
            if (persister.hasCollections()) {
                new EvictVisitor(source, object).process(object, persister);
            }
        }

        evictEntity(object, persister, id, source);
        evictCachedCollections(persister, id, source);

        refresh(event, object, source, persister, null, entry, id, persistenceContext);
    }

    private static void refresh(
            RefreshEvent event,
            Object object,
            EventSource source,
            EntityPersister persister,
            LazyInitializer lazyInitializer,
            EntityEntry entry,
            Object id,
            PersistenceContext persistenceContext) {

        final Object result = source.getLoadQueryInfluencers().fromInternalFetchProfile(
                CascadingFetchProfile.REFRESH,
                () -> doRefresh(event, source, object, entry, persister, lazyInitializer, id, persistenceContext)
        );
        final String entityName = persister.getEntityName();
        UnresolvableObjectException.throwIfNull(result, id, entityName);
    }

    private static void evictEntity(Object object, EntityPersister persister, Object id, EventSource source) {
        if (persister.canWriteToCache()) {
            Object previousVersion = null;
            if (persister.isVersionPropertyGenerated()) {
                // we need to grab the version value from the entity, otherwise
                // we have issues with generated-version entities that may have
                // multiple actions queued during the same flush
                previousVersion = persister.getVersion(object);
            }

            final EntityDataAccess cache = persister.getCacheAccessStrategy();
            final SessionFactoryImplementor factory = source.getFactory();
            final String tenantIdentifier = source.getTenantIdentifier();
            final Object ck = cache.generateCacheKey(id, persister, factory, tenantIdentifier);

            final SoftLock lock = cache.lockItem(source, ck, previousVersion);
            cache.remove(source, ck);
            final ActionQueue actionQueue = source.getActionQueue();
            actionQueue.registerProcess((success, session) -> cache.unlockItem(session, ck, lock));
        }
    }

    private static Object doRefresh(
            RefreshEvent event,
            EventSource source,
            Object object,
            EntityEntry entry,
            EntityPersister persister,
            LazyInitializer lazyInitializer,
            Object id,
            PersistenceContext persistenceContext) {
        // Handle the requested lock-mode (if one) in relation to the entry's (if one) current lock-mode
        LockOptions lockOptionsToUse = event.getLockOptions();
        final LockMode requestedLockMode = lockOptionsToUse.getLockMode();
        final LockMode postRefreshLockMode;
        if (entry != null) {
            final LockMode currentLockMode = entry.getLockMode();
            if (currentLockMode.greaterThan(requestedLockMode)) {
                // the requested lock-mode is less restrictive than the current one
                // - pass along the current lock-mode (after accounting for WRITE)
                lockOptionsToUse = event.getLockOptions().makeCopy();
                if (currentLockMode == LockMode.WRITE
                        || currentLockMode == LockMode.PESSIMISTIC_WRITE
                        || currentLockMode == LockMode.PESSIMISTIC_READ) {
                    // our transaction should already hold the exclusive lock on
                    // the underlying row - so READ should be sufficient.
                    //
                    // in fact, this really holds true for any current lock-mode that indicates we
                    // hold an exclusive lock on the underlying row - but we *need* to handle
                    // WRITE specially because the Loader/Locker mechanism does not allow for WRITE
                    // locks
                    lockOptionsToUse.setLockMode(LockMode.READ);
                    // and prepare to reset the entry lock-mode to the previous lock mode after
                    // the refresh completes
                    postRefreshLockMode = currentLockMode;
                } else {
                    lockOptionsToUse.setLockMode(currentLockMode);
                    postRefreshLockMode = null;
                }
            } else {
                postRefreshLockMode = null;
            }
        } else {
            postRefreshLockMode = null;
        }

        final Object result = persister.load(id, object, lockOptionsToUse, source);
        if (result != null) {
            // apply `postRefreshLockMode`, if needed
            if (postRefreshLockMode != null) {
                // if we get here, there was a previous entry, and we need to re-set its lock-mode
                //		- however, the refresh operation actually creates a new entry, so get it
                final EntityEntry refreshedEntry = persistenceContext.getEntry(result);
                refreshedEntry.setLockMode(postRefreshLockMode);
            }

            final boolean readOnly = isReadOnly(entry, persister, lazyInitializer, source);
            source.setReadOnly(result, readOnly);
        }
        return result;
    }

    private static boolean isReadOnly(
            EntityEntry entry,
            EntityPersister persister,
            LazyInitializer lazyInitializer,
            EventSource source) {
        // Keep the same read-only/modifiable setting for the entity that it had before refreshing;
        // If it was transient, then set it to the default for the source.
        if (!persister.isMutable()) {
            return true;
        } else if (entry != null) {
            return entry.isReadOnly();
        } else if (lazyInitializer != null) {
            return lazyInitializer.isReadOnly();
        } else {
            return source.isDefaultReadOnly();
        }
    }

    private static void evictCachedCollections(EntityPersister persister, Object id, EventSource source) {
        final Type[] propertyTypes = persister.getPropertyTypes();
        evictCachedCollections(propertyTypes, id, source);
    }

    private static void evictCachedCollections(Type[] types, Object id, EventSource source)
            throws HibernateException {
        final ActionQueue actionQueue = source.getActionQueue();
        final SessionFactoryImplementor factory = source.getFactory();
        final String tenantIdentifier = source.getTenantIdentifier();
        final MappingMetamodelImplementor metamodel = factory.getRuntimeMetamodels().getMappingMetamodel();

        for (Type type : types) {
            if (type.isCollectionType()) {
                final CollectionType collectionType = (CollectionType) type;
                final String role = collectionType.getRole();
                final CollectionPersister collectionPersister = metamodel.getCollectionDescriptor(role);
                if (collectionPersister.hasCache()) {
                    final CollectionDataAccess cache = collectionPersister.getCacheAccessStrategy();
                    final Object ck = cache.generateCacheKey(id, collectionPersister, factory, tenantIdentifier);
                    final SoftLock lock = cache.lockItem(source, ck, null);
                    cache.remove(source, ck);
                    actionQueue.registerProcess((success, session) -> cache.unlockItem(session, ck, lock));
                }
            } else if (type.isComponentType()) {
                final CompositeType compositeType = (CompositeType) type;
                final Type[] subtypes = compositeType.getSubtypes();
                evictCachedCollections(subtypes, id, source);
            }
        }
    }
}
```

---

**Summary of Extract Variable Refactorings Applied:**
- Method call results reused in a scope are now saved as local variables, e.g.:
    - `source.getFactory()`, `source.getTenantIdentifier()`, `persister.getCacheAccessStrategy()`
    - `persister.getPropertyTypes()`, etc.
    - Arguments such as `persister.getIdentifier(object, event.getSession())` now extracted.
- Conditional sub-expressions (e.g. `postRefreshLockMode`) introduced as variables for clarity.
- Avoided duplicating chained calls in tight blocks.
- Consistently named variables according to their content.
- Improved maintainability and readability.

**Let me know if you want even more aggressive refactoring or additional comments on any block!**
