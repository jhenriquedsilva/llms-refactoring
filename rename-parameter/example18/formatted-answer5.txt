package org.apache.solr.client.solrj.impl;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.TimeUnit;

import org.apache.solr.client.solrj.ResponseParser;
import org.apache.solr.client.solrj.impl.SolrZkClientTimeout.SolrZkClientTimeoutAware;
import org.apache.solr.client.solrj.request.RequestWriter;
import org.apache.solr.client.solrj.request.UpdateRequest;
import org.apache.solr.common.SolrException;

@SuppressWarnings("serial")
public class CloudHttp2SolrClient extends CloudSolrClient {

    private final ClusterStateProvider stateProvider;
    private final LBHttp2SolrClient lbClient;
    private final Http2SolrClient myClient;
    private final boolean clientIsInternal;

    protected CloudHttp2SolrClient(Builder builder) {
        super(builder.shardLeadersOnly, builder.parallelUpdates, builder.directUpdatesToLeadersOnly);
        if (builder.httpClient == null) {
            this.clientIsInternal = true;
            if (builder.internalHttpClientBuilder == null) {
                this.myClient = new Http2SolrClient.Builder().build();
            } else {
                this.myClient = builder.internalHttpClientBuilder.build();
            }
        } else {
            this.clientIsInternal = false;
            this.myClient = builder.httpClient;
        }
        this.retryExpiryTimeNano = builder.retryExpiryTimeNano;
        this.defaultCollection = builder.defaultCollectionName;
        if (builder.requestWriter != null) {
            this.myClient.requestWriter = builder.requestWriter;
        }
        if (builder.responseParser != null) {
            this.myClient.setParser(builder.responseParser);
        }
        this.stateProvider = builder.stateProvider;
        this.collectionStateCache.timeToLiveMs = TimeUnit.MILLISECONDS.convert(builder.cacheTtlSeconds, TimeUnit.SECONDS);
        this.locks = objectList(builder.cacheRefreshLockCount);
        this.lbClient = new LBHttp2SolrClient.Builder(myClient).build();
    }

    @Override
    public void close() throws IOException {
        stateProvider.close();
        lbClient.close();
        if (clientIsInternal && myClient != null) {
            myClient.close();
        }
        super.close();
    }

    @Override
    public LBHttp2SolrClient getLbClient() {
        return lbClient;
    }

    @Override
    public ClusterStateProvider getClusterStateProvider() {
        return stateProvider;
    }

    public Http2SolrClient getHttpClient() {
        return myClient;
    }

    @Override
    protected boolean wasCommError(Throwable rootCause) {
        return false;
    }

    public static class Builder {
        protected Collection<String> zkHostList = new ArrayList<>();
        protected List<String> solrBaseUrls = new ArrayList<>();
        protected String zkChrootPath;
        protected Http2SolrClient httpClient;
        protected boolean shardLeadersOnly = true;
        protected boolean directUpdatesToLeadersOnly = false;
        protected boolean parallelUpdates = true;
        protected ClusterStateProvider stateProvider;
        protected Http2SolrClient.Builder internalHttpClientBuilder;
        private RequestWriter requestWriter;
        private ResponseParser responseParser;
        private long retryExpiryTimeNano = TimeUnit.NANOSECONDS.convert(3, TimeUnit.SECONDS);
        private String defaultCollectionName;
        private long cacheTtlSeconds = 60;
        private int cacheRefreshLockCount = 3;
        private int zkConnectTimeout = SolrZkClientTimeout.DEFAULT_ZK_CONNECT_TIMEOUT;
        private int zkClientTimeout = SolrZkClientTimeout.DEFAULT_ZK_CLIENT_TIMEOUT;
        private boolean canUseZkACLs = true;

        public Builder(List<String> solrBaseUrls) {
            this.solrBaseUrls = solrBaseUrls;
        }

        public Builder(List<String> zkHostList, Optional<String> zkChrootPath) {
            this.zkHostList = zkHostList;
            if (zkChrootPath.isPresent()) this.zkChrootPath = zkChrootPath.get();
        }

        public Builder canUseZkACLs(boolean canUseZkACLs) {
            this.canUseZkACLs = canUseZkACLs;
            return this;
        }

        public Builder sendUpdatesOnlyToShardLeaders() {
            shardLeadersOnly = true;
            return this;
        }

        public Builder sendUpdatesToAnyReplica() {
            shardLeadersOnly = false;
            return this;
        }

        public Builder sendDirectUpdatesToShardLeadersOnly() {
            directUpdatesToLeadersOnly = true;
            return this;
        }

        public Builder sendDirectUpdatesToAnyShardReplica() {
            directUpdatesToLeadersOnly = false;
            return this;
        }

        public Builder withRequestWriter(RequestWriter requestWriter) {
            this.requestWriter = requestWriter;
            return this;
        }

        public Builder withResponseParser(ResponseParser responseParser) {
            this.responseParser = responseParser;
            return this;
        }

        public Builder withParallelUpdates(boolean parallelUpdates) {
            this.parallelUpdates = parallelUpdates;
            return this;
        }

        @Deprecated(since = "9.2")
        public Builder setParallelCacheRefreshes(int cacheRefreshLockCount) {
            this.withParallelCacheRefreshes(cacheRefreshLockCount);
            return this;
        }

        public Builder withParallelCacheRefreshes(int cacheRefreshLockCount) {
            this.cacheRefreshLockCount = cacheRefreshLockCount;
            return this;
        }

        @Deprecated(since = "9.2")
        public Builder setRetryExpiryTime(int duration, TimeUnit timeUnit) {
            this.withRetryExpiryTime(duration, timeUnit);
            return this;
        }

        public Builder withRetryExpiryTime(long duration, TimeUnit timeUnit) {
            this.retryExpiryTimeNano = TimeUnit.NANOSECONDS.convert(duration, timeUnit);
            return this;
        }

        public Builder withDefaultCollection(String defaultCollectionName) {
            this.defaultCollectionName = defaultCollectionName;
            return this;
        }

        @Deprecated(since = "9.2")
        public Builder withCollectionCacheTtl(int cacheTtlSeconds) {
            withCollectionCacheTtl(cacheTtlSeconds, TimeUnit.SECONDS);
            return this;
        }

        public Builder withCollectionCacheTtl(long cacheTtl, TimeUnit timeUnit) {
            assert cacheTtl > 0;
            this.cacheTtlSeconds = TimeUnit.SECONDS.convert(cacheTtl, timeUnit);
            return this;
        }

        public Builder withHttpClient(Http2SolrClient httpClient) {
            if (this.internalHttpClientBuilder != null) {
                throw new IllegalStateException("The builder can't accept an httpClient AND an internalHttpClientBuilder, only one of those can be provided");
            }
            this.httpClient = httpClient;
            return this;
        }

        public Builder withInternalClientBuilder(Http2SolrClient.Builder internalHttpClientBuilder) {
            if (this.httpClient != null) {
                throw new IllegalStateException("The builder can't accept an httpClient AND an internalHttpClientBuilder, only one of those can be provided");
            }
            this.internalHttpClientBuilder = internalHttpClientBuilder;
            return this;
        }

        public Builder withZkConnectTimeout(int zkConnectTimeout, TimeUnit timeUnit) {
            this.zkConnectTimeout = Math.toIntExact(timeUnit.toMillis(zkConnectTimeout));
            return this;
        }

        public Builder withZkClientTimeout(int zkClientTimeout, TimeUnit timeUnit) {
            this.zkClientTimeout = Math.toIntExact(timeUnit.toMillis(zkClientTimeout));
            return this;
        }

        public CloudHttp2SolrClient build() {
            if (stateProvider == null) {
                if (!zkHostList.isEmpty() && !solrBaseUrls.isEmpty()) {
                    throw new IllegalArgumentException("Both zkHost(s) & solrUrl(s) have been specified. Only specify one.");
                } else if (!zkHostList.isEmpty()) {
                    stateProvider = ClusterStateProvider.newZkClusterStateProvider(zkHostList, zkChrootPath, canUseZkACLs);
                    if (stateProvider instanceof SolrZkClientTimeoutAware) {
                        var timeoutAware = (SolrZkClientTimeoutAware) stateProvider;
                        timeoutAware.setZkClientTimeout(zkClientTimeout);
                        timeoutAware.setZkConnectTimeout(zkConnectTimeout);
                    }
                } else if (!solrBaseUrls.isEmpty()) {
                    try {
                        stateProvider = new Http2ClusterStateProvider(solrBaseUrls, httpClient);
                    } catch (Exception e) {
                        throw new RuntimeException("Couldn't initialize a HttpClusterStateProvider (is/are the " + "Solr server(s), " + solrBaseUrls + ", down?)", e);
                    }
                } else {
                    throw new IllegalArgumentException("Both zkHostList and solrBaseUrls cannot be null.");
                }
            }
            return new CloudHttp2SolrClient(this);
        }
    }
}