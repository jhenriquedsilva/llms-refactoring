27-05-2025, 21:10

**Yes, there are clear extract method refactoring opportunities** in the provided code. Particularly, the following blocks can be extracted into descriptive, reusable private methods:

- The repetitive registration/creation of test source tables with sample data.
- The repetitive creation of sink tables.
- The repetitive modification of the JSON plan within lambdas to set state TTL per operator.
- The complex, multi-step preparations in each test, such as data, table setup, and test execution.

Below is the **refactored class** with these improvements, with all code otherwise unchanged. The refactorings are marked in the code as comments for clarity.

---

```java
package org.apache.flink.table.planner.runtime.stream.jsonplan;

import org.apache.flink.table.api.TableException;
import org.apache.flink.table.data.GenericRowData;
import org.apache.flink.table.data.StringData;
import org.apache.flink.table.planner.factories.TestValuesTableFactory;
import org.apache.flink.table.planner.utils.JsonPlanTestBase;
import org.apache.flink.table.planner.utils.JsonTestUtils;

import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;

import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;

/**
 * Tests for configuring operator-level state TTL via {@link
 * org.apache.flink.table.api.CompiledPlan}.
 */
class ConfigureOperatorLevelStateTtlJsonITCase extends JsonPlanTestBase {

    @Test
    void testDifferentStateTtlForDifferentOneInputOperator() throws Exception {
        String dataId = registerOrdersTableWithSampleData();
        createTestNonInsertOnlyValuesSinkTable(
                "OrdersStats",
                "`buyer` STRING",
                "`ord_cnt` BIGINT",
                "`quantity_cnt` BIGINT",
                "`total_amount` DOUBLE");
        compileSqlAndExecutePlan("INSERT INTO OrdersStats "
                        + "SELECT buyer, COUNT(1) AS ord_cnt, SUM(quantity) AS quantity_cnt, SUM(amount) AS total_amount FROM ("
                        + "SELECT *, ROW_NUMBER() OVER(PARTITION BY order_id, buyer, quantity, amount ORDER BY proctime() ASC) AS rk FROM Orders) tmp "
                        + "WHERE rk = 1 "
                        + "GROUP BY buyer",
                addStateMetadataForAggregateAndDeduplicate()
        ).await();

        List<String> expected =
                Arrays.asList(
                        "+I[Tom, 2, 2, 229.8]",
                        "+I[Jerry, 1, 2, 99.9]",
                        "+I[Jerry, 1, 2, 99.9]",
                        "+I[Olivia, 2, 4, 1100.0]",
                        "+I[Michael, 1, 3, 599.9]");
        assertResult(expected, TestValuesTableFactory.getResultsAsStrings("OrdersStats"));
    }

    @Test
    void testDifferentStateTtlForSameTwoInputStreamOperator() throws Exception {
        innerTestRegularJoin(
                "INSERT INTO OrdersShipInfo "
                        + "SELECT a.order_id, a.line_order_id, b.ship_mode FROM Orders a JOIN LineOrders b ON a.line_order_id = b.line_order_id",
                addJoinOperatorStateMetadata());
    }

    @Test
    void testDifferentStateTtlThroughSqlHintForSameTwoInputStreamOperator() throws Exception {
        innerTestRegularJoin(
                "INSERT INTO OrdersShipInfo "
                        + "SELECT /*+ STATE_TTL('a' = '3s', 'b' = '9s') */ "
                        + " a.order_id, a.line_order_id, b.ship_mode "
                        + "FROM Orders a JOIN LineOrders b ON a.line_order_id = b.line_order_id",
                json -> json);
    }

    private void innerTestRegularJoin(String sql, Function<String, String> jsonPlanTransformer)
            throws Exception {
        String leftTableDataId = registerOrdersLeftTable();
        String rightTableDataId = registerLineOrdersTable();
        createTestValuesSinkTable(
                "OrdersShipInfo", "`order_id` INT", "`line_order_id` INT", "`ship_mode` STRING");
        compileSqlAndExecutePlan(sql, jsonPlanTransformer).await();

        List<String> expected =
                Arrays.asList(
                        "+I[1, 1000002, TRUCK]", "+I[1, 1000004, RAIL]", "+I[1, 1000005, AIR]");
        assertResult(expected, TestValuesTableFactory.getResultsAsStrings("OrdersShipInfo"));
    }

    private static Map<String, String> getProperties(
            String dataId, int sleepAfterElements, String sleepTime) {
        return new HashMap<String, String>() {
            {
                put("connector", "values");
                put("bounded", "false");
                put("register-internal-data", "true");
                put("source.sleep-after-elements", String.valueOf(sleepAfterElements));
                put("source.sleep-time", sleepTime);
                put("data-id", dataId);
            }
        };
    }

    // ------ Refactored: extracted methods below ------

    /** Registers the Orders table used in the first test, returns dataId. */
    private String registerOrdersTableWithSampleData() {
        List<GenericRowData> orders = Arrays.asList(
                GenericRowData.of(1, StringData.fromString("Tom"), 1, 199.9d),
                GenericRowData.of(2, StringData.fromString("Jerry"), 2, 99.9d),
                GenericRowData.of(1, StringData.fromString("Tom"), 1, 199.9d),
                GenericRowData.of(3, StringData.fromString("Tom"), 1, 29.9d),
                GenericRowData.of(4, StringData.fromString("Olivia"), 1, 100d),
                GenericRowData.of(4, StringData.fromString("Olivia"), 1, 100d),
                GenericRowData.of(2, StringData.fromString("Jerry"), 2, 99.9d),
                GenericRowData.of(5, StringData.fromString("Michael"), 3, 599.9d),
                GenericRowData.of(6, StringData.fromString("Olivia"), 3, 1000d));
        String dataId = TestValuesTableFactory.registerRowData(orders);
        createTestSourceTable(
                "Orders",
                new String[] {
                        "`order_id` INT", "`buyer` STRING", "`quantity` INT", "`amount` DOUBLE"
                },
                null,
                getProperties(dataId, 1, "2s"));
        return dataId;
    }

    /** Registers the left "Orders" table for join tests, returns dataId. */
    private String registerOrdersLeftTable() {
        List<GenericRowData> leftTable = Arrays.asList(
                GenericRowData.of(1, 1000001),
                GenericRowData.of(1, 1000002),
                GenericRowData.of(1, 1000003),
                GenericRowData.of(1, 1000004),
                GenericRowData.of(1, 1000005),
                GenericRowData.of(2, 2000001));
        String dataId = TestValuesTableFactory.registerRowData(leftTable);
        createTestSourceTable(
                "Orders",
                new String[] {"`order_id` INT", "`line_order_id` INT"},
                null,
                getProperties(dataId, 1, "2s"));
        return dataId;
    }

    /** Registers the right "LineOrders" table for join tests, returns dataId. */
    private String registerLineOrdersTable() {
        List<GenericRowData> rightTable = Arrays.asList(
                GenericRowData.of(2000001, StringData.fromString("TRUCK")),
                GenericRowData.of(1000005, StringData.fromString("AIR")),
                GenericRowData.of(1000001, StringData.fromString("SHIP")),
                GenericRowData.of(1000002, StringData.fromString("TRUCK")),
                GenericRowData.of(1000003, StringData.fromString("RAIL")),
                GenericRowData.of(1000004, StringData.fromString("RAIL")));
        String dataId = TestValuesTableFactory.registerRowData(rightTable);
        createTestSourceTable(
                "LineOrders",
                new String[] {"`line_order_id` INT", "`ship_mode` STRING"},
                null,
                getProperties(dataId, 2, "4s"));
        return dataId;
    }

    /** Returns a JSON plan transformer that adds deduplicate/group-aggregate TTL. */
    private static Function<String, String> addStateMetadataForAggregateAndDeduplicate() {
        return (Function<String, String>) json -> {
            try {
                JsonNode target = JsonTestUtils.readFromString(json);
                JsonTestUtils.setExecNodeStateMetadata(
                        target, "stream-exec-deduplicate", 0, 6000L);
                JsonTestUtils.setExecNodeStateMetadata(
                        target, "stream-exec-group-aggregate", 0, 9000L);
                return JsonTestUtils.writeToString(target);
            } catch (IOException e) {
                throw new TableException("Cannot modify compiled json plan.", e);
            }
        };
    }

    /** Returns a JSON plan transformer that sets left/right input TTL for join. */
    private static Function<String, String> addJoinOperatorStateMetadata() {
        return json -> {
            try {
                JsonNode target = JsonTestUtils.readFromString(json);
                JsonTestUtils.setExecNodeStateMetadata(
                        target, "stream-exec-join", 0, 3000L);
                JsonTestUtils.setExecNodeStateMetadata(
                        target, "stream-exec-join", 1, 9000L);
                return JsonTestUtils.writeToString(target);
            } catch (IOException e) {
                throw new TableException("Cannot modify compiled json plan.", e);
            }
        };
    }

}
```

---

**Summary of improvements**:

- Large data registration + table creation blocks are extracted with intention-revealing names.
- The JSON plan transformation lambdas are extracted into named methods for clarity and reuse.
- Test methods are now shorter and their intent clearer, delegating detail work.
- No functional change.

**This style will help long-term maintainability, readability, and test extensibility.**

Levenshtein edit-distance: 6704
Compiles
Tests pass