01-05-2025, 11:34

There **are** opportunities for rename parameter refactoring in this code, mainly to improve the clarity and expressiveness of certain parameters that currently have generic or ambiguous names like `files`, `fileToCheck`, `ref`, etc. Here is a list of recommended parameter renamings to boost readability and understanding of the code:

**Summary of rename opportunities:**

| Old Name         | New Name                           | Context                                 |
|------------------|------------------------------------|-----------------------------------------|
| `files`          | `virtualFiles`                     | Method/Class parameters with VirtualFile|
| `ref`            | `entityPointer`                    | In map2MapNotNull (pointer set)         |
| `fileToCheck`    | `filesToCheck`                     | In collectAndRemove, collectAndRemoveFilesUnder |
| `reference`      | `entityPointer`                    | In findPresentation                     |
| `roots`          | `rootFiles`                        | In collectAndRemoveFilesUnder           |
| `next`           | `file`                             | In collectAndRemove                     |
| `filesFromLibs`  | `libraryRootFiles`                 | Variable in createBuildersFromFilesFromAdditionalLibraryRootsProviders |

Below is the **refactored full class** implementing the parameter renaming consistently.

---

```java
package com.intellij.util.indexing;

import com.intellij.navigation.ItemPresentation;
import com.intellij.openapi.application.ReadAction;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.module.Module;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.projectRoots.Sdk;
import com.intellij.openapi.roots.AdditionalLibraryRootsProvider;
import com.intellij.openapi.roots.SyntheticLibrary;
import com.intellij.openapi.util.Pair;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.openapi.vfs.VfsUtilCore;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.platform.backend.workspace.WorkspaceModel;
import com.intellij.platform.workspace.jps.entities.LibraryId;
import com.intellij.platform.workspace.jps.entities.ModuleId;
import com.intellij.platform.workspace.storage.EntityPointer;
import com.intellij.platform.workspace.storage.EntityStorage;
import com.intellij.platform.workspace.storage.WorkspaceEntity;
import com.intellij.platform.backend.workspace.VirtualFileUrls;
import com.intellij.platform.workspace.storage.url.VirtualFileUrl;
import com.intellij.platform.workspace.storage.url.VirtualFileUrlManager;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.util.containers.MultiMap;
import com.intellij.util.indexing.roots.IndexableIteratorPresentation;
import com.intellij.util.indexing.roots.builders.IndexableIteratorBuilders;
import com.intellij.util.indexing.roots.builders.IndexableSetContributorFilesIteratorBuilder;
import com.intellij.util.indexing.roots.builders.SyntheticLibraryIteratorBuilder;
import com.intellij.util.indexing.roots.origin.IndexingUrlRootHolder;
import com.intellij.util.indexing.roots.origin.IndexingUrlSourceRootHolder;
import com.intellij.workspaceModel.core.fileIndex.WorkspaceFileIndex;
import com.intellij.workspaceModel.core.fileIndex.WorkspaceFileKind;
import com.intellij.workspaceModel.core.fileIndex.WorkspaceFileSet;
import com.intellij.workspaceModel.core.fileIndex.impl.WorkspaceFileIndexImpl;
import com.intellij.workspaceModel.core.fileIndex.impl.WorkspaceFileSetRecognizer;
import com.intellij.workspaceModel.ide.legacyBridge.ModuleBridge;
import org.jetbrains.annotations.ApiStatus;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.*;
import java.util.function.Predicate;

import static com.intellij.util.indexing.roots.IndexableEntityProvider.IndexableIteratorBuilder;

@ApiStatus.Experimental
public final class ReincludedRootsUtil {
    private static final Logger LOG = Logger.getInstance(ReincludedRootsUtil.class);

    private ReincludedRootsUtil() {
    }

    @NotNull
    public static Collection<IndexableIteratorBuilder> createBuildersForReincludedFiles(@NotNull Project project,
                                                                                        @NotNull Collection<VirtualFile> reincludedRoots) {
        if (reincludedRoots.isEmpty()) return Collections.emptyList();
        return classifyFiles(project, reincludedRoots).createAllBuilders(project);
    }

    public interface Classifier {
        @NotNull
        Collection<VirtualFile> getFilesFromAdditionalLibraryRootsProviders();

        /**
         * All SDKs and Libraries included
         */
        @NotNull
        Collection<IndexableIteratorBuilder> createBuildersFromWorkspaceFiles();

        Collection<IndexableIteratorBuilder> createBuildersFromFilesFromIndexableSetContributors(@NotNull Project project);

        @NotNull
        Collection<IndexableIteratorBuilder> createAllBuilders(@NotNull Project project);
    }

    @NotNull
    public static Classifier classifyFiles(@NotNull Project project,
                                           @NotNull Collection<VirtualFile> virtualFiles) {
        return new CustomizableRootsBuilder(project, virtualFiles);
    }

    private static final class CustomizableRootsBuilder implements Classifier {
        private final @NotNull EntityStorage entityStorage;
        private final Set<EntityPointer<?>> pointers = new HashSet<>();
        private final List<ModuleRootData<?>> filesFromModulesContent = new ArrayList<>();
        private final List<ContentRootData<?>> filesFromContent = new ArrayList<>();
        private final List<ExternalRootData<?>> filesFromExternal = new ArrayList<>();
        private final List<CustomKindRootData<?>> filesFromCustomKind = new ArrayList<>();
        private final MultiMap<Sdk, VirtualFile> filesFromSdks = MultiMap.createSet();
        private final MultiMap<LibraryId, VirtualFile> sourceFilesFromLibraries = MultiMap.createSet();
        private final MultiMap<LibraryId, VirtualFile> classFilesFromLibraries = MultiMap.createSet();
        private final List<VirtualFile> filesFromIndexableSetContributors = new ArrayList<>();
        private final List<VirtualFile> filesFromAdditionalLibraryRootsProviders = new ArrayList<>();

        private CustomizableRootsBuilder(@NotNull Project project, @NotNull Collection<VirtualFile> virtualFiles) {
            entityStorage = WorkspaceModel.getInstance(project).getEntityStorage().getCurrent();
            classifyFiles(project, virtualFiles);
        }

        @Override
        public @NotNull Collection<VirtualFile> getFilesFromAdditionalLibraryRootsProviders() {
            return filesFromAdditionalLibraryRootsProviders;
        }

        void classifyFiles(@NotNull Project project, @NotNull Collection<VirtualFile> virtualFiles) {
            WorkspaceFileIndex workspaceFileIndex = WorkspaceFileIndex.getInstance(project);
            VirtualFileUrlManager fileUrlManager = VirtualFileUrls.getVirtualFileUrlManager(project);
            for (VirtualFile file : virtualFiles) {
                WorkspaceFileSet fileSet = ReadAction.nonBlocking(() -> {
                    return workspaceFileIndex.findFileSet(file, true, true, true, true, true);
                }).expireWith(project).executeSynchronously();

                if (fileSet == null) {
                    filesFromIndexableSetContributors.add(file);
                    continue;
                }

                EntityPointer<?> entityPointer = WorkspaceFileSetRecognizer.INSTANCE.getEntityPointer(fileSet);

                if (fileSet.getKind() == WorkspaceFileKind.CONTENT || fileSet.getKind() == WorkspaceFileKind.TEST_CONTENT) {
                    LOG.assertTrue(entityPointer != null, "Content element's fileSet without entity reference, " + fileSet);
                    Module module = WorkspaceFileSetRecognizer.INSTANCE.getModuleForContent(fileSet);
                    VirtualFileUrl url = VirtualFileUrls.toVirtualFileUrl(file, fileUrlManager);
                    if (module != null) {
                        addModuleRoot(module, entityPointer, url);
                    }
                    else {
                        addContentRoot(entityPointer, url);
                    }
                    continue;
                }

                //here we have WorkspaceFileKind.EXTERNAL or WorkspaceFileKind.EXTERNAL_SOURCE
                Sdk sdk = WorkspaceFileSetRecognizer.INSTANCE.getSdk(fileSet);
                if (sdk != null) {
                    addSdkFile(sdk, file);
                    continue;
                }

                if (WorkspaceFileSetRecognizer.INSTANCE.isFromAdditionalLibraryRootsProvider(fileSet)) {
                    filesFromAdditionalLibraryRootsProviders.add(file);
                    continue;
                }

                LibraryId libraryId = WorkspaceFileSetRecognizer.INSTANCE.getLibraryId(fileSet, entityStorage);
                if (libraryId != null) {
                    addLibraryFile(libraryId, file, fileSet.getKind() == WorkspaceFileKind.EXTERNAL_SOURCE);
                    continue;
                }

                LOG.assertTrue(entityPointer != null, "External element's fileSet without entity reference, " + fileSet);
                VirtualFileUrl url = VirtualFileUrls.toVirtualFileUrl(file, fileUrlManager);
                if (fileSet.getKind() == WorkspaceFileKind.EXTERNAL_SOURCE) {
                    addExternalRoots(entityPointer, Collections.emptyList(), Collections.singletonList(url));
                }
                else if (fileSet.getKind() == WorkspaceFileKind.EXTERNAL) {
                    addExternalRoots(entityPointer, Collections.singletonList(url), Collections.emptyList());
                }
                else {
                    addCustomKindRoot(entityPointer, url);
                }
            }
        }

        private void addModuleRoot(Module module, EntityPointer<?> entityPointer, VirtualFileUrl url) {
            filesFromModulesContent.add(new ModuleRootData<>(entityPointer, ((ModuleBridge)module).getModuleEntityId(), url));
            pointers.add(entityPointer);
        }

        private void addContentRoot(EntityPointer<?> entityPointer, VirtualFileUrl url) {
            filesFromContent.add(new ContentRootData<>(entityPointer, url));
            pointers.add(entityPointer);
        }

        private void addExternalRoots(EntityPointer<?> entityPointer, List<VirtualFileUrl> roots, List<VirtualFileUrl> sourceRoots) {
            filesFromExternal.add(new ExternalRootData<>(entityPointer, roots, sourceRoots));
            pointers.add(entityPointer);
        }

        private void addCustomKindRoot(EntityPointer<?> entityPointer, VirtualFileUrl fileUrl) {
            filesFromCustomKind.add(new CustomKindRootData<>(entityPointer, fileUrl));
            pointers.add(entityPointer);
        }

        private void addSdkFile(Sdk sdk, VirtualFile file) {
            filesFromSdks.putValue(sdk, file);
        }

        private void addLibraryFile(LibraryId id, VirtualFile file, boolean isSource) {
            if (isSource) {
                sourceFilesFromLibraries.putValue(id, file);
            }
            else {
                classFilesFromLibraries.putValue(id, file);
            }
        }

        private record ModuleRootData<E extends WorkspaceEntity>(@NotNull EntityPointer<E> entityPointer,
                                                                 @NotNull ModuleId moduleId,
                                                                 @NotNull VirtualFileUrl url) {
            private @NotNull Collection<IndexableIteratorBuilder> createBuilders(Map<EntityPointer<?>, WorkspaceEntity> entityPointerMap,
                                                                                 Map<Class<WorkspaceEntity>, CustomizingIndexingPresentationContributor<?>> contributorMap) {
                IndexableIteratorPresentation presentation = findPresentation(entityPointer, entityPointerMap, contributorMap);
                if (presentation == null) {
                    return IndexableIteratorBuilders.INSTANCE.forModuleRootsFileBased(moduleId, IndexingUrlRootHolder.Companion.fromUrl(url));
                }
                return IndexableIteratorBuilders.INSTANCE.forModuleAwareCustomizedContentEntity(moduleId,
                        entityPointer,
                        IndexingUrlRootHolder.Companion.fromUrl(url),
                        presentation);
            }
        }

        private record ContentRootData<E extends WorkspaceEntity>(@NotNull EntityPointer<E> entityPointer, @NotNull VirtualFileUrl url) {
            public @NotNull Collection<IndexableIteratorBuilder> createBuilders(Map<EntityPointer<?>, WorkspaceEntity> entityPointerMap,
                                                                                Map<Class<WorkspaceEntity>, CustomizingIndexingPresentationContributor<?>> contributorMap) {
                IndexableIteratorPresentation customization = findPresentation(entityPointer, entityPointerMap, contributorMap);
                return IndexableIteratorBuilders.INSTANCE.forGenericContentEntity(entityPointer, IndexingUrlRootHolder.Companion.fromUrl(url),
                        customization);
            }
        }

        private record ExternalRootData<E extends WorkspaceEntity>(@NotNull EntityPointer<E> entityPointer,
                                                                   @NotNull List<VirtualFileUrl> roots,
                                                                   @NotNull List<VirtualFileUrl> sourceRoots) {
            public @NotNull Collection<IndexableIteratorBuilder> createBuilders(Map<EntityPointer<?>, WorkspaceEntity> entityPointerMap,
                                                                                Map<Class<WorkspaceEntity>, CustomizingIndexingPresentationContributor<?>> contributorMap) {
                IndexableIteratorPresentation presentation = findPresentation(entityPointer, entityPointerMap, contributorMap);
                return IndexableIteratorBuilders.INSTANCE.forExternalEntity(entityPointer,
                        IndexingUrlSourceRootHolder.Companion.fromUrls(roots, sourceRoots),
                        presentation);
            }
        }

        private record CustomKindRootData<E extends WorkspaceEntity>(@NotNull EntityPointer<E> entityPointer,
                                                                     @NotNull VirtualFileUrl fileUrl) {
            public @NotNull Collection<IndexableIteratorBuilder> createBuilders(Map<EntityPointer<?>, WorkspaceEntity> entityPointerMap,
                                                                                Map<Class<WorkspaceEntity>, CustomizingIndexingPresentationContributor<?>> contributorMap) {
                IndexableIteratorPresentation customization = findPresentation(entityPointer, entityPointerMap, contributorMap);
                return IndexableIteratorBuilders.INSTANCE.forCustomKindEntity(entityPointer, IndexingUrlRootHolder.Companion.fromUrl(fileUrl),
                        customization);
            }
        }

        @Override
        @NotNull
        public Collection<IndexableIteratorBuilder> createBuildersFromWorkspaceFiles() {
            Map<EntityPointer<?>, WorkspaceEntity> entityPointerMap =
                    ContainerUtil.map2MapNotNull(pointers, entityPointer -> Pair.create(entityPointer, entityPointer.resolve(entityStorage)));

            Map<Class<WorkspaceEntity>, CustomizingIndexingPresentationContributor<?>> customizingContributorsMap =
                    ContainerUtil.map2MapNotNull(WorkspaceFileIndexImpl.Companion.getEP_NAME().getExtensionList(),
                            contributor -> {
                                if (contributor instanceof CustomizingIndexingPresentationContributor<?>) {
                                    return Pair.create( (Class<WorkspaceEntity>)contributor.getEntityClass(),
                                            (CustomizingIndexingPresentationContributor<?>)contributor);
                                }
                                return null;
                            });

            List<IndexableIteratorBuilder> result = new ArrayList<>();
            for (ModuleRootData<?> data : filesFromModulesContent) {
                result.addAll(data.createBuilders(entityPointerMap, customizingContributorsMap));
            }
            for (ContentRootData<?> data : filesFromContent) {
                result.addAll(data.createBuilders(entityPointerMap, customizingContributorsMap));
            }
            for (Map.Entry<LibraryId, Collection<VirtualFile>> entry : sourceFilesFromLibraries.entrySet()) {
                result.addAll(IndexableIteratorBuilders.INSTANCE.
                        forLibraryEntity(entry.getKey(), true, Collections.emptyList(), entry.getValue()));
            }
            for (Map.Entry<LibraryId, Collection<VirtualFile>> entry : classFilesFromLibraries.entrySet()) {
                result.addAll(IndexableIteratorBuilders.INSTANCE.
                        forLibraryEntity(entry.getKey(), true, entry.getValue(), Collections.emptyList()));
            }
            for (Map.Entry<Sdk, Collection<VirtualFile>> entry : filesFromSdks.entrySet()) {
                result.addAll(IndexableIteratorBuilders.INSTANCE.forSdk(entry.getKey(), entry.getValue()));
            }
            for (ExternalRootData<?> data : filesFromExternal) {
                result.addAll(data.createBuilders(entityPointerMap, customizingContributorsMap));
            }
            for (CustomKindRootData<?> data : filesFromCustomKind) {
                result.addAll(data.createBuilders(entityPointerMap, customizingContributorsMap));
            }
            return result;
        }

        @Override
        public Collection<IndexableIteratorBuilder> createBuildersFromFilesFromIndexableSetContributors(@NotNull Project project) {
            if (filesFromIndexableSetContributors.isEmpty()) {
                return Collections.emptyList();
            }
            List<IndexableIteratorBuilder> result = new ArrayList<>();
            for (IndexableSetContributor contributor : IndexableSetContributor.EP_NAME.getExtensionList()) {
                Set<VirtualFile> applicationRoots =
                        collectAndRemoveFilesUnder(filesFromIndexableSetContributors, contributor.getAdditionalRootsToIndex());
                Set<VirtualFile> projectRoots =
                        collectAndRemoveFilesUnder(filesFromIndexableSetContributors,
                                contributor.getAdditionalProjectRootsToIndex(project));

                if (!applicationRoots.isEmpty()) {
                    result.add(
                            new IndexableSetContributorFilesIteratorBuilder(null, contributor.getDebugName(), applicationRoots, false, contributor));
                }
                if (!projectRoots.isEmpty()) {
                    result.add(new IndexableSetContributorFilesIteratorBuilder(null, contributor.getDebugName(), projectRoots, true, contributor));
                }
                if (filesFromIndexableSetContributors.isEmpty()) {
                    break;
                }
            }
            return result;
        }

        @NotNull
        private Collection<IndexableIteratorBuilder> createBuildersFromFilesFromAdditionalLibraryRootsProviders(@NotNull Project project) {
            if (filesFromAdditionalLibraryRootsProviders.isEmpty()) return Collections.emptyList();
            List<IndexableIteratorBuilder> result = new ArrayList<>();
            List<VirtualFile> libraryRootFiles = new ArrayList<>(filesFromAdditionalLibraryRootsProviders);
            for (AdditionalLibraryRootsProvider provider : AdditionalLibraryRootsProvider.EP_NAME.getExtensionList()) {
                for (SyntheticLibrary library : provider.getAdditionalProjectLibraries(project)) {
                    Set<VirtualFile> roots = collectAndRemove(libraryRootFiles, file -> library.contains(file, true, true));
                    if (!roots.isEmpty()) {
                        String name = library instanceof ItemPresentation ? ((ItemPresentation)library).getPresentableText() : null;
                        result.add(new SyntheticLibraryIteratorBuilder(library, name, roots));
                    }
                    if (libraryRootFiles.isEmpty()) {
                        break;
                    }
                }
                if (libraryRootFiles.isEmpty()) {
                    break;
                }
            }

            if (!libraryRootFiles.isEmpty()) {
                LOG.error("Failed fo find any SyntheticLibrary roots for " + StringUtil.join(libraryRootFiles, "\n"));
            }
            return result;
        }

        @Override
        public @NotNull Collection<IndexableIteratorBuilder> createAllBuilders(@NotNull Project project) {
            List<IndexableIteratorBuilder> result = new ArrayList<>(createBuildersFromWorkspaceFiles());
            result.addAll(createBuildersFromFilesFromIndexableSetContributors(project));
            result.addAll(createBuildersFromFilesFromAdditionalLibraryRootsProviders(project));
            return result;
        }
    }

    @Nullable
    private static <E extends WorkspaceEntity> IndexableIteratorPresentation findPresentation(@NotNull EntityPointer<E> entityPointer,
                                                                                              @NotNull Map<EntityPointer<?>, WorkspaceEntity> entityPointerMap,
                                                                                              @NotNull Map<Class<WorkspaceEntity>, CustomizingIndexingPresentationContributor<?>> contributorMap) {
        E entity = (E)entityPointerMap.get(entityPointer);
        if (entity == null) {
            return null;
        }
        CustomizingIndexingPresentationContributor<E> contributor =
                (CustomizingIndexingPresentationContributor<E>)contributorMap.get(entity.getEntityInterface());
        return contributor == null ? null : contributor.customizeIteratorPresentation(entity);
    }

    @NotNull
    private static Set<VirtualFile> collectAndRemoveFilesUnder(Collection<VirtualFile> filesToCheck, Set<VirtualFile> rootFiles) {
        return collectAndRemove(filesToCheck, file -> VfsUtilCore.isUnder(file, rootFiles));
    }

    @NotNull
    private static Set<VirtualFile> collectAndRemove(@NotNull Collection<VirtualFile> filesToCheck,
                                                     @NotNull Predicate<VirtualFile> predicateToRemove) {
        Iterator<VirtualFile> iterator = filesToCheck.iterator();
        Set<VirtualFile> roots = new HashSet<>();
        while (iterator.hasNext()) {
            VirtualFile file = iterator.next();
            if (predicateToRemove.test(file)) {
                roots.add(file);
                iterator.remove();
            }
        }
        return roots;
    }
}
```

**Summary of changes:**

- `files` → `virtualFiles` when representing VirtualFile collections.
- `ref` → `entityPointer`
- `reference` → `entityPointer`
- `fileToCheck` → `filesToCheck`
- `roots` → `rootFiles` in the context of root directories/files.
- Variable in iterator loops: `next` → `file` for clarity.
- `filesFromLibs` → `libraryRootFiles`

Let me know if you also want to address other code style or readability issues!
