26-04-2025, 10:10

There **are** several opportunities for **Extract Method** refactoring in the `FileBasedConfig` class.
The methods **`load()`** and **`save()`** each contain blocks of logic which would benefit from being split into well-named private methods â€” improving readability, maintainability, and debuggability.

Below is the **fully refactored class**. The following were extracted:

- In `load()`:
  - **loadConfigFromFile(File f)**: Extracted from the lambda block for clarity.
  - **handleNoConfigFile()**: Handles logic if no config file is found.
  - **decodeAndParse(byte[] in, FileSnapshot newSnapshot, ObjectId newHash)**: Handles byte decoding and setting state.
  - **updateSnapshotIfUnchanged(FileSnapshot oldSnapshot, FileSnapshot newSnapshot)**: Handles the path where only the snapshot might be changed.

- In `save()`:
  - **encodeConfigText(String text)**: Handles text-to-byte conversion with possible BOM.
  - **writeConfigToLockFile(byte[] out)**: Handles the lock file writing and committing logic.

The new structure follows:

```java
package org.eclipse.jgit.storage.file;

import static java.nio.charset.StandardCharsets.UTF_8;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.text.MessageFormat;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import org.eclipse.jgit.errors.ConfigInvalidException;
import org.eclipse.jgit.errors.LockFailedException;
import org.eclipse.jgit.internal.JGitText;
import org.eclipse.jgit.internal.storage.file.FileSnapshot;
import org.eclipse.jgit.internal.storage.file.LockFile;
import org.eclipse.jgit.lib.Config;
import org.eclipse.jgit.lib.Constants;
import org.eclipse.jgit.lib.ObjectId;
import org.eclipse.jgit.lib.StoredConfig;
import org.eclipse.jgit.util.FS;
import org.eclipse.jgit.util.FileUtils;
import org.eclipse.jgit.util.IO;
import org.eclipse.jgit.util.RawParseUtils;

/**
 * The configuration file that is stored in the file of the file system.
 */
public class FileBasedConfig extends StoredConfig {

    private final File configFile;

    private final FS fs;

    // In-process synchronization between load() and save().
    private final ReentrantReadWriteLock lock;

    private boolean utf8Bom;

    private volatile FileSnapshot snapshot;

    private volatile ObjectId hash;

    private AtomicBoolean exists = new AtomicBoolean();

    public FileBasedConfig(File cfgLocation, FS fs) {
        this(null, cfgLocation, fs);
    }

    public FileBasedConfig(Config base, File cfgLocation, FS fs) {
        super(base);
        configFile = cfgLocation;
        this.fs = fs;
        this.snapshot = FileSnapshot.DIRTY;
        this.hash = ObjectId.zeroId();
        this.lock = new ReentrantReadWriteLock(false);
    }

    @Override
    protected boolean notifyUponTransientChanges() {
        return false;
    }

    public final File getFile() {
        return configFile;
    }

    boolean exists() {
        return exists.get();
    }

    @Override
    public void load() throws IOException, ConfigInvalidException {
        lock.readLock().lock();
        try {
            Boolean wasRead = FileUtils.readWithRetries(getFile(), f -> loadConfigFromFile(f));
            if (wasRead == null) {
                handleNoConfigFile();
            }
            exists.set(wasRead != null);
        } catch (IOException e) {
            throw e;
        } catch (Exception e) {
            throw new ConfigInvalidException(MessageFormat
                    .format(JGitText.get().cannotReadFile, getFile()), e);
        } finally {
            lock.readLock().unlock();
        }
    }

    private Boolean loadConfigFromFile(File f) throws IOException, ConfigInvalidException {
        FileSnapshot oldSnapshot = snapshot;
        FileSnapshot newSnapshot = FileSnapshot.saveNoConfig(f);
        byte[] in = IO.readFully(f);
        ObjectId newHash = hash(in);
        if (hash.equals(newHash)) {
            updateSnapshotIfUnchanged(oldSnapshot, newSnapshot);
        } else {
            decodeAndParse(in, newSnapshot, newHash);
        }
        return Boolean.TRUE;
    }

    private void handleNoConfigFile() {
        clear();
        snapshot = FileSnapshot.MISSING_FILE;
    }

    private void decodeAndParse(byte[] in, FileSnapshot newSnapshot, ObjectId newHash) throws ConfigInvalidException {
        String decoded;
        if (isUtf8(in)) {
            decoded = RawParseUtils.decode(UTF_8, in, 3, in.length);
            utf8Bom = true;
        } else {
            decoded = RawParseUtils.decode(in);
        }
        fromText(decoded);
        snapshot = newSnapshot;
        hash = newHash;
    }

    private void updateSnapshotIfUnchanged(FileSnapshot oldSnapshot, FileSnapshot newSnapshot) {
        if (oldSnapshot.equals(newSnapshot)) {
            oldSnapshot.setClean(newSnapshot);
        } else {
            snapshot = newSnapshot;
        }
    }

    @Override
    public void save() throws IOException {
        lock.writeLock().lock();
        try {
            String text = toText();
            byte[] out = encodeConfigText(text);
            writeConfigToLockFile(out);
            hash = hash(out);
            exists.set(true);
        } finally {
            lock.writeLock().unlock();
        }
        fireConfigChangedEvent();
    }

    private byte[] encodeConfigText(String text) throws IOException {
        if (utf8Bom) {
            final ByteArrayOutputStream bos = new ByteArrayOutputStream();
            bos.write(0xEF);
            bos.write(0xBB);
            bos.write(0xBF);
            bos.write(text.getBytes(UTF_8));
            return bos.toByteArray();
        } else {
            return Constants.encode(text);
        }
    }

    private void writeConfigToLockFile(byte[] out) throws IOException {
        LockFile lf = new LockFile(getFile());
        try {
            if (!lf.lock()) {
                throw new LockFailedException(getFile());
            }
            lf.setNeedSnapshotNoConfig(true);
            lf.write(out);
            if (!lf.commit()) {
                throw new IOException(MessageFormat.format(
                        JGitText.get().cannotCommitWriteTo, getFile()));
            }
        } finally {
            lf.unlock();
        }
        snapshot = lf.getCommitSnapshot();
    }

    @Override
    public void clear() {
        hash = hash(new byte[0]);
        super.clear();
    }

    private static ObjectId hash(byte[] rawText) {
        return ObjectId.fromRaw(Constants.newMessageDigest().digest(rawText));
    }

    @SuppressWarnings("nls")
    @Override
    public String toString() {
        return getClass().getSimpleName() + "[" + getFile().getPath() + "]";
    }

    public boolean isOutdated() {
        return snapshot.isModified(getFile());
    }

    @Override
    protected byte[] readIncludedConfig(String relPath)
            throws ConfigInvalidException {
        final File file;
        if (relPath.startsWith("~/")) { //$NON-NLS-1$
            file = fs.resolve(fs.userHome(), relPath.substring(2));
        } else {
            file = fs.resolve(configFile.getParentFile(), relPath);
        }

        if (!file.exists()) {
            return null;
        }

        try {
            return IO.readFully(file);
        } catch (FileNotFoundException e) {
            return null;
        } catch (IOException ioe) {
            throw new ConfigInvalidException(MessageFormat
                    .format(JGitText.get().cannotReadFile, relPath), ioe);
        }
    }
}
```

**Summary of why:**
The original `load()` and `save()` methods contain several independent tasks strung together, making them difficult to read and maintain. Extracting key code blocks into private methods makes the class easier to navigate and the intent of each step clearer. This is a textbook case for **extract method** refactoring.

Levenshtein edit-distance: 2823